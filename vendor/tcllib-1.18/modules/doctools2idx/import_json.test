# -*- tcl -*-
# idx_import_json.test:  tests for the doctools::idx::import::json package/plugin.
#
# Copyright (c) 2009 by Andreas Kupries <andreas_kupries@users.sourceforge.net>
# All rights reserved.
#
# RCS: @(#) $Id: import_json.test,v 1.1 2009/04/01 04:28:37 andreas_kupries Exp $

# -------------------------------------------------------------------------

source [file join \
	[file dirname [file dirname [file join [pwd] [info script]]]] \
	devtools testutilities.tcl]

testsNeedTcl     8.4
testsNeedTcltest 2.0

support {
    use fileutil/fileutil.tcl  fileutil
    use struct/list.tcl        struct::list

    # Copy of code from idx_import_json.tcl, to define dict support
    # even where dict is not really present on the system.

    if {[package vcompare [package present Tcl] 8.5] < 0} {
	if {[catch {
	    package require dict
	}]} {
	    # Create a pure Tcl implementation of the dict methods
	    # required by json, and fake the presence of the dict package.
	    proc dict {cmd args} { return [uplevel 1 [linsert $args 0 dict/$cmd]] }
	    proc dict/create {} { return {} }
	    proc dict/set {var key val} {
		upvar 1 $var a
		array set x $a
		set x($key) $val
		set a [array get x]
		return
	    }
	    package provide dict 1
	}
    }
    use json/json.tcl          json

    useLocal structure.tcl doctools::idx::structure

    #msgcat::mclocale C
}
testing {
    package provide doctools::idx::import::plugin 1
    # The above fakes plugin environment. Well, not completely. By
    # leaving out a definition for the 'include' alias the plugin is
    # signaled that there is no need to overwrite the GetFile command
    # of doctools::idx::parse with a version calling out to the plugin
    # manager, i.e. that it can still use the regular file operations.

    useLocal import_json.tcl doctools::idx::import::json
}

source [tcllibPath doctools2base/tests/common]
set mytestdir tests/data

# -------------------------------------------------------------------------

# General set of error cases regarding the number of arguments.

test doctools-idx-import-json-1.0 {import, wrong#args} -body {
    import
} -returnCodes error -result {wrong # args: should be "import text configuration"}

test doctools-idx-import-json-1.1 {import, wrong#args} -body {
    import T
} -returnCodes error -result {wrong # args: should be "import text configuration"}

test doctools-idx-import-json-1.2 {import, wrong#args} -body {
    import T C XXX
} -returnCodes error -result {wrong # args: should be "import text configuration"}

# idx_import_json tests, numbering starts at 2
# -------------------------------------------------------------------------

# We are checking that the various forms of json markup, as can be
# generated by doctools::idx(::export(::json)) are valid input to the
# json parser.
#
# section {} holds the non-canonical input we have to accept and make
# canonical to higher layers.

foreach {k section} {
    0 {}
    1 -ultracompact
    2 -indented
    3 -indalign
} {
    TestFilesProcess $mytestdir ok json$section serial-print -> n label input data expected {
	test doctools-idx-import-json-2.$k.$n "doctools::idx::import::json, $label$section, ok" -body {
	    doctools::idx::structure print [import $data {}]
	} -result $expected
    }
}

# -------------------------------------------------------------------------

# We test the error messages and codes thrown by the parser for a
# variety of failure possibilities.

TestFilesProcess $mytestdir fail json json-emsg -> n label input data expected {
    test doctools-idx-import-json-3.$n "doctools::idx::import::json, $label, error message" -body {
	import $data {}
    } -returnCodes error -result $expected
}

#----------------------------------------------------------------------
testsuiteCleanup
return
