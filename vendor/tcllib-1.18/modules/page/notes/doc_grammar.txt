Raw PE Grammar AS Tree
======================

This file documents the tree generated by the frontend for reading a
PE grammar in textual form.

General information
-------------------

* The tree is implemented using 'struct::tree'.
* It is an abstract syntax tree semantically.

Structure
---------

* The root node has one child, of type ALL (*), we call this ALL.

* The structure of the tree under the node ALL reflects the structure
  of the PE grammar used by the frontend to read grammar.

  - Void nonterminals are leafs of the tree.

  - Match nonterminals have one child node carrying the matched
    terminal string.

  - All other nonterminals have children per the structure of the rule
    matched and the nonterminals therein.

~~
(*) <=> ((type == nonterminal) && (text == ALL))

Attributes
----------

The node root is exceptional, it has no attributes. The "set of all
nodes" referenced in the descriptions below does not include it.

Name	Type	Details
----	----	-------
type	enum	At all nodes. Values in {terminal, nonterminal}. The
		type of the node, telling us if it is a container for
		a nonterminal symbol or for a terminal string.
----	----	-------
detail	string	At all nodes. Meaning of its value is dependent on the
		value of the attribute 'type'.
	
		nonterminal : Name of symbol
	
		terminal    : Terminal data.
	
			      This is always the lexeme, as found in
			      the input. For character data from
			      strings this means that the text
			      contains the special forms as well,
			      i.e. quoted with backslashes.
====	====	=======
at	int	Restricted to nodes of type 'terminal'. Represents the  
atcol	int	location in the input where the terminal data starts    
atline	int	(= the location of the first character), as offset,     
		and in line/column notation (*)
----	----	-------
to	int	As above, but representing the end location.
tocol	int
toline	int
----	----	-------

~~
(*) Lines are counted from 1. Columns are counted from 0.
