<html>
<head>
<!-- This file has been generated by unroff 1.0, 05/30/98 15:43:05. -->
<!-- Do not edit! -->
<!--  $Id: comm.n.html,v 1.3 2004/01/15 06:36:12 andreas_kupries Exp $ -->
<!--  %%_OSF_FREE_COPYRIGHT_%% -->
<!--  Copyright (C) 1995-1998 The Open Group.   All Rights Reserved. -->
<!--  (Please see the file "comm.LICENSE" that accompanied this source) -->
<!--  unroff -fhtml -man comm.n -->
<!--  (then fix &lt;title&gt;) -->
<!--      # CS - begin code excerpt -->
<!--      # CE - end code excerpt -->
<title>Manual page for comm(n) version 3.7.1</title>
</head>
<body>
<h2>
comm.tcl - A remote communications facility for Tcl (7.6, 8.0, and later)
<hr></h2>
<h2>SYNOPSIS</h2>
<b>package require Comm 3</b>
<p>
<!--  define all interfaces ONCE -->
<!--  iD taken (see i2) -->
<!--  iE taken (see i6) -->
<!--  iF taken (see i6) -->
<!--  Show all interfaces -->
<b></b><i>chan</i><b> send </b>?<i>-async</i>? <i>id cmd </i>?<i>arg arg ...</i>?<tt> </tt>
<p>
<b></b><i>chan</i><b> interps</b>
<p>
<b></b><i>chan</i><b> ids</b>
<p>
<b></b><i>chan</i><b> self</b>
<p>
<b></b><i>chan</i><b> connect </b>?<i>id</i>?<tt> </tt>
<p>
<b></b><i>chan</i><b> config
<br>
</b><b></b><i>chan</i><b> config </b><i>name</i>
<br>
<b></b><i>chan</i><b> config ?</b><i>name value ...</i>?<tt> </tt>
<br>
<dl><dt><dd>
-<b>listen </b>?<i>0|1</i>?<tt> </tt>
-<b>local </b>?<i>0|1</i>?<tt> </tt>
-<b>port </b>?<i>port</i>?<tt> </tt>
</dl>
<p>
<b></b><i>chan</i><b> new </b><i>chan</i> ?<i>name value ...</i>?<tt> </tt>
<p>
<b></b><i>chan</i><b> channels</b>
<p>
<b></b><i>chan</i><b> shutdown </b><i>id</i>
<p>
<b></b><i>chan</i><b> abort</b>
<p>
<b></b><i>chan</i><b> destroy</b>
<p>
<b></b><i>chan</i><b> remoteid</b>
<p>
<b></b><i>chan</i><b> hook </b><i>event</i> ?<b>+</b>??<i>script</i>?<tt> </tt>
<p>
The package initializes <b>comm</b> as the default <i>chan</i>.<tt> </tt>
<h2>INTRODUCTION</h2>
<p>
The
<b>comm
</b>command provides an inter-interpreter remote execution facility
much like Tk's
<i>send</i>(n)<i>,
</i>except that it uses sockets rather than
the X server for the communication path.<tt> </tt>
As a result,
<b>comm
</b>works with multiple interpreters,
works on Windows and Macintosh systems,
and
provides control over the remote execution path.<tt> </tt>
<p>
These commands work just like
<b>send
</b>and
<b>winfo interps</b>:
<tt></tt><dl><dt><dd>
<b></b><b>comm</b><b> send </b>?<i>-async</i>? <i>id cmd </i>?<i>arg arg ...</i>?
<br>
<b></b><b>comm</b><b> interps</b>
<br>
</dl>
This is all that is really needed to know in order to use
<b>comm</b>.<tt> </tt>
<h2>DESCRIPTION</h2>
<p>
<b>comm
</b>names communication endpoints with an
<i>id
</i>unique to each machine.<tt> </tt>
Before sending commands, the
<i>id
</i>of another interpreter is needed.<tt> </tt>
Unlike Tk's send,
<b>comm
</b>doesn't implicitly know the
<i>id</i>'s
of all the interpreters on the system.<tt> </tt>
<dl>
<dt><b></b><b>comm</b><b> send </b>?<i>-async</i>? <i>id cmd </i>?<i>arg arg ...</i>?<tt> </tt>
<dd>
This invokes the given command in the interpreter named by
<i>id</i>.<tt> </tt>
The command waits for the result and remote errors are returned
unless the
<b>-async
</b>option is given.<tt> </tt>
<dt><b></b><b>comm</b><b> self</b>
<dd>
Returns the
<i>id
</i>for this channel.<tt> </tt>
<dt><b></b><b>comm</b><b> interps</b>
<dd>
Returns a list of all the remote
<i>id</i>'s
to which this channel is connected.<tt> </tt>
<b>comm
</b>learns a new remote
<i>id
</i>when a command is first issued it,
or when a remote
<i>id
</i>first issues a command to this comm channel.<tt> </tt>
<b></b><b>comm</b><b> ids</b>
is an alias for this method.<tt> </tt>
<dt><b></b><b>comm</b><b> connect </b>?<i>id</i>?<tt> </tt>
<dd>
Whereas
<b>comm send
</b>will automatically connect to the given
<i>id</i>,
this forces a connection to a remote
<i>id
</i>without sending a command.<tt> </tt>
After this, the remote
<i>id
</i>will appear in
<b>comm interps</b>.<tt> </tt>
</dl>
<p>
These four methods make up the basic
<b>comm
</b>interface.<tt> </tt>
<h2>EVAL SEMANTICS</h2>
<p>
The evaluation semantics of
<b>comm send
</b>are intended to match Tk's
<b>send
</b><i>exactly</i>.<tt> </tt>
This means that
<b>comm
</b>evaluates arguments on the remote side.<tt> </tt>
<p>
If you find that
<b>comm send
</b>doesn't work for a particular command,
try the same thing with Tk's send and see if the result is different.<tt> </tt>
If there is a problem, please report it.<tt> </tt>
For instance, there was had one report that this command produced an error.<tt> </tt>
Note that the equivalent
<b>send
</b>command also produces the same error.<tt> </tt>
<tt></tt><dl><dt><dd>
% <b>comm send </b><i>id</i><b> llength {a b c}</b>
<br>
<b>wrong # args: should be "llength list"</b>
<br>
% <b>send </b><i>name</i><b> llength {a b c}</b>
<br>
<b>wrong # args: should be "llength list"</b>
<br>
</dl>
<p>
The
<b>eval
</b>hook (described below) can be used to change from
<b>send</b>'s
double eval semantics to single eval semantics.<tt> </tt>
<h2>MULTIPLE CHANNELS</h2>
<p>
More than one
<b>comm
</b>channel (or
<i>listener</i>)
can be created in each Tcl interpeter.<tt> </tt>
This allows flexibility to create full and restricted channels.<tt> </tt>
For instance,
<b>hook
</b>scripts are specific to the channel they are defined against. 
<dl>
<dt><b></b><b>comm</b><b> new </b><i>chan</i> ?<i>name value ...</i>?<tt> </tt>
<dd>
This creates a new channel and Tcl command with the given channel name.<tt> </tt>
This new command controls the new channel and takes all the same
arguments as
<b>comm</b>.<tt> </tt>
Any remaining arguments are passed to the
<b>config
</b>method.<tt> </tt>
<dt><b></b><b>comm</b><b> channels</b>
<dd>
This lists all the channels allocated in this Tcl interpreter.<tt> </tt>
</dl>
<p>
The default configuration parameters for a new channel are:
<tt></tt><dl><dt><dd>
<b>-port 0 -local 1 -listen 0
</b></dl>
The default channel
<b>comm
</b>is created with:
<tt></tt><dl><dt><dd>
<b>comm new comm -port 0 -local 1 -listen 1
</b></dl>
<h2>CHANNEL CONFIGURATION</h2>
<p>
The
<b>config
</b>method acts similar to
<b>fconfigure
</b>in that it sets or queries configuration variables associated with a channel.<tt> </tt>
<dl><dt><dd>
<b></b><b>comm</b><b> config
<br>
</b><b></b><b>comm</b><b> config </b><i>name</i>
<br>
<b></b><b>comm</b><b> config ?</b><i>name value ...</i>?<tt> </tt>
</dl>
When given no arguments,
<b>config
</b>returns a list of all variables and their value
With one argument,
<b>config
</b>returns the value of just that argument.<tt> </tt>
With an even number of arguments, the given variables are set to the
given values.<tt> </tt>
<p>
These configuration variables can be changed
(descriptions of them are elsewhere in this manual page):
<dl><dt><dd>
-<b>listen </b>?<i>0|1</i>?<tt> </tt>
-<b>local </b>?<i>0|1</i>?<tt> </tt>
-<b>port </b>?<i>port</i>?<tt> </tt>
</dl>
<p>
These configuration variables are readonly:
<dl><dt><dd>
-<b>chan</b> <i>chan</i>
-<b>serial</b> <i>n</i>
-<b>socket</b> sock<i>n</i>
</dl>
<p>
When
<b>config
</b>changes the parameters of an existing channel,
it closes and reopens the listening socket.<tt> </tt>
An automatically assigned channel
<i>id
</i>will change when this happens.<tt> </tt>
Recycling the socket is done by invoking
<b>comm abort</b>,
which causes all active sends to terminate.<tt> </tt>
<h2>ID/PORT ASSIGNMENTS</h2>
<p>
<b>comm
</b>uses a TCP port for endpoint
<i>id</i>.<tt> </tt>
The
<b>interps
</b>(or
<b>ids</b>)
method merely lists all the TCP ports to which the channel is connected.<tt> </tt>
By default, each channel's
<i>id
</i>is randomly assigned by the operating system
(but usually starts at a low value around 1024 and increases
each time a new socket is opened).<tt> </tt>
This behavior is accomplished by giving the
<b>-port
</b>config option a value of 0.<tt> </tt>
Alternately, a specific TCP port number may be provided for a given channel.<tt> </tt>
As a special case, comm contains code to allocate a
a high-numbered TCP port (&gt;10000) by using
<b>-port {}</b>.<tt> </tt>
Note that a channel won't be created and initialized
unless the specific port can be allocated.<tt> </tt>
<p>
As a special case, if the channel is configured with
<b>-listen 0</b>,
then it will not create a listening socket and will use an id of
<i>0
</i>for itself.<tt> </tt>
Such a channel is only good for outgoing connections
(although once a connection is established, it can carry send traffic
in both directions).<tt> </tt>
<h2>REMOTE INTERPRETERS</h2>
<p>
By default, each channel is restricted to accepting connections from the
local system.  This can be overriden by using the
<b>-local 0
</b>configuration option
For such channels, the
<i>id
</i>parameter takes the form
<b>{</b><i>id host</i><b>}
</b><b></b>.<tt> </tt>
<p>
<b>WARNING</b>:
The
<i>host
</i>must always be specified in the same form
(e.g., as either a fully qualified domain name,
plain hostname or an IP address).<tt> </tt>
<h2>CLOSING CONNECTIONS</h2>
<p>
These methods give control over closing connections:
<dl>
<dt><b></b><b>comm</b><b> shutdown </b><i>id</i>
<dd>
This closes the connection to
<i>id</i>,
aborting all outstanding commands in progress.  Note that nothing
prevents the connection from being immediately reopened by another
incoming or outgoing command.<tt> </tt>
<dt><b></b><b>comm</b><b> abort</b>
<dd>
This invokes shutdown on all open connections in this comm channel.<tt> </tt>
<dt><b></b><b>comm</b><b> destroy</b>
<dd>
This aborts all connections and then destroys the this comm channel itself,
including closing the listening socket.<tt> </tt>
Special code allows the default
<b>comm
</b>channel to be closed
such that the
<b>comm
</b>command it is not destroyed.<tt> </tt>
Doing so closes the listening socket, preventing both
incoming and outgoing commands on the channel.<tt> </tt>
This sequence reinitializes the default channel:
<tt></tt></dl>
<dl><dt><dd>
<b>comm destroy; comm new comm
</b></dl>
<p>
When a remote connection is lost (because the remote exited or called
<b>shutdown</b>),
<b>comm
</b>can invoke an application callback.<tt> </tt>
This can be used to cleanup or restart an ancillary process,
for instance.<tt> </tt>
See the
<b>lost
</b>callback below.<tt> </tt>
<h2>CALLBACKS</h2>
<p>
This is a mechanism for setting hooks for particular events:
<tt></tt><dl><dt><dd>
<b></b><b>comm</b><b> hook </b><i>event</i> ?<b>+</b>??<i>script</i>?
<br>
</dl>
<p>
This uses a syntax similar to Tk's
<b>bind
</b>command.<tt> </tt>
Prefixing
<i>script
</i>with a + causes the new script to be appended.<tt> </tt>
Without this, a new
<i>script
</i>replaces any existing script.<tt> </tt>
When invoked without a script, no change is made.<tt> </tt>
In all cases, the new hook script is returned by the command.<tt> </tt>
<p>
When an
<i>event
</i>occurs,
the
<i>script
</i>associated with it is evaluated
with the listed variables in scope and available.<tt> </tt>
The return code
(<b>not
</b>the return value) of the script
is commonly used decide how to further process after the hook.<tt> </tt>
<p>
Common variables include:
<dl><dt><dd>
<dl>
<dt><b>chan</b><dd>
the name of the comm channel (and command)
<dt><b>id</b><dd>
the id of the remote in question
<dt><b>fid</b><dd>
the file id for the socket of the connection
</dl>
</dl>


These are the defined
<i>events</i>:
<dl>
<dt><b>connecting
</b><dd>
Variables:
<i>chan id host port
</i><br>
This hook is invoked before making a connection
to the remote named in
<i>id</i>.<tt> </tt>
An error return (via
<b>error</b>)
will abort the connection attempt with the error.<tt> </tt>
Example:
<p>
<tt></tt></dl>
<dl><dt><dd>
% comm hook connecting {
<br>
    if [string match {*[02468]} $id] {
<br>
        error "Can't connect to even ids" 
<br>
    }
<br>
}
<br>
% comm send 10000 puts ok
<br>
Connect to remote failed: Can't connect to even ids
<br>
% 
<br>
</dl>

<dl>
<dt><b>connected
</b><dd>
Variables:
<i>chan fid id host port
</i><br>
This hook is invoked immediately after making a remote connection to
<i>id</i>,
allowing arbitrary authentication over the socket
named by
<i>fid</i>.<tt> </tt>
An error return (via
<b>error</b>)
will close the connection with the error.<tt> </tt>
<i>host
</i>and
<i>port
</i>are merely extracted from the
<i>id</i>;
changing any of these will have no effect on the connection, however.<tt> </tt>
It is also possible to substitute and replace
<i>fid .
</i>

<dt><b>incoming
</b><dd>
Variables:
<i>chan fid addr remport
</i><br>
Hook invoked when receiving an incoming connection,
allowing arbitrary authentication over socket
named by
<i>fid</i>.<tt> </tt>
An error return (via
<b>error</b>)
will close the connection with the error.<tt> </tt>
Note that the peer is named by
<i>remport</i> and <i>addr
</i>but that the remote
<i>id
</i>is still unknown.  Example:
<p>
<tt></tt></dl>
<dl><dt><dd>
comm hook incoming {
<br>
    if [string match 127.0.0.1 $addr] {
<br>
        error "I don't talk to myself"
<br>
    }
<br>
}
<br>
</dl>

<dl>
<dt><b>eval
</b><dd>
Variables:
<i>chan id cmd buffer
</i><br>
This hook is invoked after collecting a complete script from a remote
but
<b>before
</b>evalutating it.<tt> </tt>
This allows complete control over the processing of incoming commands.<tt> </tt>
<i>cmd
</i>contains either
<b>send</b> or <b>async</b>.<tt> </tt>
<i>buffer
</i>holds the script to evaluate.<tt> </tt>
At the time the hook is called,
<b>$chan remoteid
</b>is identical in value to
<b>id.
</b><p>
By changing
<i>buffer</i>,
the hook can change the script to be evaluated.<tt> </tt>
The hook can short circuit evaluation and cause a
value to be immediately returned by using
<b>return
</b><i>result
</i>(or, from within a procedure,
<b>return -code return
</b><i>result</i>).<tt> </tt>
An error return (via
<b>error</b>)
will return an error result, as is if the script caused the error.<tt> </tt>
Any other return will evaluate the script in
<i>buffer
</i>as normal.<tt> </tt>
For compatibility with 3.2,
<b>break
</b>and
<b>return -code break
</b><i>result
</i>is supported, acting similarly to
<b>return {}
</b>and
<b>return -code return
</b><i>result</i>.<tt> </tt>
<p>
Examples:
</dl>
<dl><dt><dd>
1. augmenting a command
<tt></tt><dl><dt><dd>
% comm send [comm self] pid
<br>
5013
<br>
% comm hook eval {puts "going to execute $buffer"}
<br>
% comm send [comm self] pid
<br>
going to execute pid
<br>
5013
<br>
</dl>
2. short circuting a command
<tt></tt><dl><dt><dd>
% comm hook eval {puts "would have executed $buffer"; return 0}
<br>
% comm send [comm self] pid
<br>
would have executed pid
<br>
0
<br>
</dl>
3. Replacing double eval semantics
<tt></tt><dl><dt><dd>
% comm send [comm self] llength {a b c}
<br>
wrong # args: should be "llength list"
<br>
% comm hook eval {return [uplevel #0 $buffer]}
<br>
return [uplevel #0 $buffer]
<br>
% comm send [comm self] llength {a b c}
<br>
3
<br>
</dl>
4. Using a slave interpreter
<tt></tt><dl><dt><dd>
% interp create foo
<br>
% comm hook eval {return [foo eval $buffer]}
<br>
% comm send [comm self] set myvar 123
<br>
123
<br>
% set myvar
<br>
can't read "myvar": no such variable
<br>
% foo eval set myvar
<br>
123
<br>
</dl>
5. Using a slave interpreter (double eval)
<tt></tt><dl><dt><dd>
% comm hook eval {return [eval foo eval $buffer]}
<br>
</dl>
6. Subverting the script to execute
<tt></tt><dl><dt><dd>
% comm hook eval {
<br>
    switch -- $buffer {
<br>
        a {return A-OK} b {return B-OK} default {error "$buffer is a no-no"}
<br>
    }
<br>
}
<br>
% comm send [comm self] pid
<br>
pid is a no-no
<br>
% comm send [comm self] a
<br>
A-OK
<br>
</dl>
</dl>

<dl>
<dt><b>reply
</b><dd>
Variables:
<i>chan id buffer ret return()
</i><br>
This hook is invoked after collecting a complete reply script from a remote
but
<b>before
</b>evalutating it.<tt> </tt>
This allows complete control over the processing of replies to sent commands.<tt> </tt>
The reply
<i>buffer
</i>is in one of the following forms
</dl>
<dl><dt><dd>
<tt></tt><dl><dt><dd>
return <i>result</i>
<br>
return -code <i>code</i> <i>result</i>
<br>
return -code <i>code</i> -errorinfo <i>info</i> -errorcode <i>ecode</i> <i>msg</i>
<br>
</dl>
For safety reasons, this is decomposed.  The return result
is in 
<i>ret</i>,
and the return switches are in the return array:
<tt></tt><dl><dt><dd>
<i>return(-code)
</i><i>return(-errorinfo)
</i><i>return(-errordcode)
</i></dl>
Any of these may be the empty string.<tt> </tt>
Modifying
these four variables can change the return value, whereas
modifying
<i>buffer
</i>has no effect.<tt> </tt>
</dl>

<dl>
<dt><b>lost
</b><dd>
Variables:
<i>chan id reason
</i><br>
This hook is invoked when the connection to
<i>id
</i>is lost.<tt> </tt>
Return value (or thrown error) is ignored.<tt> </tt>
<i>reason
</i>is an explanatory string indicating why the connection was lost.<tt> </tt>
Example:
<p>
<tt></tt></dl>
<dl><dt><dd>
comm hook lost {
<br>
    global myvar
<br>
    if {$myvar(id) == $id} {
<br>
        myfunc
<br>
        return
<br>
    }
<br>
}
<br>
</dl>
<h2>UNSUPPORTED</h2>
<p>
These interfaces may change or go away in subsequence releases.<tt> </tt>
<dl>
<dt><b></b><b>comm</b><b> remoteid</b>
<dd>
Returns the
<i>id
</i>of the sender of the last remote command executed on this channel.<tt> </tt>
If used by a proc being invoked remotely, it
must be called before any events are processed.<tt> </tt>
Otherwise, another command may get invoked and change the value.<tt> </tt>
<dt><b>comm_send
</b><dd>
Invoking this procedure will substitute the Tk
<b>send
</b>and
<b>winfo interps
</b>commands with these equivalents that use
<b>comm</b>.<tt> </tt>
<p>
<tt></tt></dl>
<dl><dt><dd>
proc send {args} {
<br>
    eval comm send $args
<br>
}
<br>
rename winfo tk_winfo
<br>
proc winfo {cmd args} {
<br>
    if ![string match in* $cmd] {return [eval [list tk_winfo $cmd] $args]}
<br>
    return [comm interps]
<br>
}
<br>
</dl>
<h2>SECURITY</h2>
<p>
Something here soon.<tt> </tt>
<h2>BLOCKING SEMANTICS</h2>
<p>
There is one outstanding difference between
<b>comm
</b>and
<b>send</b>.<tt> </tt>
When blocking in a synchronous remote command,
<b>send
</b>uses an internal C hook (Tk_RestrictEvents)
to the event loop to look ahead for
send-related events and only process those without processing any other events.<tt> </tt>
In contrast,
<b>comm
</b>uses the
<b>vwait
</b>command as a semaphore to indicate the return message has arrived.<tt> </tt>
The difference is that a synchornous
<b>send
</b>will block the application and prevent all events
(including window related ones) from being processed,
while a synchronous
<b>comm
</b>will block the application but still allow
other events will still get processed.<tt> </tt>
In particular,
<b>after idle
</b>handlers will fire immediately when comm blocks.<tt> </tt>
<p>
What can be done about this?<tt> </tt>
First, note that this behavior will come from any code using
<b>vwait
</b>to block and wait for an event to occur.<tt> </tt>
At the cost of multiple channel support,
<b>comm
</b>could be changed to do blocking I/O on the socket,
givng send-like blocking semantics.<tt> </tt>
However, multiple channel support is a very useful feature of comm
that it is deemed too important to lose.<tt> </tt>
The remaining approaches involve a new loadable module written in C
(which is somewhat against the philosophy of
<b>comm</b>)
One way would be to create a modified version of the
<b>vwait
</b>command that allow the event flags passed to Tcl_DoOneEvent to be specified.<tt> </tt>
For
<b>comm</b>,
just the TCL_FILE_EVENTS would be processed.<tt> </tt>
Another way would be to implement a mechanism like Tk_RestrictEvents, but
apply it to the Tcl event loop (since
<b>comm
</b>doesn't require Tk).<tt> </tt>
One of these approaches will be available in a future
<b>comm
</b>release as an optional component.<tt> </tt>
<h2>COMPATIBILITY</h2>
<p>
<b>Comm
</b>exports itself as a package.<tt> </tt>
The package version number is in the form
<i>major</i>.<i>minor</i>,
where the major version will only change when
a non-compatible change happens to the API or protocol.<tt> </tt>
Minor bug fixes and changes will only affect the minor version.<tt> </tt>
To load
<b>comm
</b>this command is usually used:
<tt></tt><dl><dt><dd>
<b>package require Comm 3</b>
<br>
</dl>
Note that requiring no version (or a specific version) can also be done.<tt> </tt>
<p>
The revision history of
<b>comm
</b>includes these releases:

<dl>
<dt>3.6<dd>
A bug in the looking up of the remoteid for a executed command
could be triggered when the connection was closed while several
asynchronous sends were queued to be executed.<tt> </tt>

<dt>3.5<dd>
Internal change to how reply messages from a
<b>send
</b>are handled.<tt> </tt>
Reply messages are now decoded into the
<i>value
</i>to pass to
<b>return</b>;
a new return statement is then cons'd up to with this value.<tt> </tt>
Previously, the return code was passed in from the remote as a
command to evaluate.  Since the wire protocol has not changed,
this is still the case.  Instead, the reply handling code decodes the
<b>reply
</b>message.<tt> </tt>

<dt>3.4<dd>
Added more source commentary, as well as documenting config variables
in this man page.<tt> </tt>
Fixed bug were loss of connection would give error about a variable
named
rather than the message about the lost connection.<tt> </tt>
<b>comm ids
</b>is now an alias for
<b>comm interps
</b>(previously, it an alias for
<b>comm chans</b>).<tt> </tt>
Since the method invocation change of 3.0, break and other exceptional
conditions were not being returned correctly from
<b>comm send</b>.<tt> </tt>
This has been fixed by removing the extra level of indirection into
the internal procedure
<b>commSend</b>.<tt> </tt>
Also added propogation of the
<i>errorCode
</i>variable.<tt> </tt>
This means that these commands return exactly as they would with
<b>send</b>:
</dl>
<dl><dt><dd>
<tt></tt><dl><dt><dd>
comm send <i>id</i> break
<br>
catch {comm send <i>id</i> break}
<br>
comm send <i>id</i> expr 1 / 0
<br>
</dl>
Added a new hook for reply messages.<tt> </tt>
Reworked method invocation to avoid the use of comm:* procedures;
this also cut the invocation time down by 40%.<tt> </tt>
Documented
<b>comm config
</b>(as this manual page still listed the defunct
<b>comm init</b>!)
</dl>

<dl>
<dt>3.3<dd>
Some minor bugs were corrected and the documentation was cleaned up.<tt> </tt>
Added some examples for hooks.  The return semantics of the
<b>eval
</b>hook were changed.<tt> </tt>

<dt>3.2<dd>
A new wire protocol, version 3, was added.  This is backwards compatible
with version 2 but adds an exchange of supported protocol versions to
allow protocol negotiation in the future.<tt> </tt>
Several bugs with the hook implementation were fixed.<tt> </tt>
A new section of the man page on blocking semantics was added.<tt> </tt>

<dt>3.1<dd>
All the documented hooks were implemented.<tt> </tt>
<b>commLostHook
</b>was removed.<tt> </tt>
A bug in
<b>comm new
</b>was fixed.<tt> </tt>

<dt>3.0<dd>
This is a new version of
<b>comm
</b>with several major changes.<tt> </tt>
There is a new way of creating the methods available under the
<b>comm
</b>command.<tt> </tt>
The
<b>comm init
</b>method has been retired and is replaced by
<b>comm configure
</b>which allows access to many of the well-defined internal variables.<tt> </tt>
This also generalizes the options available to
<b>comm new</b>.<tt> </tt>
Finally, there is now a protocol version exchanged when a connection
is established.  This will allow for future on-wire protocol changes.<tt> </tt>
Currently, the protocol version is set to 2.<tt> </tt>

<dt>2.3<dd>
<b>comm ids
</b>was renamed to
<b>comm channels .
</b>General support for
<b>comm hook
</b>was fully implemented, but
only the
<b>lost
</b>hook exists, and it was changed to follow the general hook API.<tt> </tt>
<b>commLostHook
</b>was unsupported (replaced by
<b>comm hook lost )
</b>and
<b>commLost
</b>was removed.<tt> </tt>

<dt>2.2<dd>
The 
<b>died
</b>hook was renamed
<b>lost</b>,
to be accessed by
<b>commLostHook
</b>and an early implementation of
<b>comm lost hook</b>.<tt> </tt>
As such,
<b>commDied
</b>is now
<b>commLost</b>.<tt> </tt>

<dt>2.1<dd>
Unsupported method
<b>comm remoteid
</b>was added.<tt> </tt>

<dt>2.0<dd>
<b>comm
</b>has been rewritten from scratch (but is fully compatible with Comm 1.0,
without the requirement to use obTcl).<tt> </tt>
</dl>
<h2>SEE ALSO</h2>
<i>send</i>(n)
<h2>AUTHOR</h2>
John LoVerso, John@LoVerso.Southborough.MA.US
<p>
<i>http://www.opengroup.org/~loverso/tcl-tk/#comm
</i><h2>COPYRIGHT</h2>
Copyright (C) 1995-1998 The Open Group.   All Rights Reserved.<tt> </tt>
Please see the file
<i>comm.LICENSE
</i>that accompanied this source,
or
<i>http://www.opengroup.org/www/dist_client/caubweb/COPYRIGHT.free.html</i>.<tt> </tt>
<p>
This license for
<b>comm</b>,
new as of version 3.2,
allows it to be used for free,
without any licensing fee or royalty.<tt> </tt>
<h2>BUGS</h2>
<ul>
<li>
If there is a failure initializing a channel created with
<b>comm new</b>,
then the channel should be destroyed.<tt> </tt>
Currently, it is left in an inconsistent state.<tt> </tt>
<li>
There should be a way to force a channel to quiesce when changing the
configuration.<tt> </tt>
</ul>
<p>
The following items can be implemented with the existing hooks
and are listed here as a reminder to provide a sample hook in a future version.<tt> </tt>
<ul>
<li>
Allow easier use of a slave interp for actual command execution
(especially when operating in "not local" mode).<tt> </tt>
<li>
Add host list (xhost-like) or "magic cookie" (xauth-like)
authentication to initial handshake.<tt> </tt>
</ul>
<p>
The following are outstanding todo items.<tt> </tt>
<ul>
<li>
Add an interp discovery and name-&gt;port mapping.<tt> </tt>
This is likely to be in a separate, optional nameserver.<tt> </tt>
(See also the related work, below.)
<li>
Fix the
<i>{id host}
</i>form so as not to be dependent upon canonical hostnames.<tt> </tt>
This requires fixes to Tcl to resolve hostnames!<tt> </tt>
</ul>
<p>
<p>
<p>
This man page is bigger than the source file.<tt> </tt>
<h2>ON USING OLD VERSIONS OF TCL</h2>
<p>
Tcl7.5 under Windows contains a bug that causes the interpreter to
hang when EOF is reached on non-blocking sockets.  This can be
triggered with a command such as this:
<tt></tt><dl><dt><dd>
<b>comm send $other exit
</b></dl>
Always make sure the channel is quiescent before closing/exiting or
use at least Tcl7.6 under Windows.<tt> </tt>
<p>
Tcl7.6 on the Mac contains several bugs.  It is recommended you use
at least Tcl7.6p2.<tt> </tt>
<p>
Tcl8.0 on UNIX contains a socket bug that can crash Tcl.  It is recommended
you use Tcl8.0p1 (or Tcl7.6p2).<tt> </tt>
<h2>RELATED WORK</h2>
<p>
Tcl-DP provides an RPC-based remote execution interface, but is a compiled
Tcl extension.  See
<i>http://www.cs.cornell.edu/Info/Projects/zeno/Projects/Tcl-DP.html</i>.<tt> </tt>
<p>
Michael Doyle &lt;miked@eolas.com&gt; has code that implements the Tcl-DP RPC
interface using standard Tcl sockets, much like
<b>comm</b>.<tt> </tt>
<p>
Andreas Kupries &lt;a.kupries@westend.com&gt; uses
<b>comm
</b>and has built a simple nameserver as part of his Pool library.<tt> </tt>
See
<i>http://www.westend.com/~kupries/doc/pool/index.htm</i>.<tt> </tt>
<!--  eof -->
<p><hr>
Markup created by <em>unroff</em> 1.0,&#160;<tt> </tt>&#160;<tt> </tt>May 30, 1998.
</body>
</html>
