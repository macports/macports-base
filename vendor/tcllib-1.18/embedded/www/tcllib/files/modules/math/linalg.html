
<div class='fossil-doc' data-title='math::linearalgebra - Tcl Math Library'>
<style>
    HTML {
	background: 	#FFFFFF;
	color: 		black;
    }
    BODY {
	background: 	#FFFFFF;
	color:	 	black;
    }
    DIV.doctools {
	margin-left:	10%;
	margin-right:	10%;
    }
    DIV.doctools H1,DIV.doctools H2 {
	margin-left:	-5%;
    }
    H1, H2, H3, H4 {
	margin-top: 	1em;
	font-family:	sans-serif;
	font-size:	large;
	color:		#005A9C;
	background: 	transparent;
	text-align:		left;
    }
    H1.doctools_title {
	text-align: center;
    }
    UL,OL {
	margin-right: 0em;
	margin-top: 3pt;
	margin-bottom: 3pt;
    }
    UL LI {
	list-style: disc;
    }
    OL LI {
	list-style: decimal;
    }
    DT {
	padding-top: 	1ex;
    }
    UL.doctools_toc,UL.doctools_toc UL, UL.doctools_toc UL UL {
	font:		normal 12pt/14pt sans-serif;
	list-style:	none;
    }
    LI.doctools_section, LI.doctools_subsection {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding: 	0em;
    }
    PRE {
	display: 	block;
	font-family:	monospace;
	white-space:	pre;
	margin:		0%;
	padding-top:	0.5ex;
	padding-bottom:	0.5ex;
	padding-left:	1ex;
	padding-right:	1ex;
	width:		100%;
    }
    PRE.doctools_example {
	color: 		black;
	background: 	#f5dcb3;
	border:		1px solid black;
    }
    UL.doctools_requirements LI, UL.doctools_syntax LI {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding:	0em;
    }
    DIV.doctools_synopsis {
	color: 		black;
	background: 	#80ffff;
	border:		1px solid black;
	font-family:	serif;
	margin-top: 	1em;
	margin-bottom: 	1em;
    }
    UL.doctools_syntax {
	margin-top: 	1em;
	border-top:	1px solid black;
    }
    UL.doctools_requirements {
	margin-bottom: 	1em;
	border-bottom:	1px solid black;
    }
</style>
 <hr> [
   <a href="../../../../toc.html">Main Table Of Contents</a>
| <a href="../../../toc.html">Table Of Contents</a>
| <a href="../../../../index.html">Keyword Index</a>
| <a href="../../../../toc0.html">Categories</a>
| <a href="../../../../toc1.html">Modules</a>
| <a href="../../../../toc2.html">Applications</a>
 ] <hr>
<div class="doctools">
<h1 class="doctools_title">math::linearalgebra(n) 1.1.5 tcllib &quot;Tcl Math Library&quot;</h1>
<div id="name" class="doctools_section"><h2><a name="name">Name</a></h2>
<p>math::linearalgebra - Linear Algebra</p>
</div>
<div id="toc" class="doctools_section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="doctools_toc">
<li class="doctools_section"><a href="#toc">Table Of Contents</a></li>
<li class="doctools_section"><a href="#synopsis">Synopsis</a></li>
<li class="doctools_section"><a href="#section1">Description</a></li>
<li class="doctools_section"><a href="#section2">PROCEDURES</a></li>
<li class="doctools_section"><a href="#section3">STORAGE</a></li>
<li class="doctools_section"><a href="#section4">REMARKS ON THE IMPLEMENTATION</a></li>
<li class="doctools_section"><a href="#section5">TODO</a></li>
<li class="doctools_section"><a href="#section6">NAMING CONFLICT</a></li>
<li class="doctools_section"><a href="#section7">Bugs, Ideas, Feedback</a></li>
<li class="doctools_section"><a href="#keywords">Keywords</a></li>
<li class="doctools_section"><a href="#category">Category</a></li>
<li class="doctools_section"><a href="#copyright">Copyright</a></li>
</ul>
</div>
<div id="synopsis" class="doctools_section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="doctools_synopsis">
<ul class="doctools_requirements">
<li>package require <b class="pkgname">Tcl <span class="opt">?8.4?</span></b></li>
<li>package require <b class="pkgname">math::linearalgebra <span class="opt">?1.1.5?</span></b></li>
</ul>
<ul class="doctools_syntax">
<li><a href="#1"><b class="cmd">::math::linearalgebra::mkVector</b> <i class="arg">ndim</i> <i class="arg">value</i></a></li>
<li><a href="#2"><b class="cmd">::math::linearalgebra::mkUnitVector</b> <i class="arg">ndim</i> <i class="arg">ndir</i></a></li>
<li><a href="#3"><b class="cmd">::math::linearalgebra::mkMatrix</b> <i class="arg">nrows</i> <i class="arg">ncols</i> <i class="arg">value</i></a></li>
<li><a href="#4"><b class="cmd">::math::linearalgebra::getrow</b> <i class="arg">matrix</i> <i class="arg">row</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></li>
<li><a href="#5"><b class="cmd">::math::linearalgebra::setrow</b> <i class="arg">matrix</i> <i class="arg">row</i> <i class="arg">newvalues</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></li>
<li><a href="#6"><b class="cmd">::math::linearalgebra::getcol</b> <i class="arg">matrix</i> <i class="arg">col</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></li>
<li><a href="#7"><b class="cmd">::math::linearalgebra::setcol</b> <i class="arg">matrix</i> <i class="arg">col</i> <i class="arg">newvalues</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></li>
<li><a href="#8"><b class="cmd">::math::linearalgebra::getelem</b> <i class="arg">matrix</i> <i class="arg">row</i> <i class="arg">col</i></a></li>
<li><a href="#9"><b class="cmd">::math::linearalgebra::setelem</b> <i class="arg">matrix</i> <i class="arg">row</i> <span class="opt">?col?</span> <i class="arg">newvalue</i></a></li>
<li><a href="#10"><b class="cmd">::math::linearalgebra::swaprows</b> <i class="arg">matrix</i> <i class="arg">irow1</i> <i class="arg">irow2</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></li>
<li><a href="#11"><b class="cmd">::math::linearalgebra::swapcols</b> <i class="arg">matrix</i> <i class="arg">icol1</i> <i class="arg">icol2</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></li>
<li><a href="#12"><b class="cmd">::math::linearalgebra::show</b> <i class="arg">obj</i> <span class="opt">?format?</span> <span class="opt">?rowsep?</span> <span class="opt">?colsep?</span></a></li>
<li><a href="#13"><b class="cmd">::math::linearalgebra::dim</b> <i class="arg">obj</i></a></li>
<li><a href="#14"><b class="cmd">::math::linearalgebra::shape</b> <i class="arg">obj</i></a></li>
<li><a href="#15"><b class="cmd">::math::linearalgebra::conforming</b> <i class="arg">type</i> <i class="arg">obj1</i> <i class="arg">obj2</i></a></li>
<li><a href="#16"><b class="cmd">::math::linearalgebra::symmetric</b> <i class="arg">matrix</i> <span class="opt">?eps?</span></a></li>
<li><a href="#17"><b class="cmd">::math::linearalgebra::norm</b> <i class="arg">vector</i> <i class="arg">type</i></a></li>
<li><a href="#18"><b class="cmd">::math::linearalgebra::norm_one</b> <i class="arg">vector</i></a></li>
<li><a href="#19"><b class="cmd">::math::linearalgebra::norm_two</b> <i class="arg">vector</i></a></li>
<li><a href="#20"><b class="cmd">::math::linearalgebra::norm_max</b> <i class="arg">vector</i> <span class="opt">?index?</span></a></li>
<li><a href="#21"><b class="cmd">::math::linearalgebra::normMatrix</b> <i class="arg">matrix</i> <i class="arg">type</i></a></li>
<li><a href="#22"><b class="cmd">::math::linearalgebra::dotproduct</b> <i class="arg">vect1</i> <i class="arg">vect2</i></a></li>
<li><a href="#23"><b class="cmd">::math::linearalgebra::unitLengthVector</b> <i class="arg">vector</i></a></li>
<li><a href="#24"><b class="cmd">::math::linearalgebra::normalizeStat</b> <i class="arg">mv</i></a></li>
<li><a href="#25"><b class="cmd">::math::linearalgebra::axpy</b> <i class="arg">scale</i> <i class="arg">mv1</i> <i class="arg">mv2</i></a></li>
<li><a href="#26"><b class="cmd">::math::linearalgebra::add</b> <i class="arg">mv1</i> <i class="arg">mv2</i></a></li>
<li><a href="#27"><b class="cmd">::math::linearalgebra::sub</b> <i class="arg">mv1</i> <i class="arg">mv2</i></a></li>
<li><a href="#28"><b class="cmd">::math::linearalgebra::scale</b> <i class="arg">scale</i> <i class="arg">mv</i></a></li>
<li><a href="#29"><b class="cmd">::math::linearalgebra::rotate</b> <i class="arg">c</i> <i class="arg">s</i> <i class="arg">vect1</i> <i class="arg">vect2</i></a></li>
<li><a href="#30"><b class="cmd">::math::linearalgebra::transpose</b> <i class="arg">matrix</i></a></li>
<li><a href="#31"><b class="cmd">::math::linearalgebra::matmul</b> <i class="arg">mv1</i> <i class="arg">mv2</i></a></li>
<li><a href="#32"><b class="cmd">::math::linearalgebra::angle</b> <i class="arg">vect1</i> <i class="arg">vect2</i></a></li>
<li><a href="#33"><b class="cmd">::math::linearalgebra::crossproduct</b> <i class="arg">vect1</i> <i class="arg">vect2</i></a></li>
<li><a href="#34"><b class="cmd">::math::linearalgebra::matmul</b> <i class="arg">mv1</i> <i class="arg">mv2</i></a></li>
<li><a href="#35"><b class="cmd">::math::linearalgebra::mkIdentity</b> <i class="arg">size</i></a></li>
<li><a href="#36"><b class="cmd">::math::linearalgebra::mkDiagonal</b> <i class="arg">diag</i></a></li>
<li><a href="#37"><b class="cmd">::math::linearalgebra::mkRandom</b> <i class="arg">size</i></a></li>
<li><a href="#38"><b class="cmd">::math::linearalgebra::mkTriangular</b> <i class="arg">size</i> <span class="opt">?uplo?</span> <span class="opt">?value?</span></a></li>
<li><a href="#39"><b class="cmd">::math::linearalgebra::mkHilbert</b> <i class="arg">size</i></a></li>
<li><a href="#40"><b class="cmd">::math::linearalgebra::mkDingdong</b> <i class="arg">size</i></a></li>
<li><a href="#41"><b class="cmd">::math::linearalgebra::mkOnes</b> <i class="arg">size</i></a></li>
<li><a href="#42"><b class="cmd">::math::linearalgebra::mkMoler</b> <i class="arg">size</i></a></li>
<li><a href="#43"><b class="cmd">::math::linearalgebra::mkFrank</b> <i class="arg">size</i></a></li>
<li><a href="#44"><b class="cmd">::math::linearalgebra::mkBorder</b> <i class="arg">size</i></a></li>
<li><a href="#45"><b class="cmd">::math::linearalgebra::mkWilkinsonW+</b> <i class="arg">size</i></a></li>
<li><a href="#46"><b class="cmd">::math::linearalgebra::mkWilkinsonW-</b> <i class="arg">size</i></a></li>
<li><a href="#47"><b class="cmd">::math::linearalgebra::solveGauss</b> <i class="arg">matrix</i> <i class="arg">bvect</i></a></li>
<li><a href="#48"><b class="cmd">::math::linearalgebra::solvePGauss</b> <i class="arg">matrix</i> <i class="arg">bvect</i></a></li>
<li><a href="#49"><b class="cmd">::math::linearalgebra::solveTriangular</b> <i class="arg">matrix</i> <i class="arg">bvect</i> <span class="opt">?uplo?</span></a></li>
<li><a href="#50"><b class="cmd">::math::linearalgebra::solveGaussBand</b> <i class="arg">matrix</i> <i class="arg">bvect</i></a></li>
<li><a href="#51"><b class="cmd">::math::linearalgebra::solveTriangularBand</b> <i class="arg">matrix</i> <i class="arg">bvect</i></a></li>
<li><a href="#52"><b class="cmd">::math::linearalgebra::determineSVD</b> <i class="arg">A</i> <i class="arg">eps</i></a></li>
<li><a href="#53"><b class="cmd">::math::linearalgebra::eigenvectorsSVD</b> <i class="arg">A</i> <i class="arg">eps</i></a></li>
<li><a href="#54"><b class="cmd">::math::linearalgebra::leastSquaresSVD</b> <i class="arg">A</i> <i class="arg">y</i> <i class="arg">qmin</i> <i class="arg">eps</i></a></li>
<li><a href="#55"><b class="cmd">::math::linearalgebra::choleski</b> <i class="arg">matrix</i></a></li>
<li><a href="#56"><b class="cmd">::math::linearalgebra::orthonormalizeColumns</b> <i class="arg">matrix</i></a></li>
<li><a href="#57"><b class="cmd">::math::linearalgebra::orthonormalizeRows</b> <i class="arg">matrix</i></a></li>
<li><a href="#58"><b class="cmd">::math::linearalgebra::dger</b> <i class="arg">matrix</i> <i class="arg">alpha</i> <i class="arg">x</i> <i class="arg">y</i> <span class="opt">?scope?</span></a></li>
<li><a href="#59"><b class="cmd">::math::linearalgebra::dgetrf</b> <i class="arg">matrix</i></a></li>
<li><a href="#60"><b class="cmd">::math::linearalgebra::det</b> <i class="arg">matrix</i></a></li>
<li><a href="#61"><b class="cmd">::math::linearalgebra::largesteigen</b> <i class="arg">matrix</i> <i class="arg">tolerance</i> <i class="arg">maxiter</i></a></li>
<li><a href="#62"><b class="cmd">::math::linearalgebra::to_LA</b> <i class="arg">mv</i></a></li>
<li><a href="#63"><b class="cmd">::math::linearalgebra::from_LA</b> <i class="arg">mv</i></a></li>
</ul>
</div>
</div>
<div id="section1" class="doctools_section"><h2><a name="section1">Description</a></h2>
<p>This package offers both low-level procedures and high-level algorithms
to deal with linear algebra problems:</p>
<ul class="doctools_itemized">
<li><p>robust solution of linear equations or least squares problems</p></li>
<li><p>determining eigenvectors and eigenvalues of symmetric matrices</p></li>
<li><p>various decompositions of general matrices or matrices of a specific
form</p></li>
<li><p>(limited) support for matrices in band storage, a common type of sparse
matrices</p></li>
</ul>
<p>It arose as a re-implementation of Hume's LA package and the desire to
offer low-level procedures as found in the well-known BLAS library.
Matrices are implemented as lists of lists rather linear lists with
reserved elements, as in the original LA package, as it was found that
such an implementation is actually faster.</p>
<p>It is advisable, however, to use the procedures that are offered, such
as <em>setrow</em> and <em>getrow</em>, rather than rely on this
representation explicitly: that way it is to switch to a possibly even
faster compiled implementation that supports the same API.</p>
<p><em>Note:</em> When using this package in combination with Tk, there may
be a naming conflict, as both this package and Tk define a command
<em>scale</em>. See the <span class="sectref"><a href="#section6">NAMING CONFLICT</a></span> section below.</p>
</div>
<div id="section2" class="doctools_section"><h2><a name="section2">PROCEDURES</a></h2>
<p>The package defines the following public procedures (several exist as
specialised procedures, see below):</p>
<p><em>Constructing matrices and vectors</em></p>
<dl class="doctools_definitions">
<dt><a name="1"><b class="cmd">::math::linearalgebra::mkVector</b> <i class="arg">ndim</i> <i class="arg">value</i></a></dt>
<dd><p>Create a vector with ndim elements, each with the value <em>value</em>.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">ndim</i></dt>
<dd><p>Dimension of the vector (number of components)</p></dd>
<dt>double <i class="arg">value</i></dt>
<dd><p>Uniform value to be used (default: 0.0)</p></dd>
</dl></dd>
<dt><a name="2"><b class="cmd">::math::linearalgebra::mkUnitVector</b> <i class="arg">ndim</i> <i class="arg">ndir</i></a></dt>
<dd><p>Create a unit vector in <em>ndim</em>-dimensional space, along the
<em>ndir</em>-th direction.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">ndim</i></dt>
<dd><p>Dimension of the vector (number of components)</p></dd>
<dt>integer <i class="arg">ndir</i></dt>
<dd><p>Direction (0, ..., ndim-1)</p></dd>
</dl></dd>
<dt><a name="3"><b class="cmd">::math::linearalgebra::mkMatrix</b> <i class="arg">nrows</i> <i class="arg">ncols</i> <i class="arg">value</i></a></dt>
<dd><p>Create a matrix with <em>nrows</em> rows and <em>ncols</em> columns. All
elements have the value <em>value</em>.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">nrows</i></dt>
<dd><p>Number of rows</p></dd>
<dt>integer <i class="arg">ncols</i></dt>
<dd><p>Number of columns</p></dd>
<dt>double <i class="arg">value</i></dt>
<dd><p>Uniform value to be used (default: 0.0)</p></dd>
</dl></dd>
<dt><a name="4"><b class="cmd">::math::linearalgebra::getrow</b> <i class="arg">matrix</i> <i class="arg">row</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></dt>
<dd><p>Returns a single row of a matrix as a list</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Matrix in question</p></dd>
<dt>integer <i class="arg">row</i></dt>
<dd><p>Index of the row to return</p></dd>
<dt>integer <i class="arg">imin</i></dt>
<dd><p>Minimum index of the column (default: 0)</p></dd>
<dt>integer <i class="arg">imax</i></dt>
<dd><p>Maximum index of the column (default: ncols-1)</p></dd>
</dl></dd>
<dt><a name="5"><b class="cmd">::math::linearalgebra::setrow</b> <i class="arg">matrix</i> <i class="arg">row</i> <i class="arg">newvalues</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></dt>
<dd><p>Set a single row of a matrix to new values (this list must have the same
number of elements as the number of <em>columns</em> in the matrix)</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p><em>name</em> of the matrix in question</p></dd>
<dt>integer <i class="arg">row</i></dt>
<dd><p>Index of the row to update</p></dd>
<dt>list <i class="arg">newvalues</i></dt>
<dd><p>List of new values for the row</p></dd>
<dt>integer <i class="arg">imin</i></dt>
<dd><p>Minimum index of the column (default: 0)</p></dd>
<dt>integer <i class="arg">imax</i></dt>
<dd><p>Maximum index of the column (default: ncols-1)</p></dd>
</dl></dd>
<dt><a name="6"><b class="cmd">::math::linearalgebra::getcol</b> <i class="arg">matrix</i> <i class="arg">col</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></dt>
<dd><p>Returns a single column of a matrix as a list</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Matrix in question</p></dd>
<dt>integer <i class="arg">col</i></dt>
<dd><p>Index of the column to return</p></dd>
<dt>integer <i class="arg">imin</i></dt>
<dd><p>Minimum index of the row (default: 0)</p></dd>
<dt>integer <i class="arg">imax</i></dt>
<dd><p>Maximum index of the row (default: nrows-1)</p></dd>
</dl></dd>
<dt><a name="7"><b class="cmd">::math::linearalgebra::setcol</b> <i class="arg">matrix</i> <i class="arg">col</i> <i class="arg">newvalues</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></dt>
<dd><p>Set a single column of a matrix to new values (this list must have
the same number of elements as the number of <em>rows</em> in the matrix)</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p><em>name</em> of the matrix in question</p></dd>
<dt>integer <i class="arg">col</i></dt>
<dd><p>Index of the column to update</p></dd>
<dt>list <i class="arg">newvalues</i></dt>
<dd><p>List of new values for the column</p></dd>
<dt>integer <i class="arg">imin</i></dt>
<dd><p>Minimum index of the row (default: 0)</p></dd>
<dt>integer <i class="arg">imax</i></dt>
<dd><p>Maximum index of the row (default: nrows-1)</p></dd>
</dl></dd>
<dt><a name="8"><b class="cmd">::math::linearalgebra::getelem</b> <i class="arg">matrix</i> <i class="arg">row</i> <i class="arg">col</i></a></dt>
<dd><p>Returns a single element of a matrix/vector</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Matrix or vector in question</p></dd>
<dt>integer <i class="arg">row</i></dt>
<dd><p>Row of the element</p></dd>
<dt>integer <i class="arg">col</i></dt>
<dd><p>Column of the element (not present for vectors)</p></dd>
</dl></dd>
<dt><a name="9"><b class="cmd">::math::linearalgebra::setelem</b> <i class="arg">matrix</i> <i class="arg">row</i> <span class="opt">?col?</span> <i class="arg">newvalue</i></a></dt>
<dd><p>Set a single element of a matrix (or vector) to a new value</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p><em>name</em> of the matrix in question</p></dd>
<dt>integer <i class="arg">row</i></dt>
<dd><p>Row of the element</p></dd>
<dt>integer <i class="arg">col</i></dt>
<dd><p>Column of the element (not present for vectors)</p></dd>
</dl></dd>
<dt><a name="10"><b class="cmd">::math::linearalgebra::swaprows</b> <i class="arg">matrix</i> <i class="arg">irow1</i> <i class="arg">irow2</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></dt>
<dd><p>Swap two rows in a matrix completely or only a selected part</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p><em>name</em> of the matrix in question</p></dd>
<dt>integer <i class="arg">irow1</i></dt>
<dd><p>Index of first row</p></dd>
<dt>integer <i class="arg">irow2</i></dt>
<dd><p>Index of second row</p></dd>
<dt>integer <i class="arg">imin</i></dt>
<dd><p>Minimum column index (default: 0)</p></dd>
<dt>integer <i class="arg">imin</i></dt>
<dd><p>Maximum column index (default: ncols-1)</p></dd>
</dl></dd>
<dt><a name="11"><b class="cmd">::math::linearalgebra::swapcols</b> <i class="arg">matrix</i> <i class="arg">icol1</i> <i class="arg">icol2</i> <span class="opt">?imin?</span> <span class="opt">?imax?</span></a></dt>
<dd><p>Swap two columns in a matrix completely or only a selected part</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p><em>name</em> of the matrix in question</p></dd>
<dt>integer <i class="arg">irow1</i></dt>
<dd><p>Index of first column</p></dd>
<dt>integer <i class="arg">irow2</i></dt>
<dd><p>Index of second column</p></dd>
<dt>integer <i class="arg">imin</i></dt>
<dd><p>Minimum row index (default: 0)</p></dd>
<dt>integer <i class="arg">imin</i></dt>
<dd><p>Maximum row index (default: nrows-1)</p></dd>
</dl></dd>
</dl>
<p><em>Querying matrices and vectors</em></p>
<dl class="doctools_definitions">
<dt><a name="12"><b class="cmd">::math::linearalgebra::show</b> <i class="arg">obj</i> <span class="opt">?format?</span> <span class="opt">?rowsep?</span> <span class="opt">?colsep?</span></a></dt>
<dd><p>Return a string representing the vector or matrix, for easy printing.
(There is currently no way to print fixed sets of columns)</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">obj</i></dt>
<dd><p>Matrix or vector in question</p></dd>
<dt>string <i class="arg">format</i></dt>
<dd><p>Format for printing the numbers (default: %6.4f)</p></dd>
<dt>string <i class="arg">rowsep</i></dt>
<dd><p>String to use for separating rows (default: newline)</p></dd>
<dt>string <i class="arg">colsep</i></dt>
<dd><p>String to use for separating columns (default: space)</p></dd>
</dl></dd>
<dt><a name="13"><b class="cmd">::math::linearalgebra::dim</b> <i class="arg">obj</i></a></dt>
<dd><p>Returns the number of dimensions for the object (either 0 for a scalar,
1 for a vector and 2 for a matrix)</p>
<dl class="doctools_arguments">
<dt>any <i class="arg">obj</i></dt>
<dd><p>Scalar, vector, or matrix</p></dd>
</dl></dd>
<dt><a name="14"><b class="cmd">::math::linearalgebra::shape</b> <i class="arg">obj</i></a></dt>
<dd><p>Returns the number of elements in each dimension for the object (either
an empty list for a scalar, a single number for a vector and a list of
the number of rows and columns for a matrix)</p>
<dl class="doctools_arguments">
<dt>any <i class="arg">obj</i></dt>
<dd><p>Scalar, vector, or matrix</p></dd>
</dl></dd>
<dt><a name="15"><b class="cmd">::math::linearalgebra::conforming</b> <i class="arg">type</i> <i class="arg">obj1</i> <i class="arg">obj2</i></a></dt>
<dd><p>Checks if two objects (vector or matrix) have conforming shapes, that is
if they can be applied in an operation like addition or matrix
multiplication.</p>
<dl class="doctools_arguments">
<dt>string <i class="arg">type</i></dt>
<dd><p>Type of check:</p>
<ul class="doctools_itemized">
<li><p>&quot;shape&quot; - the two objects have the same shape (for all element-wise
operations)</p></li>
<li><p>&quot;rows&quot; - the two objects have the same number of rows (for use as A and
b in a system of linear equations <em>Ax = b</em></p></li>
<li><p>&quot;matmul&quot; - the first object has the same number of columns as the number
of rows of the second object. Useful for matrix-matrix or matrix-vector
multiplication.</p></li>
</ul></dd>
<dt>list <i class="arg">obj1</i></dt>
<dd><p>First vector or matrix (left operand)</p></dd>
<dt>list <i class="arg">obj2</i></dt>
<dd><p>Second vector or matrix (right operand)</p></dd>
</dl></dd>
<dt><a name="16"><b class="cmd">::math::linearalgebra::symmetric</b> <i class="arg">matrix</i> <span class="opt">?eps?</span></a></dt>
<dd><p>Checks if the given (square) matrix is symmetric. The argument eps
is the tolerance.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Matrix to be inspected</p></dd>
<dt>float <i class="arg">eps</i></dt>
<dd><p>Tolerance for determining approximate equality
(defaults to 1.0e-8)</p></dd>
</dl></dd>
</dl>
<p><em>Basic operations</em></p>
<dl class="doctools_definitions">
<dt><a name="17"><b class="cmd">::math::linearalgebra::norm</b> <i class="arg">vector</i> <i class="arg">type</i></a></dt>
<dd><p>Returns the norm of the given vector. The type argument can be: 1,
2, inf or max, respectively the sum of absolute values, the ordinary
Euclidean norm or the max norm.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">vector</i></dt>
<dd><p>Vector, list of coefficients</p></dd>
<dt>string <i class="arg">type</i></dt>
<dd><p>Type of norm (default: 2, the Euclidean norm)</p></dd>
</dl></dd>
<dt><a name="18"><b class="cmd">::math::linearalgebra::norm_one</b> <i class="arg">vector</i></a></dt>
<dd><p>Returns the L1 norm of the given vector, the sum of absolute values</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">vector</i></dt>
<dd><p>Vector, list of coefficients</p></dd>
</dl></dd>
<dt><a name="19"><b class="cmd">::math::linearalgebra::norm_two</b> <i class="arg">vector</i></a></dt>
<dd><p>Returns the L2 norm of the given vector, the ordinary Euclidean norm</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">vector</i></dt>
<dd><p>Vector, list of coefficients</p></dd>
</dl></dd>
<dt><a name="20"><b class="cmd">::math::linearalgebra::norm_max</b> <i class="arg">vector</i> <span class="opt">?index?</span></a></dt>
<dd><p>Returns the Linf norm of the given vector, the maximum absolute
coefficient</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">vector</i></dt>
<dd><p>Vector, list of coefficients</p></dd>
<dt>integer <i class="arg">index</i></dt>
<dd><p>(optional) if non zero, returns a list made of the maximum
value and the index where that maximum was found.
if zero, returns the maximum value.</p></dd>
</dl></dd>
<dt><a name="21"><b class="cmd">::math::linearalgebra::normMatrix</b> <i class="arg">matrix</i> <i class="arg">type</i></a></dt>
<dd><p>Returns the norm of the given matrix. The type argument can be: 1,
2, inf or max, respectively the sum of absolute values, the ordinary
Euclidean norm or the max norm.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Matrix, list of row vectors</p></dd>
<dt>string <i class="arg">type</i></dt>
<dd><p>Type of norm (default: 2, the Euclidean norm)</p></dd>
</dl></dd>
<dt><a name="22"><b class="cmd">::math::linearalgebra::dotproduct</b> <i class="arg">vect1</i> <i class="arg">vect2</i></a></dt>
<dd><p>Determine the inproduct or dot product of two vectors. These must have
the same shape (number of dimensions)</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">vect1</i></dt>
<dd><p>First vector, list of coefficients</p></dd>
<dt>list <i class="arg">vect2</i></dt>
<dd><p>Second vector, list of coefficients</p></dd>
</dl></dd>
<dt><a name="23"><b class="cmd">::math::linearalgebra::unitLengthVector</b> <i class="arg">vector</i></a></dt>
<dd><p>Return a vector in the same direction with length 1.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">vector</i></dt>
<dd><p>Vector to be normalized</p></dd>
</dl></dd>
<dt><a name="24"><b class="cmd">::math::linearalgebra::normalizeStat</b> <i class="arg">mv</i></a></dt>
<dd><p>Normalize the matrix or vector in a statistical sense: the mean of the
elements of the columns of the result is zero and the standard deviation
is 1.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">mv</i></dt>
<dd><p>Vector or matrix to be normalized in the above sense</p></dd>
</dl></dd>
<dt><a name="25"><b class="cmd">::math::linearalgebra::axpy</b> <i class="arg">scale</i> <i class="arg">mv1</i> <i class="arg">mv2</i></a></dt>
<dd><p>Return a vector or matrix that results from a &quot;daxpy&quot; operation, that
is: compute a*x+y (a a scalar and x and y both vectors or matrices of
the same shape) and return the result.</p>
<p>Specialised variants are: axpy_vect and axpy_mat (slightly faster,
but no check on the arguments)</p>
<dl class="doctools_arguments">
<dt>double <i class="arg">scale</i></dt>
<dd><p>The scale factor for the first vector/matrix (a)</p></dd>
<dt>list <i class="arg">mv1</i></dt>
<dd><p>First vector or matrix (x)</p></dd>
<dt>list <i class="arg">mv2</i></dt>
<dd><p>Second vector or matrix (y)</p></dd>
</dl></dd>
<dt><a name="26"><b class="cmd">::math::linearalgebra::add</b> <i class="arg">mv1</i> <i class="arg">mv2</i></a></dt>
<dd><p>Return a vector or matrix that is the sum of the two arguments (x+y)</p>
<p>Specialised variants are: add_vect and add_mat (slightly faster,
but no check on the arguments)</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">mv1</i></dt>
<dd><p>First vector or matrix (x)</p></dd>
<dt>list <i class="arg">mv2</i></dt>
<dd><p>Second vector or matrix (y)</p></dd>
</dl></dd>
<dt><a name="27"><b class="cmd">::math::linearalgebra::sub</b> <i class="arg">mv1</i> <i class="arg">mv2</i></a></dt>
<dd><p>Return a vector or matrix that is the difference of the two arguments
(x-y)</p>
<p>Specialised variants are: sub_vect and sub_mat (slightly faster,
but no check on the arguments)</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">mv1</i></dt>
<dd><p>First vector or matrix (x)</p></dd>
<dt>list <i class="arg">mv2</i></dt>
<dd><p>Second vector or matrix (y)</p></dd>
</dl></dd>
<dt><a name="28"><b class="cmd">::math::linearalgebra::scale</b> <i class="arg">scale</i> <i class="arg">mv</i></a></dt>
<dd><p>Scale a vector or matrix and return the result, that is: compute a*x.</p>
<p>Specialised variants are: scale_vect and scale_mat (slightly faster,
but no check on the arguments)</p>
<dl class="doctools_arguments">
<dt>double <i class="arg">scale</i></dt>
<dd><p>The scale factor for the vector/matrix (a)</p></dd>
<dt>list <i class="arg">mv</i></dt>
<dd><p>Vector or matrix (x)</p></dd>
</dl></dd>
<dt><a name="29"><b class="cmd">::math::linearalgebra::rotate</b> <i class="arg">c</i> <i class="arg">s</i> <i class="arg">vect1</i> <i class="arg">vect2</i></a></dt>
<dd><p>Apply a planar rotation to two vectors and return the result as a list
of two vectors: c*x-s*y and s*x+c*y. In algorithms you can often easily
determine the cosine and sine of the angle, so it is more efficient to
pass that information directly.</p>
<dl class="doctools_arguments">
<dt>double <i class="arg">c</i></dt>
<dd><p>The cosine of the angle</p></dd>
<dt>double <i class="arg">s</i></dt>
<dd><p>The sine of the angle</p></dd>
<dt>list <i class="arg">vect1</i></dt>
<dd><p>First vector (x)</p></dd>
<dt>list <i class="arg">vect2</i></dt>
<dd><p>Seocnd vector (x)</p></dd>
</dl></dd>
<dt><a name="30"><b class="cmd">::math::linearalgebra::transpose</b> <i class="arg">matrix</i></a></dt>
<dd><p>Transpose a matrix</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Matrix to be transposed</p></dd>
</dl></dd>
<dt><a name="31"><b class="cmd">::math::linearalgebra::matmul</b> <i class="arg">mv1</i> <i class="arg">mv2</i></a></dt>
<dd><p>Multiply a vector/matrix with another vector/matrix. The result is
a matrix, if both x and y are matrices or both are vectors, in
which case the &quot;outer product&quot; is computed. If one is a vector and the
other is a matrix, then the result is a vector.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">mv1</i></dt>
<dd><p>First vector/matrix (x)</p></dd>
<dt>list <i class="arg">mv2</i></dt>
<dd><p>Second vector/matrix (y)</p></dd>
</dl></dd>
<dt><a name="32"><b class="cmd">::math::linearalgebra::angle</b> <i class="arg">vect1</i> <i class="arg">vect2</i></a></dt>
<dd><p>Compute the angle between two vectors (in radians)</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">vect1</i></dt>
<dd><p>First vector</p></dd>
<dt>list <i class="arg">vect2</i></dt>
<dd><p>Second vector</p></dd>
</dl></dd>
<dt><a name="33"><b class="cmd">::math::linearalgebra::crossproduct</b> <i class="arg">vect1</i> <i class="arg">vect2</i></a></dt>
<dd><p>Compute the cross product of two (three-dimensional) vectors</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">vect1</i></dt>
<dd><p>First vector</p></dd>
<dt>list <i class="arg">vect2</i></dt>
<dd><p>Second vector</p></dd>
</dl></dd>
<dt><a name="34"><b class="cmd">::math::linearalgebra::matmul</b> <i class="arg">mv1</i> <i class="arg">mv2</i></a></dt>
<dd><p>Multiply a vector/matrix with another vector/matrix. The result is
a matrix, if both x and y are matrices or both are vectors, in
which case the &quot;outer product&quot; is computed. If one is a vector and the
other is a matrix, then the result is a vector.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">mv1</i></dt>
<dd><p>First vector/matrix (x)</p></dd>
<dt>list <i class="arg">mv2</i></dt>
<dd><p>Second vector/matrix (y)</p></dd>
</dl></dd>
</dl>
<p><em>Common matrices and test matrices</em></p>
<dl class="doctools_definitions">
<dt><a name="35"><b class="cmd">::math::linearalgebra::mkIdentity</b> <i class="arg">size</i></a></dt>
<dd><p>Create an identity matrix of dimension <em>size</em>.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
</dl></dd>
<dt><a name="36"><b class="cmd">::math::linearalgebra::mkDiagonal</b> <i class="arg">diag</i></a></dt>
<dd><p>Create a diagonal matrix whose diagonal elements are the elements of the
vector <em>diag</em>.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">diag</i></dt>
<dd><p>Vector whose elements are used for the diagonal</p></dd>
</dl></dd>
<dt><a name="37"><b class="cmd">::math::linearalgebra::mkRandom</b> <i class="arg">size</i></a></dt>
<dd><p>Create a square matrix whose elements are uniformly distributed random
numbers between 0 and 1 of dimension <em>size</em>.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
</dl></dd>
<dt><a name="38"><b class="cmd">::math::linearalgebra::mkTriangular</b> <i class="arg">size</i> <span class="opt">?uplo?</span> <span class="opt">?value?</span></a></dt>
<dd><p>Create a triangular matrix with non-zero elements in the upper or lower
part, depending on argument <em>uplo</em>.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
<dt>string <i class="arg">uplo</i></dt>
<dd><p>Fill the upper (U) or lower part (L)</p></dd>
<dt>double <i class="arg">value</i></dt>
<dd><p>Value to fill the matrix with</p></dd>
</dl></dd>
<dt><a name="39"><b class="cmd">::math::linearalgebra::mkHilbert</b> <i class="arg">size</i></a></dt>
<dd><p>Create a Hilbert matrix of dimension <em>size</em>.
Hilbert matrices are very ill-conditioned with respect to
eigenvalue/eigenvector problems. Therefore they
are good candidates for testing the accuracy
of algorithms and implementations.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
</dl></dd>
<dt><a name="40"><b class="cmd">::math::linearalgebra::mkDingdong</b> <i class="arg">size</i></a></dt>
<dd><p>Create a &quot;dingdong&quot; matrix of dimension <em>size</em>.
Dingdong matrices are imprecisely represented,
but have the property of being very stable in
such algorithms as Gauss elimination.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
</dl></dd>
<dt><a name="41"><b class="cmd">::math::linearalgebra::mkOnes</b> <i class="arg">size</i></a></dt>
<dd><p>Create a square matrix of dimension <em>size</em> whose entries are all 1.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
</dl></dd>
<dt><a name="42"><b class="cmd">::math::linearalgebra::mkMoler</b> <i class="arg">size</i></a></dt>
<dd><p>Create a Moler matrix of size <em>size</em>. (Moler matrices have
a very simple Choleski decomposition. It has one small eigenvalue
and it can easily upset elimination methods for systems of linear
equations.)</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
</dl></dd>
<dt><a name="43"><b class="cmd">::math::linearalgebra::mkFrank</b> <i class="arg">size</i></a></dt>
<dd><p>Create a Frank matrix of size <em>size</em>. (Frank matrices are
fairly well-behaved matrices)</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
</dl></dd>
<dt><a name="44"><b class="cmd">::math::linearalgebra::mkBorder</b> <i class="arg">size</i></a></dt>
<dd><p>Create a bordered matrix of size <em>size</em>. (Bordered matrices have
a very low rank and can upset certain specialised algorithms.)</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
</dl></dd>
<dt><a name="45"><b class="cmd">::math::linearalgebra::mkWilkinsonW+</b> <i class="arg">size</i></a></dt>
<dd><p>Create a Wilkinson W+ of size <em>size</em>. This kind of matrix
has pairs of eigenvalues that are very close together. Usually
the order (size) is odd.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
</dl></dd>
<dt><a name="46"><b class="cmd">::math::linearalgebra::mkWilkinsonW-</b> <i class="arg">size</i></a></dt>
<dd><p>Create a Wilkinson W- of size <em>size</em>. This kind of matrix
has pairs of eigenvalues with opposite signs, when the order (size)
is odd.</p>
<dl class="doctools_arguments">
<dt>integer <i class="arg">size</i></dt>
<dd><p>Dimension of the matrix</p></dd>
</dl></dd>
</dl>
<p><em>Common algorithms</em></p>
<dl class="doctools_definitions">
<dt><a name="47"><b class="cmd">::math::linearalgebra::solveGauss</b> <i class="arg">matrix</i> <i class="arg">bvect</i></a></dt>
<dd><p>Solve a system of linear equations (Ax=b) using Gauss elimination.
Returns the solution (x) as a vector or matrix of the same shape as
bvect.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Square matrix (matrix A)</p></dd>
<dt>list <i class="arg">bvect</i></dt>
<dd><p>Vector or matrix whose columns are the individual
b-vectors</p></dd>
</dl></dd>
<dt><a name="48"><b class="cmd">::math::linearalgebra::solvePGauss</b> <i class="arg">matrix</i> <i class="arg">bvect</i></a></dt>
<dd><p>Solve a system of linear equations (Ax=b) using Gauss elimination with
partial pivoting. Returns the solution (x) as a vector or matrix of the
same shape as bvect.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Square matrix (matrix A)</p></dd>
<dt>list <i class="arg">bvect</i></dt>
<dd><p>Vector or matrix whose columns are the individual
b-vectors</p></dd>
</dl></dd>
<dt><a name="49"><b class="cmd">::math::linearalgebra::solveTriangular</b> <i class="arg">matrix</i> <i class="arg">bvect</i> <span class="opt">?uplo?</span></a></dt>
<dd><p>Solve a system of linear equations (Ax=b) by backward substitution. The
matrix is supposed to be upper-triangular.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Lower or upper-triangular matrix (matrix A)</p></dd>
<dt>list <i class="arg">bvect</i></dt>
<dd><p>Vector or matrix whose columns are the individual
b-vectors</p></dd>
<dt>string <i class="arg">uplo</i></dt>
<dd><p>Indicates whether the matrix is lower-triangular
(L) or upper-triangular (U). Defaults to &quot;U&quot;.</p></dd>
</dl></dd>
<dt><a name="50"><b class="cmd">::math::linearalgebra::solveGaussBand</b> <i class="arg">matrix</i> <i class="arg">bvect</i></a></dt>
<dd><p>Solve a system of linear equations (Ax=b) using Gauss elimination,
where the matrix is stored as a band matrix (<em>cf.</em> <span class="sectref"><a href="#section3">STORAGE</a></span>).
Returns the solution (x) as a vector or matrix of the same shape as
bvect.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Square matrix (matrix A; in band form)</p></dd>
<dt>list <i class="arg">bvect</i></dt>
<dd><p>Vector or matrix whose columns are the individual
b-vectors</p></dd>
</dl></dd>
<dt><a name="51"><b class="cmd">::math::linearalgebra::solveTriangularBand</b> <i class="arg">matrix</i> <i class="arg">bvect</i></a></dt>
<dd><p>Solve a system of linear equations (Ax=b) by backward substitution. The
matrix is supposed to be upper-triangular and stored in band form.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Upper-triangular matrix (matrix A)</p></dd>
<dt>list <i class="arg">bvect</i></dt>
<dd><p>Vector or matrix whose columns are the individual
b-vectors</p></dd>
</dl></dd>
<dt><a name="52"><b class="cmd">::math::linearalgebra::determineSVD</b> <i class="arg">A</i> <i class="arg">eps</i></a></dt>
<dd><p>Determines the Singular Value Decomposition of a matrix: A = U S Vtrans.
Returns a list with the matrix U, the vector of singular values S and
the matrix V.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">A</i></dt>
<dd><p>Matrix to be decomposed</p></dd>
<dt>float <i class="arg">eps</i></dt>
<dd><p>Tolerance (defaults to 2.3e-16)</p></dd>
</dl></dd>
<dt><a name="53"><b class="cmd">::math::linearalgebra::eigenvectorsSVD</b> <i class="arg">A</i> <i class="arg">eps</i></a></dt>
<dd><p>Determines the eigenvectors and eigenvalues of a real
<em>symmetric</em> matrix, using SVD. Returns a list with the matrix of
normalized eigenvectors and their eigenvalues.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">A</i></dt>
<dd><p>Matrix whose eigenvalues must be determined</p></dd>
<dt>float <i class="arg">eps</i></dt>
<dd><p>Tolerance (defaults to 2.3e-16)</p></dd>
</dl></dd>
<dt><a name="54"><b class="cmd">::math::linearalgebra::leastSquaresSVD</b> <i class="arg">A</i> <i class="arg">y</i> <i class="arg">qmin</i> <i class="arg">eps</i></a></dt>
<dd><p>Determines the solution to a least-sqaures problem Ax ~ y via singular
value decomposition. The result is the vector x.</p>
<p>Note that if you add a column of 1s to the matrix, then this column will
represent a constant like in: y = a*x1 + b*x2 + c. To force the
intercept to be zero, simply leave it out.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">A</i></dt>
<dd><p>Matrix of independent variables</p></dd>
<dt>list <i class="arg">y</i></dt>
<dd><p>List of observed values</p></dd>
<dt>float <i class="arg">qmin</i></dt>
<dd><p>Minimum singular value to be considered (defaults to 0.0)</p></dd>
<dt>float <i class="arg">eps</i></dt>
<dd><p>Tolerance (defaults to 2.3e-16)</p></dd>
</dl></dd>
<dt><a name="55"><b class="cmd">::math::linearalgebra::choleski</b> <i class="arg">matrix</i></a></dt>
<dd><p>Determine the Choleski decomposition of a symmetric positive
semidefinite matrix (this condition is not checked!). The result
is the lower-triangular matrix L such that L Lt = matrix.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Matrix to be decomposed</p></dd>
</dl></dd>
<dt><a name="56"><b class="cmd">::math::linearalgebra::orthonormalizeColumns</b> <i class="arg">matrix</i></a></dt>
<dd><p>Use the modified Gram-Schmidt method to orthogonalize and normalize
the <em>columns</em> of the given matrix and return the result.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Matrix whose columns must be orthonormalized</p></dd>
</dl></dd>
<dt><a name="57"><b class="cmd">::math::linearalgebra::orthonormalizeRows</b> <i class="arg">matrix</i></a></dt>
<dd><p>Use the modified Gram-Schmidt method to orthogonalize and normalize
the <em>rows</em> of the given matrix and return the result.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Matrix whose rows must be orthonormalized</p></dd>
</dl></dd>
<dt><a name="58"><b class="cmd">::math::linearalgebra::dger</b> <i class="arg">matrix</i> <i class="arg">alpha</i> <i class="arg">x</i> <i class="arg">y</i> <span class="opt">?scope?</span></a></dt>
<dd><p>Perform the rank 1 operation A + alpha*x*y' inline (that is: the matrix A is adjusted).
For convenience the new matrix is also returned as the result.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Matrix whose rows must be adjusted</p></dd>
<dt>double <i class="arg">alpha</i></dt>
<dd><p>Scale factor</p></dd>
<dt>list <i class="arg">x</i></dt>
<dd><p>A column vector</p></dd>
<dt>list <i class="arg">y</i></dt>
<dd><p>A column vector</p></dd>
<dt>list <i class="arg">scope</i></dt>
<dd><p>If not provided, the operation is performed on all rows/columns of A
if provided, it is expected to be the list {imin imax jmin jmax}
where:</p>
<ul class="doctools_itemized">
<li><p><i class="term">imin</i> Minimum row index</p></li>
<li><p><i class="term">imax</i> Maximum row index</p></li>
<li><p><i class="term">jmin</i> Minimum column index</p></li>
<li><p><i class="term">jmax</i> Maximum column index</p></li>
</ul></dd>
</dl></dd>
<dt><a name="59"><b class="cmd">::math::linearalgebra::dgetrf</b> <i class="arg">matrix</i></a></dt>
<dd><p>Computes an LU factorization of a general matrix, using partial,
pivoting with row interchanges. Returns the permutation vector.</p>
<p>The factorization has the form</p>
<pre class="doctools_example">
   P * A = L * U
</pre>
<p>where P is a permutation matrix, L is lower triangular with unit
diagonal elements, and U is upper triangular.
Returns the permutation vector, as a list of length n-1.
The last entry of the permutation is not stored, since it is
implicitely known, with value n (the last row is not swapped
with any other row).
At index #i of the permutation is stored the index of the row #j
which is swapped with row #i at step #i. That means that each
index of the permutation gives the permutation at each step, not the
cumulated permutation matrix, which is the product of permutations.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>On entry, the matrix to be factored.
On exit, the factors L and U from the factorization
P*A = L*U; the unit diagonal elements of L are not stored.</p></dd>
</dl></dd>
<dt><a name="60"><b class="cmd">::math::linearalgebra::det</b> <i class="arg">matrix</i></a></dt>
<dd><p>Returns the determinant of the given matrix, based on PA=LU
decomposition, i.e. Gauss partial pivotal.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Square matrix (matrix A)</p></dd>
<dt>list <i class="arg">ipiv</i></dt>
<dd><p>The pivots (optionnal).
If the pivots are not provided, a PA=LU decomposition
is performed.
If the pivots are provided, we assume that it
contains the pivots and that the matrix A contains the
L and U factors, as provided by dgterf.
b-vectors</p></dd>
</dl></dd>
<dt><a name="61"><b class="cmd">::math::linearalgebra::largesteigen</b> <i class="arg">matrix</i> <i class="arg">tolerance</i> <i class="arg">maxiter</i></a></dt>
<dd><p>Returns a list made of the largest eigenvalue (in magnitude)
and associated eigenvector.
Uses iterative Power Method as provided as algorithm #7.3.3 of Golub &amp; Van Loan.
This algorithm is used here for a dense matrix (but is usually
used for sparse matrices).</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">matrix</i></dt>
<dd><p>Square matrix (matrix A)</p></dd>
<dt>double <i class="arg">tolerance</i></dt>
<dd><p>The relative tolerance of the eigenvalue (default:1.e-8).</p></dd>
<dt>integer <i class="arg">maxiter</i></dt>
<dd><p>The maximum number of iterations (default:10).</p></dd>
</dl></dd>
</dl>
<p><em>Compability with the LA package</em>
Two procedures are provided for compatibility with Hume's LA package:</p>
<dl class="doctools_definitions">
<dt><a name="62"><b class="cmd">::math::linearalgebra::to_LA</b> <i class="arg">mv</i></a></dt>
<dd><p>Transforms a vector or matrix into the format used by the original LA
package.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">mv</i></dt>
<dd><p>Matrix or vector</p></dd>
</dl></dd>
<dt><a name="63"><b class="cmd">::math::linearalgebra::from_LA</b> <i class="arg">mv</i></a></dt>
<dd><p>Transforms a vector or matrix from the format used by the original LA
package into the format used by the present implementation.</p>
<dl class="doctools_arguments">
<dt>list <i class="arg">mv</i></dt>
<dd><p>Matrix or vector as used by the LA package</p></dd>
</dl></dd>
</dl>
</div>
<div id="section3" class="doctools_section"><h2><a name="section3">STORAGE</a></h2>
<p>While most procedures assume that the matrices are given in full form,
the procedures <em>solveGaussBand</em> and <em>solveTriangularBand</em>
assume that the matrices are stored as <em>band matrices</em>. This
common type of &quot;sparse&quot; matrices is related to ordinary matrices as
follows:</p>
<ul class="doctools_itemized">
<li><p>&quot;A&quot; is a full-size matrix with N rows and M columns.</p></li>
<li><p>&quot;B&quot; is a band matrix, with m upper and lower diagonals and n rows.</p></li>
<li><p>&quot;B&quot; can be stored in an ordinary matrix of (2m+1) columns (one for
each off-diagonal and the main diagonal) and n rows.</p></li>
<li><p>Element i,j (i = -m,...,m; j =1,...,n) of &quot;B&quot; corresponds to element
k,j of &quot;A&quot; where k = M+i-1 and M is at least (!) n, the number of rows
in &quot;B&quot;.</p></li>
<li><p>To set element (i,j) of matrix &quot;B&quot; use:</p>
<pre class="doctools_example">
    setelem B $j [expr {$N+$i-1}] $value
</pre>
</li>
</ul>
<p>(There is no convenience procedure for this yet)</p>
</div>
<div id="section4" class="doctools_section"><h2><a name="section4">REMARKS ON THE IMPLEMENTATION</a></h2>
<p>There is a difference between the original LA package by Hume and the
current implementation. Whereas the LA package uses a linear list, the
current package uses lists of lists to represent matrices. It turns out
that with this representation, the algorithms are faster and easier to
implement.</p>
<p>The LA package was used as a model and in fact the implementation of,
for instance, the SVD algorithm was taken from that package. The set of
procedures was expanded using ideas from the well-known BLAS library and
some algorithms were updated from the second edition of J.C. Nash's
book, Compact Numerical Methods for Computers, (Adam Hilger, 1990) that
inspired the LA package.</p>
<p>Two procedures are provided to make the transition between the two
implementations easier: <em>to_LA</em> and <em>from_LA</em>. They are
described above.</p>
</div>
<div id="section5" class="doctools_section"><h2><a name="section5">TODO</a></h2>
<p>Odds and ends: the following algorithms have not been implemented yet:</p>
<ul class="doctools_itemized">
<li><p>determineQR</p></li>
<li><p>certainlyPositive, diagonallyDominant</p></li>
</ul>
</div>
<div id="section6" class="doctools_section"><h2><a name="section6">NAMING CONFLICT</a></h2>
<p>If you load this package in a Tk-enabled shell like wish, then the
command</p>
<pre class="doctools_example">namespace import ::math::linearalgebra</pre>
<p>results in an error
message about &quot;scale&quot;. This is due to the fact that Tk defines all
its commands in the global namespace. The solution is to import
the linear algebra commands in a namespace that is not the global one:</p>
<pre class="doctools_example">
package require math::linearalgebra
namespace eval compute {
    namespace import ::math::linearalgebra::*
    ... use the linear algebra version of scale ...
}
</pre>
<p>To use Tk's scale command in that same namespace you can rename it:</p>
<pre class="doctools_example">
namespace eval compute {
    rename ::scale scaleTk
    scaleTk .scale ...
}
</pre>
</div>
<div id="section7" class="doctools_section"><h2><a name="section7">Bugs, Ideas, Feedback</a></h2>
<p>This document, and the package it describes, will undoubtedly contain
bugs and other problems.
Please report such in the category <em>math :: linearalgebra</em> of the
<a href="http://core.tcl.tk/tcllib/reportlist">Tcllib Trackers</a>.
Please also report any ideas for enhancements you may have for either
package and/or documentation.</p>
</div>
<div id="keywords" class="doctools_section"><h2><a name="keywords">Keywords</a></h2>
<p><a href="../../../../index.html#key69">least squares</a>, <a href="../../../../index.html#key68">linear algebra</a>, <a href="../../../../index.html#key67">linear equations</a>, <a href="../../../../index.html#key71">math</a>, <a href="../../../../index.html#key66">matrices</a>, <a href="../../../../index.html#key51">matrix</a>, <a href="../../../../index.html#key70">vectors</a></p>
</div>
<div id="category" class="doctools_section"><h2><a name="category">Category</a></h2>
<p>Mathematics</p>
</div>
<div id="copyright" class="doctools_section"><h2><a name="copyright">Copyright</a></h2>
<p>Copyright &copy; 2004-2008 Arjen Markus &lt;arjenmarkus@users.sourceforge.net&gt;<br>
Copyright &copy; 2004 Ed Hume &lt;http://www.hume.com/contact.us.htm&gt;<br>
Copyright &copy; 2008 Michael Buadin &lt;relaxkmike@users.sourceforge.net&gt;</p>
</div>
</div>
