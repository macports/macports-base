/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.5
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#define SWIGTCL

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



#include <stdio.h>
#include <tcl.h>
#include <errno.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGINTERN const char*
SWIG_Tcl_ErrorType(int code) {
  const char* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = "MemoryError";
    break;
  case SWIG_IOError:
    type = "IOError";
    break;
  case SWIG_RuntimeError:
    type = "RuntimeError";
    break;
  case SWIG_IndexError:
    type = "IndexError";
    break;
  case SWIG_TypeError:
    type = "TypeError";
    break;
  case SWIG_DivisionByZero:
    type = "ZeroDivisionError";
    break;
  case SWIG_OverflowError:
    type = "OverflowError";
    break;
  case SWIG_SyntaxError:
    type = "SyntaxError";
    break;
  case SWIG_ValueError:
    type = "ValueError";
    break;
  case SWIG_SystemError:
    type = "SystemError";
    break;
  case SWIG_AttributeError:
    type = "AttributeError";
    break;
  default:
    type = "RuntimeError";
  }
  return type;
}


SWIGINTERN void
SWIG_Tcl_SetErrorObj(Tcl_Interp *interp, const char *ctype, Tcl_Obj *obj)
{
  Tcl_ResetResult(interp);
  Tcl_SetObjResult(interp, obj);
  Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
}

SWIGINTERN void
SWIG_Tcl_SetErrorMsg(Tcl_Interp *interp, const char *ctype, const char *mesg)
{
  Tcl_ResetResult(interp);
  Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
  Tcl_AppendResult(interp, ctype, " ", mesg, NULL);
  /*
  Tcl_AddErrorInfo(interp, ctype);
  Tcl_AddErrorInfo(interp, " ");
  Tcl_AddErrorInfo(interp, mesg);
  */
}

SWIGINTERNINLINE void
SWIG_Tcl_AddErrorMsg(Tcl_Interp *interp, const char* mesg)
{
  Tcl_AddErrorInfo(interp, mesg);
}



/* -----------------------------------------------------------------------------
 * SWIG API. Portion that goes into the runtime
 * ----------------------------------------------------------------------------- */
#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_TCL_POINTER 4
#define SWIG_TCL_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
typedef void  (*swig_delete_func)(ClientData);

typedef struct swig_method {
  const char     *name;
  swig_wrapper   method;
} swig_method;

typedef struct swig_attribute {
  const char     *name;
  swig_wrapper   getmethod;
  swig_wrapper   setmethod;
} swig_attribute;

typedef struct swig_class {
  const char         *name;
  swig_type_info   **type;
  swig_wrapper       constructor;
  void              (*destructor)(void *);
  swig_method        *methods;
  swig_attribute     *attributes;
  struct swig_class **bases;
  const char              **base_names;
  swig_module_info   *module;
  Tcl_HashTable       hashtable;
} swig_class;

typedef struct swig_instance {
  Tcl_Obj       *thisptr;
  void          *thisvalue;
  swig_class   *classptr;
  int            destroy;
  Tcl_Command    cmdtok;
} swig_instance;

/* Structure for command table */
typedef struct {
  const char *name;
  int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
  ClientData  clientdata;
} swig_command_info;

/* Structure for variable linking table */
typedef struct {
  const char *name;
  void *addr;
  char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
  char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
} swig_var_info;


/* -----------------------------------------------------------------------------*
 *  Install a constant object 
 * -----------------------------------------------------------------------------*/

static Tcl_HashTable   swigconstTable;
static int             swigconstTableinit = 0;

SWIGINTERN void
SWIG_Tcl_SetConstantObj(Tcl_Interp *interp, const char* name, Tcl_Obj *obj) {
  int newobj;
  Tcl_ObjSetVar2(interp,Tcl_NewStringObj(name,-1), NULL, obj, TCL_GLOBAL_ONLY);
  Tcl_SetHashValue(Tcl_CreateHashEntry(&swigconstTable, name, &newobj), (ClientData) obj);
}

SWIGINTERN Tcl_Obj *
SWIG_Tcl_GetConstantObj(const char *key) {
  Tcl_HashEntry *entryPtr;
  if (!swigconstTableinit) return 0;
  entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
  if (entryPtr) {
    return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
  }
  return 0;
}

#ifdef __cplusplus
}
#endif



/* -----------------------------------------------------------------------------
 * tclrun.swg
 *
 * This file contains the runtime support for Tcl modules and includes
 * code for managing global variables and pointer type checking.
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_ConvertPtr(oc, ptr, ty, flags)             SWIG_Tcl_ConvertPtr(interp, oc, ptr, ty, flags)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Tcl_NewPointerObj(ptr, type, flags)

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp, obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, flags)
#define SWIG_NewInstanceObj(thisvalue, type, flags)     SWIG_Tcl_NewInstanceObj(interp, thisvalue, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Tcl_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp,obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Tcl_GetModule((Tcl_Interp *) (clientdata))	     
#define SWIG_SetModule(clientdata, pointer)          	SWIG_Tcl_SetModule((Tcl_Interp *) (clientdata), pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Tcl_ErrorType(code)                                      
#define SWIG_Error(code, msg)            		SWIG_Tcl_SetErrorMsg(interp, SWIG_Tcl_ErrorType(code), msg)
#define SWIG_fail                        		goto fail						    


/* Tcl-specific SWIG API */

#define SWIG_Acquire(ptr)                               SWIG_Tcl_Acquire(ptr)                                     
#define SWIG_MethodCommand                           	SWIG_Tcl_MethodCommand				       
#define SWIG_Disown(ptr)                             	SWIG_Tcl_Disown(ptr)				       
#define SWIG_ConvertPtrFromString(c, ptr, ty, flags) 	SWIG_Tcl_ConvertPtrFromString(interp, c, ptr, ty, flags)  
#define SWIG_MakePtr(c, ptr, ty, flags)              	SWIG_Tcl_MakePtr(c, ptr, ty, flags)		       
#define SWIG_PointerTypeFromString(c)                	SWIG_Tcl_PointerTypeFromString(c)			       
#define SWIG_GetArgs                                 	SWIG_Tcl_GetArgs					       
#define SWIG_GetConstantObj(key)                     	SWIG_Tcl_GetConstantObj(key)			       
#define SWIG_ObjectConstructor                       	SWIG_Tcl_ObjectConstructor				       
#define SWIG_Thisown(ptr)                            	SWIG_Tcl_Thisown(ptr)				       
#define SWIG_ObjectDelete                            	SWIG_Tcl_ObjectDelete				       


#define SWIG_TCL_DECL_ARGS_2(arg1, arg2)                (Tcl_Interp *interp SWIGUNUSED, arg1, arg2)
#define SWIG_TCL_CALL_ARGS_2(arg1, arg2)                (interp, arg1, arg2)
/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_GetConstant        SWIG_GetConstantObj
#define SWIG_Tcl_GetConstant    SWIG_Tcl_GetConstantObj

#include "assert.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Object support */

SWIGRUNTIME Tcl_HashTable*
SWIG_Tcl_ObjectTable(void) {
  static Tcl_HashTable  swigobjectTable;
  static int            swigobjectTableinit = 0;
  if (!swigobjectTableinit) {
    Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
    swigobjectTableinit = 1;
  }
  return &swigobjectTable;
}

/* Acquire ownership of a pointer */
SWIGRUNTIME void
SWIG_Tcl_Acquire(void *ptr) {
  int newobj;
  Tcl_CreateHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr, &newobj);
}

SWIGRUNTIME int
SWIG_Tcl_Thisown(void *ptr) {
  if (Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr)) {
    return 1;
  }
  return 0;
}

/* Disown a pointer.  Returns 1 if we owned it to begin with */
SWIGRUNTIME int
SWIG_Tcl_Disown(void *ptr) {
  Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr);
  if (entryPtr) {
    Tcl_DeleteHashEntry(entryPtr);
    return 1;
  }
  return 0;
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Tcl_ConvertPtrFromString(Tcl_Interp *interp, const char *c, void **ptr, swig_type_info *ty, int flags) {
  swig_cast_info *tc;
  /* Pointer values must start with leading underscore */
  while (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) return SWIG_OK;

    /* Empty string: not a pointer */
    if (*c == 0) return SWIG_ERROR; 

    /* Hmmm. It could be an object name. */

    /* Check if this is a command at all. Prevents <c> cget -this         */
    /* from being called when c is not a command, firing the unknown proc */
    if (Tcl_VarEval(interp,"info commands ", c, (char *) NULL) == TCL_OK) {
      Tcl_Obj *result = Tcl_GetObjResult(interp);
      if (*(Tcl_GetStringFromObj(result, NULL)) == 0) {
        /* It's not a command, so it can't be a pointer */
        Tcl_ResetResult(interp);
        return SWIG_ERROR;
      }
    } else {
      /* This will only fail if the argument is multiple words. */
      /* Multiple words are also not commands.                  */
      Tcl_ResetResult(interp);
      return SWIG_ERROR;
    }

    /* Check if this is really a SWIG pointer */
    if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) != TCL_OK) {
      Tcl_ResetResult(interp);
      return SWIG_ERROR;
    }

    c = Tcl_GetStringFromObj(Tcl_GetObjResult(interp), NULL);
  }

  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (ty) {
    tc = c ? SWIG_TypeCheck(c,ty) : 0;
    if (!tc) {
      return SWIG_ERROR;
    }
    if (flags & SWIG_POINTER_DISOWN) {
      SWIG_Disown((void *) *ptr);
    }
    {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc,(void *) *ptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    }
  }
  return SWIG_OK;
}

/* Convert a pointer value */
SWIGRUNTIMEINLINE int
SWIG_Tcl_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags) {
  return SWIG_Tcl_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty, flags);
}

/* Convert a pointer value */
SWIGRUNTIME char *
SWIG_Tcl_PointerTypeFromString(char *c) {
  char d;
  /* Pointer values must start with leading underscore. NULL has no type */
  if (*c != '_') {
    return 0;
  }
  c++;
  /* Extract hex value from pointer */
  while ((d = *c)) {
    if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
    c++;
  }
  return c;
}

/* Convert a packed value value */
SWIGRUNTIME int
SWIG_Tcl_ConvertPacked(Tcl_Interp *SWIGUNUSEDPARM(interp) , Tcl_Obj *obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (!obj) goto type_error;
  c = Tcl_GetStringFromObj(obj,NULL);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:

  return SWIG_ERROR;
}


/* Take a pointer and convert it to a string */
SWIGRUNTIME void
SWIG_Tcl_MakePtr(char *c, void *ptr, swig_type_info *ty, int flags) {
  if (ptr) {
    *(c++) = '_';
    c = SWIG_PackData(c,&ptr,sizeof(void *));
    strcpy(c,ty->name);
  } else {
    strcpy(c,(char *)"NULL");
  }
  flags = 0;
}

/* Create a new pointer object */
SWIGRUNTIMEINLINE Tcl_Obj *
SWIG_Tcl_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  Tcl_Obj *robj;
  char result[SWIG_BUFFER_SIZE];
  SWIG_MakePtr(result,ptr,type,flags);
  robj = Tcl_NewStringObj(result,-1);
  return robj;
}

SWIGRUNTIME Tcl_Obj *
SWIG_Tcl_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return Tcl_NewStringObj(result,-1);
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

SWIGRUNTIME swig_module_info * 
SWIG_Tcl_GetModule(Tcl_Interp *interp) {
  const char *data;
  swig_module_info *ret = 0;
  
  /* first check if pointer already created */
  data = Tcl_GetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TCL_GLOBAL_ONLY);
  if (data) {
    SWIG_UnpackData(data, &ret, sizeof(swig_type_info **));
  }

  return ret;
}

SWIGRUNTIME void
SWIG_Tcl_SetModule(Tcl_Interp *interp, swig_module_info *module) {
  char buf[SWIG_BUFFER_SIZE];
  char *data;

  /* create a new pointer */
  data = SWIG_PackData(buf, &module, sizeof(swig_type_info **));
  *data = 0;
  Tcl_SetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, buf, TCL_GLOBAL_ONLY);
}

/* -----------------------------------------------------------------------------*
 *  Object auxiliars
 * -----------------------------------------------------------------------------*/


SWIGRUNTIME void
SWIG_Tcl_ObjectDelete(ClientData clientData) {
  swig_instance *si = (swig_instance *) clientData;
  if ((si) && (si->destroy) && (SWIG_Disown(si->thisvalue))) {
    if (si->classptr->destructor) {
      (si->classptr->destructor)(si->thisvalue);
    }
  }
  Tcl_DecrRefCount(si->thisptr);
  free(si);
}

/* Function to invoke object methods given an instance */
SWIGRUNTIME int
SWIG_Tcl_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[]) {
  char *method,   *attrname;
  swig_instance   *inst = (swig_instance *) clientData;
  swig_method     *meth;
  swig_attribute  *attr;
  Tcl_Obj         *oldarg;
  Tcl_Obj         **objv;
  int              rcode;
  swig_class      *cls;
  swig_class      *cls_stack[64];
  int              cls_stack_bi[64];
  int              cls_stack_top = 0;
  int              numconf = 2;
  int              bi;

  objv = (Tcl_Obj **) _objv;
  if (objc < 2) {
    Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
    return TCL_ERROR;
  }
  method = Tcl_GetStringFromObj(objv[1],NULL);
  if (strcmp(method,"-acquire") == 0) {
    inst->destroy = 1;
    SWIG_Acquire(inst->thisvalue);
    return TCL_OK;
  }
  if (strcmp(method,"-disown") == 0) {
    if (inst->destroy) {
      SWIG_Disown(inst->thisvalue);
    }
    inst->destroy = 0;
    return TCL_OK;
  }
  if (strcmp(method,"-delete") == 0) {
    Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
    return TCL_OK;
  }
  cls_stack[cls_stack_top] = inst->classptr;
  cls_stack_bi[cls_stack_top] = -1;
  cls = inst->classptr;
  while (1) {
    Tcl_HashEntry* hashentry;
    bi = cls_stack_bi[cls_stack_top];
    cls = cls_stack[cls_stack_top];
    if (bi != -1) {
      if (!cls->bases[bi] && cls->base_names[bi]) {
        /* lookup and cache the base class */
	swig_type_info *info = SWIG_TypeQueryModule(cls->module, cls->module, cls->base_names[bi]);
	if (info) cls->bases[bi] = (swig_class *) info->clientdata;
      }
      cls = cls->bases[bi];
      if (cls) {
        cls_stack_bi[cls_stack_top]++;
        cls_stack_top++;
        cls_stack[cls_stack_top] = cls;
        cls_stack_bi[cls_stack_top] = -1;
        continue;
      }
    }
    if (!cls) {
      cls_stack_top--;
      if (cls_stack_top < 0) break;
      else continue;
    }
    cls_stack_bi[cls_stack_top]++;

    hashentry = Tcl_FindHashEntry(&(cls->hashtable), method);
    if (hashentry) {
        ClientData cd = Tcl_GetHashValue(hashentry);
        swig_wrapper method_wrapper = (swig_wrapper)cd;
        oldarg = objv[1];
        objv[1] = inst->thisptr;
        Tcl_IncrRefCount(inst->thisptr);
        rcode = (method_wrapper)(clientData,interp,objc,objv);
        objv[1] = oldarg;
        Tcl_DecrRefCount(inst->thisptr);
        return rcode;
    }
    /* Check class methods for a match */
    if (strcmp(method,"cget") == 0) {
      if (objc < 3) {
        Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
        return TCL_ERROR;
      }
      attrname = Tcl_GetStringFromObj(objv[2],NULL);
      attr = cls->attributes;
      while (attr && attr->name) {
        if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
          oldarg = objv[1];
          objv[1] = inst->thisptr;
          Tcl_IncrRefCount(inst->thisptr);
          rcode = (*attr->getmethod)(clientData,interp,2, objv);
          objv[1] = oldarg;
          Tcl_DecrRefCount(inst->thisptr);
          return rcode;
        }
        attr++;
      }
      if (strcmp(attrname, "-this") == 0) {
        Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
        return TCL_OK;
      }
      if (strcmp(attrname, "-thisown") == 0) {
        if (SWIG_Thisown(inst->thisvalue)) {
          Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
        } else {
          Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
        }
        return TCL_OK;
      }
    } else if (strcmp(method, "configure") == 0) {
      int i;
      if (objc < 4) {
        Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
        return TCL_ERROR;
      }
      i = 2;
      while (i < objc) {
        attrname = Tcl_GetStringFromObj(objv[i],NULL);
        attr = cls->attributes;
        while (attr && attr->name) {
          if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
            oldarg = objv[i];
            objv[i] = inst->thisptr;
            Tcl_IncrRefCount(inst->thisptr);
            rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
            objv[i] = oldarg;
            Tcl_DecrRefCount(inst->thisptr);
            if (rcode != TCL_OK) return rcode;
            numconf += 2;
          }
          attr++;
        }
        i+=2;
      }
    }
  }
  if (strcmp(method,"configure") == 0) {
    if (numconf >= objc) {
      return TCL_OK;
    } else {
      Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
      return TCL_ERROR;
    }
  }
  if (strcmp(method,"cget") == 0) {
    Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
    return TCL_ERROR;
  }
  Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
  cls = inst->classptr;
  bi = 0;
  while (cls) {
    meth = cls->methods;
    while (meth && meth->name) {
      char *cr = (char *) Tcl_GetStringResult(interp);
      size_t meth_len = strlen(meth->name);
      char* where = strchr(cr,':');
      while(where) {
        where = strstr(where, meth->name);
        if(where) {
          if(where[-1] == ' ' && (where[meth_len] == ' ' || where[meth_len]==0)) {
            break;
          } else {
            where++;
          }
        }
      }

      if (!where)
        Tcl_AppendElement(interp, (char *) meth->name);
      meth++;
    }
    cls = inst->classptr->bases[bi++];
  }
  return TCL_ERROR;
}

/* This function takes the current result and turns it into an object command */
SWIGRUNTIME Tcl_Obj *
SWIG_Tcl_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
  Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
  /* Check to see if this pointer belongs to a class or not */
  if (thisvalue && (type->clientdata) && (interp)) {
    Tcl_CmdInfo    ci;
    char          *name;
    name = Tcl_GetStringFromObj(robj,NULL);
    if (!Tcl_GetCommandInfo(interp,name, &ci) || (flags)) {
      swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
      newinst->thisptr = Tcl_DuplicateObj(robj);
      Tcl_IncrRefCount(newinst->thisptr);
      newinst->thisvalue = thisvalue;
      newinst->classptr = (swig_class *) type->clientdata;
      newinst->destroy = flags;
      newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetStringFromObj(robj,NULL), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
      if (flags) {
        SWIG_Acquire(thisvalue);
      }
    }
  }
  return robj;
}

/* Function to create objects */
SWIGRUNTIME int
SWIG_Tcl_ObjectConstructor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Tcl_Obj          *newObj = 0;
  void             *thisvalue = 0;
  swig_instance   *newinst = 0;
  swig_class      *classptr = (swig_class *) clientData;
  swig_wrapper     cons = 0;
  char             *name = 0;
  int               firstarg = 0;
  int               thisarg = 0;
  int               destroy = 1;

  if (!classptr) {
    Tcl_SetResult(interp, (char *) "swig: internal runtime error. No class object defined.", TCL_STATIC);
    return TCL_ERROR;
  }
  cons = classptr->constructor;
  if (objc > 1) {
    char *s = Tcl_GetStringFromObj(objv[1],NULL);
    if (strcmp(s,"-this") == 0) {
      thisarg = 2;
      cons = 0;
    } else if (strcmp(s,"-args") == 0) {
      firstarg = 1;
    } else if (objc == 2) {
      firstarg = 1;
      name = s;
    } else if (objc >= 3) {
      char *s1;
      name = s;
      s1 = Tcl_GetStringFromObj(objv[2],NULL);
      if (strcmp(s1,"-this") == 0) {
	thisarg = 3;
	cons = 0;
      } else {
	firstarg = 1;
      }
    }
  }
  if (cons) {
    int result;
    result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
    if (result != TCL_OK) {
      return result;
    }
    newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
    if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
  } else if (thisarg > 0) {
    if (thisarg < objc) {
      destroy = 0;
      newObj = Tcl_DuplicateObj(objv[thisarg]);
      if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
    } else {
      Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
      return TCL_ERROR;
    }
  } else {
    Tcl_SetResult(interp, (char *) "No constructor available.", TCL_STATIC);
    return TCL_ERROR;
  }
  if (SWIG_Tcl_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type), 0) != SWIG_OK) {
    Tcl_DecrRefCount(newObj);
    return TCL_ERROR;
  }
  newinst = (swig_instance *) malloc(sizeof(swig_instance));
  newinst->thisptr = newObj;
  Tcl_IncrRefCount(newObj);
  newinst->thisvalue = thisvalue;
  newinst->classptr = classptr;
  newinst->destroy = destroy;
  if (destroy) {
    SWIG_Acquire(thisvalue);
  }
  newinst->cmdtok = Tcl_CreateObjCommand(interp,name, (swig_wrapper) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
  return TCL_OK;
}

/* -----------------------------------------------------------------------------*
 *   Get arguments 
 * -----------------------------------------------------------------------------*/
SWIGRUNTIME int
SWIG_Tcl_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...) {
  int        argno = 0, opt = 0;
  long       tempi;
  double     tempd;
  const char *c;
  va_list    ap;
  void      *vptr;
  Tcl_Obj   *obj = 0;
  swig_type_info *ty;

  va_start(ap,fmt);
  for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
    if (*c == '|') {
      opt = 1;
      c++;
    }
    if (argno >= (objc-1)) {
      if (!opt) {
        Tcl_SetResult(interp, (char *) "Wrong number of arguments ", TCL_STATIC);
        goto argerror;
      } else {
        va_end(ap);
        return TCL_OK;
      }
    }

    vptr = va_arg(ap,void *);
    if (vptr) {
      if (isupper(*c)) {
        obj = SWIG_Tcl_GetConstantObj(Tcl_GetStringFromObj(objv[argno+1],0));
        if (!obj) obj = objv[argno+1];
      } else {
        obj = objv[argno+1];
      }
      switch(*c) {
      case 'i': case 'I':
      case 'l': case 'L':
      case 'h': case 'H':
      case 'b': case 'B':
        if (Tcl_GetLongFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
        if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = (int)tempi;
        else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = (long)tempi;
        else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = (short)tempi;
        else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = (unsigned char)tempi;
        break;
      case 'f': case 'F':
      case 'd': case 'D':
        if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
        if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
        else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
        break;
      case 's': case 'S':
        if (*(c+1) == '#') {
          int *vlptr = (int *) va_arg(ap, void *);
          *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
          c++;
        } else {
          *((char **)vptr) = Tcl_GetStringFromObj(obj,NULL);
        }
        break;
      case 'c': case 'C':
        *((char *)vptr) = *(Tcl_GetStringFromObj(obj,NULL));
        break;
      case 'p': case 'P':
        ty = (swig_type_info *) va_arg(ap, void *);
        if (SWIG_Tcl_ConvertPtr(interp, obj, (void **) vptr, ty, 0) != SWIG_OK) goto argerror;
        break;
      case 'o': case 'O':
        *((Tcl_Obj **)vptr) = objv[argno+1];
        break;
      default:
        break;
      }
    }
  }

  if ((*c != ';') && ((objc-1) > argno)) {
    Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
    goto argerror;
  }
  va_end(ap);
  return TCL_OK;

 argerror:
  {
    char temp[32];
    sprintf(temp,"%d", argno+1);
    c = strchr(fmt,':');
    if (!c) c = strchr(fmt,';');
    if (!c) c = (char *)"";
    Tcl_AppendResult(interp,c," argument ", temp, NULL);
    va_end(ap);
    return TCL_ERROR;
  }
}

#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Alternative swig_types[0]
#define SWIGTYPE_p_Chksum swig_types[1]
#define SWIGTYPE_p_Dataiterator swig_types[2]
#define SWIGTYPE_p_Datamatch swig_types[3]
#define SWIGTYPE_p_Datapos swig_types[4]
#define SWIGTYPE_p_Dep swig_types[5]
#define SWIGTYPE_p_Job swig_types[6]
#define SWIGTYPE_p_Pool swig_types[7]
#define SWIGTYPE_p_Pool_repo_iterator swig_types[8]
#define SWIGTYPE_p_Pool_solvable_iterator swig_types[9]
#define SWIGTYPE_p_Problem swig_types[10]
#define SWIGTYPE_p_Queue swig_types[11]
#define SWIGTYPE_p_Repo swig_types[12]
#define SWIGTYPE_p_Repo_solvable_iterator swig_types[13]
#define SWIGTYPE_p_Ruleinfo swig_types[14]
#define SWIGTYPE_p_Selection swig_types[15]
#define SWIGTYPE_p_Solution swig_types[16]
#define SWIGTYPE_p_Solutionelement swig_types[17]
#define SWIGTYPE_p_SolvFp swig_types[18]
#define SWIGTYPE_p_Solver swig_types[19]
#define SWIGTYPE_p_TclObj swig_types[20]
#define SWIGTYPE_p_Tcl_Interp swig_types[21]
#define SWIGTYPE_p_Transaction swig_types[22]
#define SWIGTYPE_p_TransactionClass swig_types[23]
#define SWIGTYPE_p_XRepodata swig_types[24]
#define SWIGTYPE_p_XRule swig_types[25]
#define SWIGTYPE_p_XSolvable swig_types[26]
#define SWIGTYPE_p_char swig_types[27]
#define SWIGTYPE_p_int swig_types[28]
#define SWIGTYPE_p_p_XRule swig_types[29]
#define SWIGTYPE_p_unsigned_char swig_types[30]
#define SWIGTYPE_p_unsigned_int swig_types[31]
static swig_type_info *swig_types[33];
static swig_module_info swig_module = {swig_types, 32, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Solv_Init
#define SWIG_name    "solv"
#define SWIG_prefix  "solv::"
#define SWIG_namespace "solv"

#define SWIG_version "0.6.11"

#define SWIGVERSION 0x030005 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 



#ifdef __cplusplus
extern "C" {
#endif
#ifdef MAC_TCL
#pragma export on
#endif
SWIGEXPORT int SWIG_init(Tcl_Interp *);
#ifdef MAC_TCL
#pragma export off
#endif
#ifdef __cplusplus
}
#endif

/* Compatibility version for TCL stubs */
#ifndef SWIG_TCL_STUBS_VERSION
#define SWIG_TCL_STUBS_VERSION "8.1"
#endif



typedef struct {
  const void *data;
  size_t len;
} BinaryBlob;


#include <stdbool.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/utsname.h>
#include <sys/types.h>
#include <unistd.h>

/* argh, swig undefs bool for perl */
#ifndef bool
typedef int bool;
#endif

#include "pool.h"
#include "poolarch.h"
#include "evr.h"
#include "solver.h"
#include "policy.h"
#include "solverdebug.h"
#include "repo_solv.h"
#include "chksum.h"
#include "selection.h"

#include "repo_write.h"
#ifdef ENABLE_RPMDB
#include "repo_rpmdb.h"
#endif
#ifdef ENABLE_PUBKEY
#include "repo_pubkey.h"
#endif
#ifdef ENABLE_DEBIAN
#include "repo_deb.h"
#endif
#ifdef ENABLE_RPMMD
#include "repo_rpmmd.h"
#include "repo_updateinfoxml.h"
#include "repo_deltainfoxml.h"
#include "repo_repomdxml.h"
#endif
#ifdef ENABLE_SUSEREPO
#include "repo_products.h"
#include "repo_susetags.h"
#include "repo_content.h"
#endif
#ifdef ENABLE_MDKREPO
#include "repo_mdk.h"
#endif
#ifdef ENABLE_ARCHREPO
#include "repo_arch.h"
#endif
#ifdef SUSE
#include "repo_autopattern.h"
#endif
#include "solv_xfopen.h"

/* for old ruby versions */
#ifndef RARRAY_PTR
#define RARRAY_PTR(ary) (RARRAY(ary)->ptr)
#endif
#ifndef RARRAY_LEN
#define RARRAY_LEN(ary) (RARRAY(ary)->len)
#endif

#define SOLVER_SOLUTION_ERASE                   -100
#define SOLVER_SOLUTION_REPLACE                 -101
#define SOLVER_SOLUTION_REPLACE_DOWNGRADE       -102
#define SOLVER_SOLUTION_REPLACE_ARCHCHANGE      -103
#define SOLVER_SOLUTION_REPLACE_VENDORCHANGE    -104
#define SOLVER_SOLUTION_REPLACE_NAMECHANGE      -105

typedef void *AppObjectPtr;
typedef Id DepId;

typedef struct {
  Pool *pool;
  Id id;
} Dep;

typedef struct {
  Pool *pool;
  Id id;
} XSolvable;

typedef struct {
  Solver *solv;
  Id id;
} XRule;

typedef struct {
  Repo *repo;
  Id id;
} XRepodata;

typedef struct {
  Pool *pool;
  Id id;
} Pool_solvable_iterator;

typedef struct {
  Pool *pool;
  Id id;
} Pool_repo_iterator;

typedef struct {
  Repo *repo;
  Id id;
} Repo_solvable_iterator;

typedef struct {
  Pool *pool;
  int how;
  Id what;
} Job;

typedef struct {
  Solver *solv;
  Id id;
} Problem;

typedef struct {
  Solver *solv;
  Id problemid;
  Id id;
} Solution;

typedef struct {
  Solver *solv;
  Id problemid;
  Id solutionid;
  Id id;

  Id type;
  Id p;
  Id rp;
} Solutionelement;

typedef struct {
  Solver *solv;
  Id rid;
  Id type;
  Id source;
  Id target;
  Id dep_id;
} Ruleinfo;

typedef struct {
  Solver *solv;
  Id type;
  Id rid;
  Id from_id;
  Id dep_id;
  Id chosen_id;
  Queue choices;
  int level;
} Alternative;

typedef struct {
  Transaction *transaction;
  int mode;
  Id type;
  int count;
  Id fromid;
  Id toid;
} TransactionClass;

typedef struct {
  Pool *pool;
  Queue q;
  int flags;
} Selection;

typedef struct {
  FILE *fp;
} SolvFp;

typedef Dataiterator Datamatch;

typedef int disown_helper;



#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_long  (long value)
{
  if (((long) INT_MIN <= value) && (value <= (long) INT_MAX)) {
    return Tcl_NewIntObj((int)(value));
  } else {
    return Tcl_NewLongObj(value);
  }
}


SWIGINTERNINLINE Tcl_Obj *
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}

SWIGINTERN Selection *new_Selection(Pool *pool){
    Selection *s;
    s = solv_calloc(1, sizeof(*s));
    s->pool = pool;
    return s;
  }
SWIGINTERN void delete_Selection(Selection *self){
    queue_free(&self->q);
    solv_free(self);
  }
SWIGINTERN int Selection_flags(Selection *self){
    return self->flags;
  }
SWIGINTERN bool Selection_isempty(Selection *self){
    return self->q.count == 0;
  }

  #define SWIG_From_bool   Tcl_NewBooleanObj 

SWIGINTERN void Selection_filter(Selection *self,Selection *lsel){
    if (self->pool != lsel->pool)
      queue_empty(&self->q);
    else
      selection_filter(self->pool, &self->q, &lsel->q);
  }
SWIGINTERN void Selection_add(Selection *self,Selection *lsel){
    if (self->pool == lsel->pool)
      {
        selection_add(self->pool, &self->q, &lsel->q);
        self->flags |= lsel->flags;
      }
  }

SWIGINTERN int
SWIG_AsVal_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, long* val)
{
  long v;
  if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
    if (val) *val = (long) v;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}

SWIGINTERN void Selection_add_raw(Selection *self,Id how,Id what){
    queue_push2(&self->q, how, what);
  }
SWIGINTERN Queue Selection_jobs(Selection *self,int flags){
    Queue q;
    int i;
    queue_init_clone(&q, &self->q);
    for (i = 0; i < q.count; i += 2)
      q.elements[i] |= flags;
    return q;
  }
SWIGINTERN Queue Selection_solvables(Selection *self){
    Queue q;
    queue_init(&q);
    selection_solvables(self->pool, &self->q, &q);
    return q;
  }
SWIGINTERN char const *Selection___str__(Selection *self){
    return pool_selection2str(self->pool, &self->q, 0);
  }

SWIGINTERNINLINE Tcl_Obj *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  return (size < INT_MAX) ? Tcl_NewStringObj(carray, (int)(size)) : NULL;
}


SWIGINTERNINLINE Tcl_Obj * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}

SWIGINTERN char const *Selection___repr__(Selection *self){
    const char *str = pool_selection2str(self->pool, &self->q, ~0);
    return pool_tmpjoin(self->pool, "<Selection ", str, ">");
  }
SWIGINTERN Dep *new_Dep(Pool *pool,Id id){
    Dep *s;
    if (!id)
      return 0;
    s = solv_calloc(1, sizeof(*s));
    s->pool = pool;
    s->id = id;
    return s;
  }


SWIGINTERN int



SWIG_AsValDepId SWIG_TCL_DECL_ARGS_2(void *obj, int *val) {



  static swig_type_info* desc = 0;
  void *vptr = 0;
  int ecode;
  if (!desc) desc = SWIG_TypeQuery("Dep *");

  ecode = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(obj, val);



  if (SWIG_IsOK(ecode))
    return ecode;
  if ((SWIG_ConvertPtr(obj, &vptr, desc, 0)) == SWIG_OK) {
    if (val)
      *val = vptr ? ((Dep *)vptr)->id : 0;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}






SWIGINTERN int
SWIG_AsVal_bool SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, bool *val)
{
  int v;
  if (Tcl_GetBooleanFromObj(0, obj, &v) == TCL_OK) {
    if (val) *val = v ? true : false;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}

SWIGINTERN Dep *Dep_Rel(Dep *self,int flags,DepId evrid,bool create){
    Id id = pool_rel2id(self->pool, self->id, evrid, flags, create);
    if (!id)
      return 0;
    return new_Dep(self->pool, id);
  }
SWIGINTERN Selection *Dep_Selection_name(Dep *self,int setflags){
    Selection *sel = new_Selection(self->pool);
    if (ISRELDEP(self->id)) {
      Reldep *rd = GETRELDEP(self->pool, self->id);
      if (rd->flags == REL_EQ) {
        setflags |= self->pool->disttype == DISTTYPE_DEB || strchr(pool_id2str(self->pool, rd->evr), '-') != 0 ? SOLVER_SETEVR : SOLVER_SETEV;
        if (ISRELDEP(rd->name))
          rd = GETRELDEP(self->pool, rd->name);
      }
      if (rd->flags == REL_ARCH)
        setflags |= SOLVER_SETARCH;
    }
    queue_push2(&sel->q, SOLVER_SOLVABLE_NAME | setflags, self->id);
    return sel;
  }
SWIGINTERN Selection *Dep_Selection_provides(Dep *self,int setflags){
    Selection *sel = new_Selection(self->pool);
    if (ISRELDEP(self->id)) {
      Reldep *rd = GETRELDEP(self->pool, self->id);
      if (rd->flags == REL_ARCH)
        setflags |= SOLVER_SETARCH;
    }
    queue_push2(&sel->q, SOLVER_SOLVABLE_PROVIDES | setflags, self->id);
    return sel;
  }
SWIGINTERN char const *Dep_str(Dep *self){
    return pool_dep2str(self->pool, self->id);
  }
SWIGINTERN bool Dep___eq__(Dep *self,Dep *s){
    return self->pool == s->pool && self->id == s->id;
  }
SWIGINTERN bool Dep___ne__(Dep *self,Dep *s){
    return !Dep___eq__(self, s);
  }
SWIGINTERN char const *Dep___str__(Dep *self){
    return pool_dep2str(self->pool, self->id);
  }
SWIGINTERN char const *Dep___repr__(Dep *self){
    char buf[20];
    sprintf(buf, "<Id #%d ", self->id);
    return solv_dupjoin(buf, pool_dep2str(self->pool, self->id), ">");
  }

SWIGINTERN int
SWIG_AsCharPtrAndSize(Tcl_Obj *obj, char** cptr, size_t* psize, int *alloc)
{ 
  int len = 0;
  char *cstr = Tcl_GetStringFromObj(obj, &len);
  if (cstr) {
    if (cptr)  *cptr = cstr;
    if (psize) *psize = len + 1;
    if (alloc) *alloc = SWIG_OLDOBJ;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}




SWIGINTERN Dataiterator *new_Dataiterator(Pool *pool,Repo *repo,Id p,Id key,char const *match,int flags){
    Dataiterator *di = solv_calloc(1, sizeof(*di));
    dataiterator_init(di, pool, repo, p, key, match, flags);
    return di;
  }
SWIGINTERN void delete_Dataiterator(Dataiterator *self){
    dataiterator_free(self);
    solv_free(self);
  }
SWIGINTERN Datamatch *Dataiterator___next__(Dataiterator *self){
    Dataiterator *ndi;
    if (!dataiterator_step(self)) {
      return 0;
    }
    ndi = solv_calloc(1, sizeof(*ndi));
    dataiterator_init_clone(ndi, self);
    dataiterator_strdup(ndi);
    return ndi;
  }
SWIGINTERN void Dataiterator_prepend_keyname(Dataiterator *self,Id key){
    dataiterator_prepend_keyname(self, key);
  }
SWIGINTERN void Dataiterator_skip_solvable(Dataiterator *self){
    dataiterator_skip_solvable(self);
  }
SWIGINTERN XSolvable *new_XSolvable(Pool *pool,Id id){
    XSolvable *s;
    if (!id || id >= pool->nsolvables)
      return 0;
    s = solv_calloc(1, sizeof(*s));
    s->pool = pool;
    s->id = id;
    return s;
  }
SWIGINTERN char const *XSolvable_str(XSolvable *self){
    return pool_solvid2str(self->pool, self->id);
  }
SWIGINTERN char const *XSolvable_lookup_str(XSolvable *self,Id keyname){
    return pool_lookup_str(self->pool, self->id, keyname);
  }
SWIGINTERN Id XSolvable_lookup_id(XSolvable *self,Id keyname){
    return pool_lookup_id(self->pool, self->id, keyname);
  }

SWIGINTERN int
SWIG_AsVal_unsigned_SS_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, unsigned long *val) {
  long v;
  if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
    if (v >= 0) {
      if (val) *val = (unsigned long) v;
      return SWIG_OK;
    }
    /* If v is negative, then this could be a negative number, or an
       unsigned value which doesn't fit in a signed long, so try to
       get it as a string so we can distinguish these cases. */
  }
  {
    int len = 0;
    const char *nptr = Tcl_GetStringFromObj(obj, &len);
    if (nptr && len > 0) {
      char *endptr;
      unsigned long v;
      if (*nptr == '-') return SWIG_OverflowError;
      errno = 0;
      v = strtoul(nptr, &endptr,0);
      if (nptr[0] == '\0' || *endptr != '\0')
	return SWIG_TypeError;
      if (v == ULONG_MAX && errno == ERANGE) {
	errno = 0;
	return SWIG_OverflowError;
      } else {
	if (*endptr == '\0') {
	  if (val) *val = v;
	  return SWIG_OK;
	}
      }
    }
  }
  
  return SWIG_TypeError;
}


#include <stdlib.h>
#ifdef _MSC_VER
# ifndef strtoull
#  define strtoull _strtoui64
# endif
# ifndef strtoll
#  define strtoll _strtoi64
# endif
#endif


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, unsigned long long *val)
{
  long v;
  if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
    if (val) *val = (unsigned long) v;
    return SWIG_OK;
  } else {
    int len = 0;
    const char *nptr = Tcl_GetStringFromObj(obj, &len);
    if (nptr && len > 0) {
      char *endptr;
      unsigned long long v;
      if (*nptr == '-') return SWIG_OverflowError;
      errno = 0;
      v = strtoull(nptr, &endptr,0);
      if (nptr[0] == '\0' || *endptr != '\0')
	return SWIG_TypeError;
      if (v == ULLONG_MAX && errno == ERANGE) {
	errno = 0;
	return SWIG_OverflowError;
      } else {
	if (*endptr == '\0') {
	  if (val) *val = v;
	  return SWIG_OK;
	}
      }
    }
  }
  return SWIG_TypeError;
}

SWIGINTERN unsigned long long XSolvable_lookup_num(XSolvable *self,Id keyname,unsigned long long notfound){
    return pool_lookup_num(self->pool, self->id, keyname, notfound);
  }

#include <stdio.h>
#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
# ifndef snprintf
#  define snprintf _snprintf
# endif
#endif


SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_long_SS_long  (long long value)
{
  if (((long long) LONG_MIN <= value) && (value <= (long long) LONG_MAX)) {
    return SWIG_From_long  ((long)(value));
  } else {    
    char temp[256]; 
    sprintf(temp, "%lld", value);
    return Tcl_NewStringObj(temp,-1);
  }
}


SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  if (value < (unsigned long long) LONG_MAX) {
    return SWIG_From_long_SS_long  ((long long)(value));
  } else {
    char temp[256]; 
    sprintf(temp, "%llu", value);
    return Tcl_NewStringObj(temp,-1);
  }
}

SWIGINTERN bool XSolvable_lookup_void(XSolvable *self,Id keyname){
    return pool_lookup_void(self->pool, self->id, keyname);
  }
SWIGINTERN Chksum *XSolvable_lookup_checksum(XSolvable *self,Id keyname){
    Id type = 0;
    const unsigned char *b = pool_lookup_bin_checksum(self->pool, self->id, keyname, &type);
    return solv_chksum_create_from_bin(type, b);
  }
SWIGINTERN Queue XSolvable_lookup_idarray(XSolvable *self,Id keyname,Id marker){
    Solvable *s = self->pool->solvables + self->id;
    Queue r;
    queue_init(&r);
    solvable_lookup_deparray(s, keyname, &r, marker);
    return r;
  }
SWIGINTERN Queue XSolvable_lookup_deparray(XSolvable *self,Id keyname,Id marker){
    Solvable *s = self->pool->solvables + self->id;
    Queue r;
    queue_init(&r);
    solvable_lookup_deparray(s, keyname, &r, marker);
    return r;
  }

SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  if (value < (unsigned long) LONG_MAX) {
    return SWIG_From_long  ((long)(value));
  } else {
    char temp[256]; 
    sprintf(temp, "%lu", value);
    return Tcl_NewStringObj(temp,-1);
  }
}


SWIGINTERNINLINE Tcl_Obj *
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}

SWIGINTERN char const *XSolvable_lookup_location(XSolvable *self,unsigned int *OUTPUT){
    return solvable_lookup_location(self->pool->solvables + self->id, OUTPUT);
  }
SWIGINTERN Dataiterator *XSolvable_Dataiterator(XSolvable *self,Id key,char const *match,int flags){
    return new_Dataiterator(self->pool, 0, self->id, key, match, flags);
  }
SWIGINTERN bool XSolvable_installable(XSolvable *self){
    return pool_installable(self->pool, pool_id2solvable(self->pool, self->id));
  }
SWIGINTERN bool XSolvable_isinstalled(XSolvable *self){
    Pool *pool = self->pool;
    return pool->installed && pool_id2solvable(pool, self->id)->repo == pool->installed;
  }

    SWIGINTERN void XSolvable_name_set(XSolvable *xs, const char *name) {
      Pool *pool = xs->pool;
      pool->solvables[xs->id].name = pool_str2id(pool, name, 1);
    }
    SWIGINTERN const char *XSolvable_name_get(XSolvable *xs) {
      Pool *pool = xs->pool;
      return pool_id2str(pool, pool->solvables[xs->id].name);
    }
  

    SWIGINTERN void XSolvable_nameid_set(XSolvable *xs, Id nameid) {
      xs->pool->solvables[xs->id].name = nameid;
    }
    SWIGINTERN Id XSolvable_nameid_get(XSolvable *xs) {
      return xs->pool->solvables[xs->id].name;
    }
  

    SWIGINTERN void XSolvable_evr_set(XSolvable *xs, const char *evr) {
      Pool *pool = xs->pool;
      pool->solvables[xs->id].evr = pool_str2id(pool, evr, 1);
    }
    SWIGINTERN const char *XSolvable_evr_get(XSolvable *xs) {
      Pool *pool = xs->pool;
      return pool_id2str(pool, pool->solvables[xs->id].evr);
    }
  

    SWIGINTERN void XSolvable_evrid_set(XSolvable *xs, Id evrid) {
      xs->pool->solvables[xs->id].evr = evrid;
    }
    SWIGINTERN Id XSolvable_evrid_get(XSolvable *xs) {
      return xs->pool->solvables[xs->id].evr;
    }
  

    SWIGINTERN void XSolvable_arch_set(XSolvable *xs, const char *arch) {
      Pool *pool = xs->pool;
      pool->solvables[xs->id].arch = pool_str2id(pool, arch, 1);
    }
    SWIGINTERN const char *XSolvable_arch_get(XSolvable *xs) {
      Pool *pool = xs->pool;
      return pool_id2str(pool, pool->solvables[xs->id].arch);
    }
  

    SWIGINTERN void XSolvable_archid_set(XSolvable *xs, Id archid) {
      xs->pool->solvables[xs->id].arch = archid;
    }
    SWIGINTERN Id XSolvable_archid_get(XSolvable *xs) {
      return xs->pool->solvables[xs->id].arch;
    }
  

    SWIGINTERN void XSolvable_vendor_set(XSolvable *xs, const char *vendor) {
      Pool *pool = xs->pool;
      pool->solvables[xs->id].vendor = pool_str2id(pool, vendor, 1);
    }
    SWIGINTERN const char *XSolvable_vendor_get(XSolvable *xs) {
      Pool *pool = xs->pool;
      return pool_id2str(pool, pool->solvables[xs->id].vendor);
    }
  

    SWIGINTERN void XSolvable_vendorid_set(XSolvable *xs, Id vendorid) {
      xs->pool->solvables[xs->id].vendor = vendorid;
    }
    SWIGINTERN Id XSolvable_vendorid_get(XSolvable *xs) {
      return xs->pool->solvables[xs->id].vendor;
    }
  

    SWIGINTERN Repo *XSolvable_repo_get(XSolvable *xs) {
      return xs->pool->solvables[xs->id].repo;
    }
  
SWIGINTERN void XSolvable_add_provides(XSolvable *self,DepId id,Id marker){
    Solvable *s = self->pool->solvables + self->id;
    marker = solv_depmarker(SOLVABLE_PROVIDES, marker);
    s->provides = repo_addid_dep(s->repo, s->provides, id, marker);
  }
SWIGINTERN void XSolvable_add_obsoletes(XSolvable *self,DepId id){
    Solvable *s = self->pool->solvables + self->id;
    s->obsoletes = repo_addid_dep(s->repo, s->obsoletes, id, 0);
  }
SWIGINTERN void XSolvable_add_conflicts(XSolvable *self,DepId id){
    Solvable *s = self->pool->solvables + self->id;
    s->conflicts = repo_addid_dep(s->repo, s->conflicts, id, 0);
  }
SWIGINTERN void XSolvable_add_requires(XSolvable *self,DepId id,Id marker){
    Solvable *s = self->pool->solvables + self->id;
    marker = solv_depmarker(SOLVABLE_REQUIRES, marker);
    s->requires = repo_addid_dep(s->repo, s->requires, id, marker);
  }
SWIGINTERN void XSolvable_add_recommends(XSolvable *self,DepId id){
    Solvable *s = self->pool->solvables + self->id;
    s->recommends = repo_addid_dep(s->repo, s->recommends, id, 0);
  }
SWIGINTERN void XSolvable_add_suggests(XSolvable *self,DepId id){
    Solvable *s = self->pool->solvables + self->id;
    s->suggests = repo_addid_dep(s->repo, s->suggests, id, 0);
  }
SWIGINTERN void XSolvable_add_supplements(XSolvable *self,DepId id){
    Solvable *s = self->pool->solvables + self->id;
    s->supplements = repo_addid_dep(s->repo, s->supplements, id, 0);
  }
SWIGINTERN void XSolvable_add_enhances(XSolvable *self,DepId id){
    Solvable *s = self->pool->solvables + self->id;
    s->enhances = repo_addid_dep(s->repo, s->enhances, id, 0);
  }
SWIGINTERN void XSolvable_unset(XSolvable *self,Id keyname){
    Solvable *s = self->pool->solvables + self->id;
    repo_unset(s->repo, self->id, keyname);
  }
SWIGINTERN void XSolvable_add_deparray(XSolvable *self,Id keyname,DepId id,Id marker){
    Solvable *s = self->pool->solvables + self->id;
    solvable_add_deparray(s, keyname, id, marker);
  }
SWIGINTERN Selection *XSolvable_Selection(XSolvable *self,int setflags){
    Selection *sel = new_Selection(self->pool);
    queue_push2(&sel->q, SOLVER_SOLVABLE | setflags, self->id);
    return sel;
  }
SWIGINTERN bool XSolvable_identical(XSolvable *self,XSolvable *s2){
    return solvable_identical(self->pool->solvables + self->id, s2->pool->solvables + s2->id);
  }
SWIGINTERN int XSolvable_evrcmp(XSolvable *self,XSolvable *s2){
    return pool_evrcmp(self->pool, self->pool->solvables[self->id].evr, s2->pool->solvables[s2->id].evr, EVRCMP_COMPARE);
  }
SWIGINTERN bool XSolvable___eq__(XSolvable *self,XSolvable *s){
    return self->pool == s->pool && self->id == s->id;
  }
SWIGINTERN bool XSolvable___ne__(XSolvable *self,XSolvable *s){
    return !XSolvable___eq__(self, s);
  }
SWIGINTERN char const *XSolvable___str__(XSolvable *self){
    return pool_solvid2str(self->pool, self->id);
  }
SWIGINTERN char const *XSolvable___repr__(XSolvable *self){
    char buf[20];
    sprintf(buf, "<Solvable #%d ", self->id);
    return solv_dupjoin(buf, pool_solvid2str(self->pool, self->id), ">");
  }
SWIGINTERN Ruleinfo *new_Ruleinfo(XRule *r,Id type,Id source,Id target,Id dep_id){
    Ruleinfo *ri = solv_calloc(1, sizeof(*ri));
    ri->solv = r->solv;
    ri->rid = r->id;
    ri->type = type;
    ri->source = source;
    ri->target = target;
    ri->dep_id = dep_id;
    return ri;
  }

    SWIGINTERN XSolvable *Ruleinfo_solvable_get(Ruleinfo *ri) {
      return new_XSolvable(ri->solv->pool, ri->source);
    }
    SWIGINTERN XSolvable *Ruleinfo_othersolvable_get(Ruleinfo *ri) {
      return new_XSolvable(ri->solv->pool, ri->target);
    }
    SWIGINTERN Dep *Ruleinfo_dep_get(Ruleinfo *ri) {
      return new_Dep(ri->solv->pool, ri->dep_id);
    }
  
SWIGINTERN char const *Ruleinfo_problemstr(Ruleinfo *self){
    return solver_problemruleinfo2str(self->solv, self->type, self->source, self->target, self->dep_id);
  }
SWIGINTERN XRule *new_XRule(Solver *solv,Id id){
    if (!id)
      return 0;
    XRule *xr = solv_calloc(1, sizeof(*xr));
    xr->solv = solv;
    xr->id = id;
    return xr;
  }

    SWIGINTERN int XRule_type_get(XRule *xr) {
      return solver_ruleclass(xr->solv, xr->id);
    }
  
SWIGINTERN Ruleinfo *XRule_info(XRule *self){
    Id type, source, target, dep;
    type = solver_ruleinfo(self->solv, self->id, &source, &target, &dep);
    return new_Ruleinfo(self, type, source, target, dep);
  }
SWIGINTERN Queue XRule_allinfos(XRule *self){
    Queue q;
    queue_init(&q);
    solver_allruleinfos(self->solv, self->id, &q);
    return q;
  }
SWIGINTERN bool XRule___eq__(XRule *self,XRule *xr){
    return self->solv == xr->solv && self->id == xr->id;
  }
SWIGINTERN bool XRule___ne__(XRule *self,XRule *xr){
    return !XRule___eq__(self, xr);
  }
SWIGINTERN char const *XRule___repr__(XRule *self){
    char buf[20];
    sprintf(buf, "<Rule #%d>", self->id);
    return solv_strdup(buf);
  }
SWIGINTERN XRepodata *new_XRepodata(Repo *repo,Id id){
    XRepodata *xr = solv_calloc(1, sizeof(*xr));
    xr->repo = repo;
    xr->id = id;
    return xr;
  }
SWIGINTERN Id XRepodata_new_handle(XRepodata *self){
    return repodata_new_handle(repo_id2repodata(self->repo, self->id));
  }
SWIGINTERN void XRepodata_set_id(XRepodata *self,Id solvid,Id keyname,DepId id){
    repodata_set_id(repo_id2repodata(self->repo, self->id), solvid, keyname, id);
  }
SWIGINTERN void XRepodata_set_str(XRepodata *self,Id solvid,Id keyname,char const *str){
    repodata_set_str(repo_id2repodata(self->repo, self->id), solvid, keyname, str);
  }
SWIGINTERN void XRepodata_set_poolstr(XRepodata *self,Id solvid,Id keyname,char const *str){
    repodata_set_poolstr(repo_id2repodata(self->repo, self->id), solvid, keyname, str);
  }
SWIGINTERN void XRepodata_add_idarray(XRepodata *self,Id solvid,Id keyname,DepId id){
    repodata_add_idarray(repo_id2repodata(self->repo, self->id), solvid, keyname, id);
  }
SWIGINTERN void XRepodata_add_flexarray(XRepodata *self,Id solvid,Id keyname,Id handle){
    repodata_add_flexarray(repo_id2repodata(self->repo, self->id), solvid, keyname, handle);
  }
SWIGINTERN void XRepodata_set_checksum(XRepodata *self,Id solvid,Id keyname,Chksum *chksum){
    const unsigned char *buf = solv_chksum_get(chksum, 0);
    if (buf)
      repodata_set_bin_checksum(repo_id2repodata(self->repo, self->id), solvid, keyname, solv_chksum_get_type(chksum), buf);
  }
SWIGINTERN char const *XRepodata_lookup_str(XRepodata *self,Id solvid,Id keyname){
    return repodata_lookup_str(repo_id2repodata(self->repo, self->id), solvid, keyname);
  }
SWIGINTERN Queue XRepodata_lookup_idarray(XRepodata *self,Id solvid,Id keyname){
    Queue r;
    queue_init(&r);
    repodata_lookup_idarray(repo_id2repodata(self->repo, self->id), solvid, keyname, &r);
    return r;
  }
SWIGINTERN Chksum *XRepodata_lookup_checksum(XRepodata *self,Id solvid,Id keyname){
    Id type = 0;
    const unsigned char *b = repodata_lookup_bin_checksum(repo_id2repodata(self->repo, self->id), solvid, keyname, &type);
    return solv_chksum_create_from_bin(type, b);
  }
SWIGINTERN void XRepodata_internalize(XRepodata *self){
    repodata_internalize(repo_id2repodata(self->repo, self->id));
  }
SWIGINTERN void XRepodata_create_stubs(XRepodata *self){
    Repodata *data = repo_id2repodata(self->repo, self->id);
    data = repodata_create_stubs(data);
    self->id = data->repodataid;
  }



SWIGINTERN int



SWIG_AsValSolvFpPtr SWIG_TCL_DECL_ARGS_2(void *obj, FILE **val) {



  static swig_type_info* desc = 0;
  void *vptr = 0;
  int ecode;

  if (!desc) desc = SWIG_TypeQuery("SolvFp *");
  if ((SWIG_ConvertPtr(obj, &vptr, desc, 0)) == SWIG_OK) {
    if (val)
      *val = vptr ? ((SolvFp *)vptr)->fp : 0;
    return SWIG_OK;
  }





  return SWIG_TypeError;
}






SWIGINTERN bool XRepodata_write(XRepodata *self,FILE *fp){
    return repodata_write(repo_id2repodata(self->repo, self->id), fp) == 0;
  }
SWIGINTERN bool XRepodata_add_solv(XRepodata *self,FILE *fp,int flags){
    Repodata *data = repo_id2repodata(self->repo, self->id);
    int r, oldstate = data->state;
    data->state = REPODATA_LOADING;
    r = repo_add_solv(data->repo, fp, flags | REPO_USE_LOADING);
    if (r || data->state == REPODATA_LOADING)
      data->state = oldstate;
    return r;
  }
SWIGINTERN void XRepodata_extend_to_repo(XRepodata *self){
    Repodata *data = repo_id2repodata(self->repo, self->id);
    repodata_extend_block(data, data->repo->start, data->repo->end - data->repo->start);
  }
SWIGINTERN bool XRepodata___eq__(XRepodata *self,XRepodata *xr){
    return self->repo == xr->repo && self->id == xr->id;
  }
SWIGINTERN bool XRepodata___ne__(XRepodata *self,XRepodata *xr){
    return !XRepodata___eq__(self, xr);
  }
SWIGINTERN char const *XRepodata___repr__(XRepodata *self){
    char buf[20];
    sprintf(buf, "<Repodata #%d>", self->id);
    return solv_strdup(buf);
  }
SWIGINTERN Pool_solvable_iterator *new_Pool_solvable_iterator(Pool *pool){
    Pool_solvable_iterator *s;
    s = solv_calloc(1, sizeof(*s));
    s->pool = pool;
    return s;
  }
SWIGINTERN XSolvable *Pool_solvable_iterator___next__(Pool_solvable_iterator *self){
    Pool *pool = self->pool;
    if (self->id >= pool->nsolvables)
      return 0;
    while (++self->id < pool->nsolvables)
      if (pool->solvables[self->id].repo)
        return new_XSolvable(pool, self->id);
    return 0;
  }
SWIGINTERN XSolvable *Pool_solvable_iterator___getitem__(Pool_solvable_iterator *self,Id key){
    Pool *pool = self->pool;
    if (key > 0 && key < pool->nsolvables && pool->solvables[key].repo)
      return new_XSolvable(pool, key);
    return 0;
  }
SWIGINTERN int Pool_solvable_iterator___len__(Pool_solvable_iterator *self){
    return self->pool->nsolvables;
  }
SWIGINTERN Pool_repo_iterator *new_Pool_repo_iterator(Pool *pool){
    Pool_repo_iterator *s;
    s = solv_calloc(1, sizeof(*s));
    s->pool = pool;
    return s;
  }
SWIGINTERN Repo *Pool_repo_iterator___next__(Pool_repo_iterator *self){
    Pool *pool = self->pool;
    if (self->id >= pool->nrepos)
      return 0;
    while (++self->id < pool->nrepos) {
      Repo *r = pool_id2repo(pool, self->id);
      if (r)
        return r;
    }
    return 0;
  }
SWIGINTERN Repo *Pool_repo_iterator___getitem__(Pool_repo_iterator *self,Id key){
    Pool *pool = self->pool;
    if (key > 0 && key < pool->nrepos)
      return pool_id2repo(pool, key);
    return 0;
  }
SWIGINTERN int Pool_repo_iterator___len__(Pool_repo_iterator *self){
    return self->pool->nrepos;
  }
SWIGINTERN Repo_solvable_iterator *new_Repo_solvable_iterator(Repo *repo){
    Repo_solvable_iterator *s;
    s = solv_calloc(1, sizeof(*s));
    s->repo = repo;
    return s;
  }
SWIGINTERN XSolvable *Repo_solvable_iterator___next__(Repo_solvable_iterator *self){
    Repo *repo = self->repo;
    Pool *pool = repo->pool;
    if (repo->start > 0 && self->id < repo->start)
      self->id = repo->start - 1;
    if (self->id >= repo->end)
      return 0;
    while (++self->id < repo->end)
      if (pool->solvables[self->id].repo == repo)
        return new_XSolvable(pool, self->id);
    return 0;
  }
SWIGINTERN XSolvable *Repo_solvable_iterator___getitem__(Repo_solvable_iterator *self,Id key){
    Repo *repo = self->repo;
    Pool *pool = repo->pool;
    if (key > 0 && key < pool->nsolvables && pool->solvables[key].repo == repo)
      return new_XSolvable(pool, key);
    return 0;
  }
SWIGINTERN int Repo_solvable_iterator___len__(Repo_solvable_iterator *self){
    return self->repo->pool->nsolvables;
  }
SWIGINTERN void delete_Datamatch(Datamatch *self){
    dataiterator_free(self);
    solv_free(self);
  }

  SWIGINTERN XSolvable *Datamatch_solvable_get(Dataiterator *di) {
    return new_XSolvable(di->pool, di->solvid);
  }
  SWIGINTERN Id Datamatch_key_id_get(Dataiterator *di) {
    return di->key->name;
  }
  SWIGINTERN const char *Datamatch_key_idstr_get(Dataiterator *di) {
    return pool_id2str(di->pool, di->key->name);
  }
  SWIGINTERN Id Datamatch_type_id_get(Dataiterator *di) {
    return di->key->type;
  }
  SWIGINTERN const char *Datamatch_type_idstr_get(Dataiterator *di) {
    return pool_id2str(di->pool, di->key->type);
  }
  SWIGINTERN Id Datamatch_id_get(Dataiterator *di) {
    return di->kv.id;
  }
  SWIGINTERN const char *Datamatch_idstr_get(Dataiterator *di) {
   if (di->data && (di->key->type == REPOKEY_TYPE_DIR || di->key->type == REPOKEY_TYPE_DIRSTRARRAY || di->key->type == REPOKEY_TYPE_DIRNUMNUMARRAY))
      return repodata_dir2str(di->data,  di->kv.id, 0);
    if (di->data && di->data->localpool)
      return stringpool_id2str(&di->data->spool, di->kv.id);
    return pool_id2str(di->pool, di->kv.id);
  }
  SWIGINTERN const char * const Datamatch_str_get(Dataiterator *di) {
    return di->kv.str;
  }
  SWIGINTERN BinaryBlob Datamatch_binary_get(Dataiterator *di) {
    BinaryBlob bl;
    bl.data = 0;
    bl.len = 0;
    if (di->key->type == REPOKEY_TYPE_BINARY)
      {
        bl.data = di->kv.str;
        bl.len = di->kv.num;
      }
    else if ((bl.len = solv_chksum_len(di->key->type)) != 0)
      bl.data = di->kv.str;
    return bl;
  }
  SWIGINTERN unsigned long long Datamatch_num_get(Dataiterator *di) {
   if (di->key->type == REPOKEY_TYPE_NUM)
     return SOLV_KV_NUM64(&di->kv);
   return di->kv.num;
  }
  SWIGINTERN unsigned int Datamatch_num2_get(Dataiterator *di) {
    return di->kv.num2;
  }
  
SWIGINTERN Datapos *Datamatch_pos(Datamatch *self){
    Pool *pool = self->pool;
    Datapos *pos, oldpos = pool->pos;
    dataiterator_setpos(self);
    pos = solv_calloc(1, sizeof(*pos));
    *pos = pool->pos;
    pool->pos = oldpos;
    return pos;
  }
SWIGINTERN Datapos *Datamatch_parentpos(Datamatch *self){
    Pool *pool = self->pool;
    Datapos *pos, oldpos = pool->pos;
    dataiterator_setpos_parent(self);
    pos = solv_calloc(1, sizeof(*pos));
    *pos = pool->pos;
    pool->pos = oldpos;
    return pos;
  }
SWIGINTERN char const *Datamatch___str__(Datamatch *self){
    KeyValue kv = self->kv;
    const char *str = repodata_stringify(self->pool, self->data, self->key, &kv, SEARCH_FILES | SEARCH_CHECKSUMS);
    return str ? str : "";
  }
SWIGINTERN Id Datapos_lookup_id(Datapos *self,Id keyname){
    Pool *pool = self->repo->pool;
    Datapos oldpos = pool->pos;
    Id r;
    pool->pos = *self;
    r = pool_lookup_id(pool, SOLVID_POS, keyname);
    pool->pos = oldpos;
    return r;
  }
SWIGINTERN char const *Datapos_lookup_str(Datapos *self,Id keyname){
    Pool *pool = self->repo->pool;
    Datapos oldpos = pool->pos;
    const char *r;
    pool->pos = *self;
    r = pool_lookup_str(pool, SOLVID_POS, keyname);
    pool->pos = oldpos;
    return r;
  }
SWIGINTERN unsigned long long Datapos_lookup_num(Datapos *self,Id keyname,unsigned long long notfound){
    Pool *pool = self->repo->pool;
    Datapos oldpos = pool->pos;
    unsigned long long r;
    pool->pos = *self;
    r = pool_lookup_num(pool, SOLVID_POS, keyname, notfound);
    pool->pos = oldpos;
    return r;
  }
SWIGINTERN bool Datapos_lookup_void(Datapos *self,Id keyname){
    Pool *pool = self->repo->pool;
    Datapos oldpos = pool->pos;
    int r;
    pool->pos = *self;
    r = pool_lookup_void(pool, SOLVID_POS, keyname);
    pool->pos = oldpos;
    return r;
  }
SWIGINTERN Chksum *Datapos_lookup_checksum(Datapos *self,Id keyname){
    Pool *pool = self->repo->pool;
    Datapos oldpos = pool->pos;
    Id type = 0;
    const unsigned char *b;
    pool->pos = *self;
    b = pool_lookup_bin_checksum(pool, SOLVID_POS, keyname, &type);
    pool->pos = oldpos;
    return solv_chksum_create_from_bin(type, b);
  }
SWIGINTERN char const *Datapos_lookup_deltaseq(Datapos *self){
    Pool *pool = self->repo->pool;
    Datapos oldpos = pool->pos;
    const char *seq;
    pool->pos = *self;
    seq = pool_lookup_str(pool, SOLVID_POS, DELTA_SEQ_NAME);
    if (seq) {
      seq = pool_tmpjoin(pool, seq, "-", pool_lookup_str(pool, SOLVID_POS, DELTA_SEQ_EVR));
      seq = pool_tmpappend(pool, seq, "-", pool_lookup_str(pool, SOLVID_POS, DELTA_SEQ_NUM));
    }
    pool->pos = oldpos;
    return seq;
  }
SWIGINTERN char const *Datapos_lookup_deltalocation(Datapos *self,unsigned int *OUTPUT){
    Pool *pool = self->repo->pool;
    Datapos oldpos = pool->pos;
    const char *loc;
    pool->pos = *self;
    loc = pool_lookup_deltalocation(pool, SOLVID_POS, OUTPUT);
    pool->pos = oldpos;
    return loc;
  }
SWIGINTERN Queue Datapos_lookup_idarray(Datapos *self,Id keyname){
    Pool *pool = self->repo->pool;
    Datapos oldpos = pool->pos;
    Queue r;
    queue_init(&r);
    pool->pos = *self;
    pool_lookup_idarray(pool, SOLVID_POS, keyname, &r);
    pool->pos = oldpos;
    return r;
  }
SWIGINTERN Dataiterator *Datapos_Dataiterator(Datapos *self,Id key,char const *match,int flags){
    Pool *pool = self->repo->pool;
    Datapos oldpos = pool->pos;
    Dataiterator *di;
    pool->pos = *self;
    di = new_Dataiterator(pool, 0, SOLVID_POS, key, match, flags);
    pool->pos = oldpos;
    return di;
  }
SWIGINTERN Job *new_Job(Pool *pool,int how,Id what){
    Job *job = solv_calloc(1, sizeof(*job));
    job->pool = pool;
    job->how = how;
    job->what = what;
    return job;
  }
SWIGINTERN Queue Job_solvables(Job *self){
    Queue q;
    queue_init(&q);
    pool_job2solvables(self->pool, &q, self->how, self->what);
    return q;
  }
SWIGINTERN bool Job_isemptyupdate(Job *self){
    return pool_isemptyupdatejob(self->pool, self->how, self->what);
  }
SWIGINTERN bool Job___eq__(Job *self,Job *j){
    return self->pool == j->pool && self->how == j->how && self->what == j->what;
  }
SWIGINTERN bool Job___ne__(Job *self,Job *j){
    return !Job___eq__(self, j);
  }
SWIGINTERN char const *Job___str__(Job *self){
    return pool_job2str(self->pool, self->how, self->what, 0);
  }
SWIGINTERN char const *Job___repr__(Job *self){
    const char *str = pool_job2str(self->pool, self->how, self->what, ~0);
    return pool_tmpjoin(self->pool, "<Job ", str, ">");
  }
SWIGINTERN Pool *new_Pool(void){
    Pool *pool = pool_create();
    return pool;
  }
SWIGINTERN void Pool_set_debuglevel(Pool *self,int level){
    pool_setdebuglevel(self, level);
  }
SWIGINTERN int Pool_set_flag(Pool *self,int flag,int value){
    return pool_set_flag(self, flag, value);
  }
SWIGINTERN int Pool_get_flag(Pool *self,int flag){
    return pool_get_flag(self, flag);
  }
SWIGINTERN void Pool_set_rootdir(Pool *self,char const *rootdir){
    pool_set_rootdir(self, rootdir);
  }
SWIGINTERN char const *Pool_get_rootdir(Pool *self,int flag){
    return pool_get_rootdir(self);
  }

  typedef struct {
    Tcl_Interp *interp;
    Tcl_Obj *obj;
  } tcl_callback_t;
  SWIGINTERN int loadcallback(Pool *pool, Repodata *data, void *d) {
    tcl_callback_t *callback_var = (tcl_callback_t *)d;
    XRepodata *xd = new_XRepodata(data->repo, data->repodataid);
    Tcl_Obj *objvx[2];
    objvx[0] = callback_var->obj;
    objvx[1] = SWIG_NewPointerObj(SWIG_as_voidptr(xd), SWIGTYPE_p_XRepodata, SWIG_POINTER_OWN | 0); 
    int result = Tcl_EvalObjv(callback_var->interp, sizeof(objvx), objvx, TCL_EVAL_GLOBAL);
    int ecode = 0;
    int vresult = 0;
    Tcl_DecrRefCount(objvx[1]);
    if (result != TCL_OK)
      return 0; /* exception */
    ecode = SWIG_AsVal_int(callback_var->interp, Tcl_GetObjResult(callback_var->interp), &vresult);
    return SWIG_IsOK(ecode) ? vresult : 0;
  }
  
SWIGINTERN void Pool_set_loadcallback(Pool *self,Tcl_Obj *callable,Tcl_Interp *interp){
    tcl_callback_t *callable_temp;
    if (self->loadcallback == loadcallback) {
      tcl_callback_t *obj = self->loadcallbackdata;
      Tcl_DecrRefCount(obj->obj);
      free(obj);
    }
    if (callable) {
      Tcl_IncrRefCount(callable);
      callable_temp = malloc(sizeof(tcl_callback_t));
      callable_temp->interp = interp;
      callable_temp->obj = callable;
    }
    else {
      callable_temp = NULL;
    }
    pool_setloadcallback(self, callable ? loadcallback : 0, callable_temp);
  }
SWIGINTERN void delete_Pool(Pool *self){
    Pool_set_loadcallback(self, 0, 0);
    pool_free(self);
  }
SWIGINTERN disown_helper Pool_free(Pool *self){
    Pool_set_loadcallback(self, 0, 0);
    pool_free(self);
    return 0;
  }
SWIGINTERN disown_helper Pool_disown(Pool *self){
    return 0;
  }
SWIGINTERN Id Pool_str2id(Pool *self,char const *str,bool create){
    return pool_str2id(self, str, create);
  }
SWIGINTERN Dep *Pool_Dep(Pool *self,char const *str,bool create){
    Id id = pool_str2id(self, str, create);
    return new_Dep(self, id);
  }
SWIGINTERN char const *Pool_id2str(Pool *self,Id id){
    return pool_id2str(self, id);
  }
SWIGINTERN char const *Pool_dep2str(Pool *self,Id id){
    return pool_dep2str(self, id);
  }
SWIGINTERN Id Pool_rel2id(Pool *self,Id name,Id evr,int flags,bool create){
    return pool_rel2id(self, name, evr, flags, create);
  }
SWIGINTERN Id Pool_id2langid(Pool *self,Id id,char const *lang,bool create){
    return pool_id2langid(self, id, lang, create);
  }
SWIGINTERN void Pool_setarch(Pool *self,char const *arch){
    struct utsname un;
    if (!arch) {
      if (uname(&un)) {
        perror("uname");
        return;
      }
      arch = un.machine;
    }
    pool_setarch(self, arch);
  }
SWIGINTERN Repo *Pool_add_repo(Pool *self,char const *name){
    return repo_create(self, name);
  }
SWIGINTERN char const *Pool_lookup_str(Pool *self,Id entry,Id keyname){
    return pool_lookup_str(self, entry, keyname);
  }
SWIGINTERN Id Pool_lookup_id(Pool *self,Id entry,Id keyname){
    return pool_lookup_id(self, entry, keyname);
  }
SWIGINTERN unsigned long long Pool_lookup_num(Pool *self,Id entry,Id keyname,unsigned long long notfound){
    return pool_lookup_num(self, entry, keyname, notfound);
  }
SWIGINTERN bool Pool_lookup_void(Pool *self,Id entry,Id keyname){
    return pool_lookup_void(self, entry, keyname);
  }
SWIGINTERN Chksum *Pool_lookup_checksum(Pool *self,Id entry,Id keyname){
    Id type = 0;
    const unsigned char *b = pool_lookup_bin_checksum(self, entry, keyname, &type);
    return solv_chksum_create_from_bin(type, b);
  }
SWIGINTERN Dataiterator *Pool_Dataiterator(Pool *self,Id key,char const *match,int flags){
    return new_Dataiterator(self, 0, 0, key, match, flags);
  }
SWIGINTERN Dataiterator *Pool_Dataiterator_solvid(Pool *self,Id p,Id key,char const *match,int flags){
    return new_Dataiterator(self, 0, p, key, match, flags);
  }
SWIGINTERN char const *Pool_solvid2str(Pool *self,Id solvid){
    return pool_solvid2str(self, solvid);
  }
SWIGINTERN void Pool_addfileprovides(Pool *self){
    pool_addfileprovides(self);
  }
SWIGINTERN Queue Pool_addfileprovides_queue(Pool *self){
    Queue r;
    queue_init(&r);
    pool_addfileprovides_queue(self, &r, 0);
    return r;
  }
SWIGINTERN void Pool_createwhatprovides(Pool *self){
    pool_createwhatprovides(self);
  }
SWIGINTERN XSolvable *Pool_id2solvable(Pool *self,Id id){
    return new_XSolvable(self, id);
  }

  SWIGINTERN Pool_solvable_iterator * Pool_solvables_get(Pool *pool) {
    return new_Pool_solvable_iterator(pool);
  }
  
SWIGINTERN Pool_solvable_iterator *Pool_solvables_iter(Pool *self){
    return new_Pool_solvable_iterator(self);
  }
SWIGINTERN Repo *Pool_id2repo(Pool *self,Id id){
    if (id < 1 || id >= self->nrepos)
      return 0;
    return pool_id2repo(self, id);
  }

  SWIGINTERN Pool_repo_iterator * Pool_repos_get(Pool *pool) {
    return new_Pool_repo_iterator(pool);
  }
  
SWIGINTERN Pool_repo_iterator *Pool_repos_iter(Pool *self){
    return new_Pool_repo_iterator(self);
  }

  SWIGINTERN void Pool_installed_set(Pool *pool, Repo *installed) {
    pool_set_installed(pool, installed);
  }
  Repo *Pool_installed_get(Pool *pool) {
    return pool->installed;
  }
  const char *Pool_errstr_get(Pool *pool) {
    return pool_errstr(pool);
  }
  
SWIGINTERN Queue Pool_matchprovidingids(Pool *self,char const *match,int flags){
    Pool *pool = self;
    Queue q;
    Id id;
    queue_init(&q);
    if (!flags) {
      for (id = 1; id < pool->ss.nstrings; id++)
        if (pool->whatprovides[id])
          queue_push(&q, id);
    } else {
      Datamatcher ma;
      if (!datamatcher_init(&ma, match, flags)) {
        for (id = 1; id < pool->ss.nstrings; id++)
          if (pool->whatprovides[id] && datamatcher_match(&ma, pool_id2str(pool, id)))
            queue_push(&q, id);
        datamatcher_free(&ma);
      }
    }
    return q;
  }
SWIGINTERN Job *Pool_Job(Pool *self,int how,Id what){
    return new_Job(self, how, what);
  }
SWIGINTERN Queue Pool_whatprovides(Pool *self,DepId dep){
    Pool *pool = self;
    Queue q;
    Id p, pp;
    queue_init(&q);
    FOR_PROVIDES(p, pp, dep)
      queue_push(&q, p);
    return q;
  }
SWIGINTERN Id Pool_towhatprovides(Pool *self,Queue q){
    return pool_queuetowhatprovides(self, &q);
  }
SWIGINTERN Queue Pool_whatmatchesdep(Pool *self,Id keyname,DepId dep,Id marker){
    Queue q;
    queue_init(&q);
    pool_whatmatchesdep(self, keyname, dep, &q, marker);
    return q;
  }
SWIGINTERN bool Pool_isknownarch(Pool *self,DepId id){
    Pool *pool = self;
    if (!id || id == ID_EMPTY)
      return 0;
    if (id == ARCH_SRC || id == ARCH_NOSRC || id == ARCH_NOARCH)
      return 1;
    if (pool->id2arch && (id > pool->lastarch || !pool->id2arch[id]))
      return 0;
    return 1;
  }
SWIGINTERN Solver *Pool_Solver(Pool *self){
    return solver_create(self);
  }
SWIGINTERN Selection *Pool_Selection(Pool *self){
    return new_Selection(self);
  }
SWIGINTERN Selection *Pool_Selection_all(Pool *self,int setflags){
    Selection *sel = new_Selection(self);
    queue_push2(&sel->q, SOLVER_SOLVABLE_ALL | setflags, 0);
    return sel;
  }
SWIGINTERN Selection *Pool_select(Pool *self,char const *name,int flags){
    Selection *sel = new_Selection(self);
    sel->flags = selection_make(self, &sel->q, name, flags);
    return sel;
  }
SWIGINTERN void Pool_setpooljobs_helper(Pool *self,Queue jobs){
    queue_free(&self->pooljobs);
    queue_init_clone(&self->pooljobs, &jobs);
  }
SWIGINTERN Queue Pool_getpooljobs(Pool *self){
    Queue q;
    queue_init_clone(&q, &self->pooljobs);
    return q;
  }
SWIGINTERN void Repo_free(Repo *self,bool reuseids){
    repo_free(self, reuseids);
  }
SWIGINTERN void Repo_empty(Repo *self,bool reuseids){
    repo_empty(self, reuseids);
  }
SWIGINTERN bool Repo_isempty(Repo *self){
    return !self->nsolvables;
  }
SWIGINTERN bool Repo_add_solv__SWIG_0(Repo *self,char const *name,int flags){
    FILE *fp = fopen(name, "r");
    int r;
    if (!fp)
      return 0;
    r = repo_add_solv(self, fp, flags);
    fclose(fp);
    return r == 0;
  }
SWIGINTERN bool Repo_add_solv__SWIG_1(Repo *self,FILE *fp,int flags){
    return repo_add_solv(self, fp, flags) == 0;
  }
SWIGINTERN XSolvable *Repo_add_solvable(Repo *self){
    Id solvid = repo_add_solvable(self);
    return new_XSolvable(self->pool, solvid);
  }
SWIGINTERN void Repo_internalize(Repo *self){
    repo_internalize(self);
  }
SWIGINTERN bool Repo_write(Repo *self,FILE *fp){
    return repo_write(self, fp) == 0;
  }
SWIGINTERN bool Repo_write_first_repodata(Repo *self,FILE *fp){
    int oldnrepodata = self->nrepodata;
    int res;
    self->nrepodata = oldnrepodata > 2 ? 2 : oldnrepodata;
    res = repo_write(self, fp);
    self->nrepodata = oldnrepodata;
    return res == 0;
  }
SWIGINTERN Dataiterator *Repo_Dataiterator(Repo *self,Id key,char const *match,int flags){
    return new_Dataiterator(self->pool, self, 0, key, match, flags);
  }
SWIGINTERN Dataiterator *Repo_Dataiterator_meta(Repo *self,Id key,char const *match,int flags){
    return new_Dataiterator(self->pool, self, SOLVID_META, key, match, flags);
  }

  SWIGINTERN Id Repo_id_get(Repo *repo) {
    return repo->repoid;
  }
  

  SWIGINTERN Repo_solvable_iterator * Repo_solvables_get(Repo *repo) {
    return new_Repo_solvable_iterator(repo);
  }
  

  SWIGINTERN Datapos * Repo_meta_get(Repo *repo) {
    Datapos *pos = solv_calloc(1, sizeof(*pos));
    pos->solvid = SOLVID_META;
    pos->repo = repo;
    return pos;
  }
  
SWIGINTERN Repo_solvable_iterator *Repo_solvables_iter(Repo *self){
    return new_Repo_solvable_iterator(self);
  }
SWIGINTERN XRepodata *Repo_add_repodata(Repo *self,int flags){
    Repodata *rd = repo_add_repodata(self, flags);
    return new_XRepodata(self, rd->repodataid);
  }
SWIGINTERN void Repo_create_stubs(Repo *self){
    Repodata *data;
    if (!self->nrepodata)
      return;
    data = repo_id2repodata(self, self->nrepodata - 1);
    if (data->state != REPODATA_STUB)
      (void)repodata_create_stubs(data);
  }
SWIGINTERN bool Repo_iscontiguous(Repo *self){
    int i;
    for (i = self->start; i < self->end; i++)
      if (self->pool->solvables[i].repo != self)
        return 0;
    return 1;
  }
SWIGINTERN XRepodata *Repo_first_repodata(Repo *self){
    Repodata *data;
    int i;
    if (self->nrepodata < 2)
      return 0;
    /* make sure all repodatas but the first are extensions */
    data = repo_id2repodata(self, 1);
    if (data->loadcallback)
       return 0;
    for (i = 2; i < self->nrepodata; i++)
      {
        data = repo_id2repodata(self, i);
        if (!data->loadcallback)
          return 0;       /* oops, not an extension */
      }
    return new_XRepodata(self, 1);
  }
SWIGINTERN Selection *Repo_Selection(Repo *self,int setflags){
    Selection *sel = new_Selection(self->pool);
    setflags |= SOLVER_SETREPO;
    queue_push2(&sel->q, SOLVER_SOLVABLE_REPO | setflags, self->repoid);
    return sel;
  }
SWIGINTERN bool Repo___eq__(Repo *self,Repo *repo){
    return self == repo;
  }
SWIGINTERN bool Repo___ne__(Repo *self,Repo *repo){
    return self != repo;
  }
SWIGINTERN char const *Repo___str__(Repo *self){
    char buf[20];
    if (self->name)
      return solv_strdup(self->name);
    sprintf(buf, "Repo#%d", self->repoid);
    return solv_strdup(buf);
  }
SWIGINTERN char const *Repo___repr__(Repo *self){
    char buf[20];
    if (self->name)
      {
        sprintf(buf, "<Repo #%d ", self->repoid);
        return solv_dupjoin(buf, self->name, ">");
      }
    sprintf(buf, "<Repo #%d>", self->repoid);
    return solv_strdup(buf);
  }
SWIGINTERN void delete_Solver(Solver *self){
    solver_free(self);
  }
SWIGINTERN int Solver_set_flag(Solver *self,int flag,int value){
    return solver_set_flag(self, flag, value);
  }
SWIGINTERN int Solver_get_flag(Solver *self,int flag){
    return solver_get_flag(self, flag);
  }
SWIGINTERN Queue Solver_solve_helper(Solver *self,Queue jobs){
    Queue q;
    int i, cnt;
    queue_init(&q);
    solver_solve(self, &jobs);
    cnt = solver_problem_count(self);
    for (i = 1; i <= cnt; i++)
      queue_push(&q, i);
    return q;
  }
SWIGINTERN Transaction *Solver_transaction(Solver *self){
    return solver_create_transaction(self);
  }
SWIGINTERN int Solver_describe_decision(Solver *self,XSolvable *s,XRule **OUTPUT){
    int ruleid;
    int reason = solver_describe_decision(self, s->id, &ruleid);
    *OUTPUT = new_XRule(self, ruleid);
    return reason;
  }
SWIGINTERN int Solver_alternatives_count(Solver *self){
    return solver_alternatives_count(self);
  }
SWIGINTERN Alternative *Solver_alternative(Solver *self,Id aid){
    Alternative *a = solv_calloc(1, sizeof(*a));
    a->solv = self;
    queue_init(&a->choices);
    a->type = solver_get_alternative(self, aid, &a->dep_id, &a->from_id, &a->chosen_id, &a->choices, &a->level);
    if (!a->type) {
      queue_free(&a->choices);
      solv_free(a);
      return 0;
    }
    if (a->type == SOLVER_ALTERNATIVE_TYPE_RULE) {
      a->rid = a->dep_id;
      a->dep_id = 0;
    }
    return a;
  }
SWIGINTERN Queue Solver_all_alternatives(Solver *self){
    Queue q;
    int i, cnt;
    queue_init(&q);
    cnt = solver_alternatives_count(self);
    for (i = 1; i <= cnt; i++)
      queue_push(&q, i);
    return q;
  }
SWIGINTERN Chksum *new_Chksum__SWIG_0(Id type){
    return solv_chksum_create(type);
  }
SWIGINTERN Chksum *new_Chksum__SWIG_1(Id type,char const *hex){
    unsigned char buf[64];
    int l = solv_chksum_len(type);
    if (!l)
      return 0;
    if (solv_hex2bin(&hex, buf, sizeof(buf)) != l || hex[0])
      return 0;
    return solv_chksum_create_from_bin(type, buf);
  }
SWIGINTERN void delete_Chksum(Chksum *self){
    solv_chksum_free(self, 0);
  }

  SWIGINTERN Id Chksum_type_get(Chksum *chk) {
    return solv_chksum_get_type(chk);
  }
  

SWIGINTERNINLINE int
SWIG_AsVal_size_t SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long SWIG_TCL_CALL_ARGS_2(obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = (size_t)(v);
  return res;
}

SWIGINTERN void Chksum_add(Chksum *self,unsigned char const *str,size_t len){
    solv_chksum_add(self, str, (int)len);
  }
SWIGINTERN void Chksum_add_fp(Chksum *self,FILE *fp){
    char buf[4096];
    int l;
    while ((l = fread(buf, 1, sizeof(buf), fp)) > 0)
      solv_chksum_add(self, buf, l);
    rewind(fp);         /* convenience */
  }
SWIGINTERN void Chksum_add_fd(Chksum *self,int fd){
    char buf[4096];
    int l;
    while ((l = read(fd, buf, sizeof(buf))) > 0)
      solv_chksum_add(self, buf, l);
    lseek(fd, 0, 0);    /* convenience */
  }
SWIGINTERN void Chksum_add_stat(Chksum *self,char const *filename){
    struct stat stb;
    if (stat(filename, &stb))
      memset(&stb, 0, sizeof(stb));
    solv_chksum_add(self, &stb.st_dev, sizeof(stb.st_dev));
    solv_chksum_add(self, &stb.st_ino, sizeof(stb.st_ino));
    solv_chksum_add(self, &stb.st_size, sizeof(stb.st_size));
    solv_chksum_add(self, &stb.st_mtime, sizeof(stb.st_mtime));
  }
SWIGINTERN void Chksum_add_fstat(Chksum *self,int fd){
    struct stat stb;
    if (fstat(fd, &stb))
      memset(&stb, 0, sizeof(stb));
    solv_chksum_add(self, &stb.st_dev, sizeof(stb.st_dev));
    solv_chksum_add(self, &stb.st_ino, sizeof(stb.st_ino));
    solv_chksum_add(self, &stb.st_size, sizeof(stb.st_size));
    solv_chksum_add(self, &stb.st_mtime, sizeof(stb.st_mtime));
  }
SWIGINTERN BinaryBlob Chksum_raw(Chksum *self){
    BinaryBlob bl;
    int l;
    const unsigned char *b;
    b = solv_chksum_get(self, &l);
    bl.data = b;
    bl.len = l;
    return bl;
  }
SWIGINTERN char *Chksum_hex(Chksum *self){
    int l;
    const unsigned char *b;
    char *ret;

    b = solv_chksum_get(self, &l);
    ret = solv_malloc(2 * l + 1);
    solv_bin2hex(b, l, ret);
    return ret;
  }
SWIGINTERN char const *Chksum_typestr(Chksum *self){
    return solv_chksum_type2str(solv_chksum_get_type(self));
  }
SWIGINTERN bool Chksum___eq__(Chksum *self,Chksum *chk){
    int l;
    const unsigned char *b, *bo;
    if (!chk)
      return 0;
    if (solv_chksum_get_type(self) != solv_chksum_get_type(chk))
      return 0;
    b = solv_chksum_get(self, &l);
    bo = solv_chksum_get(chk, 0);
    return memcmp(b, bo, l) == 0;
  }
SWIGINTERN bool Chksum___ne__(Chksum *self,Chksum *chk){
    return !Chksum___eq__(self, chk);
  }
SWIGINTERN char const *Chksum___str__(Chksum *self){
    const char *str;
    const char *h = 0;
    if (solv_chksum_isfinished(self))
      h = Chksum_hex(self);
    str = solv_dupjoin(solv_chksum_type2str(solv_chksum_get_type(self)), ":", h ? h : "unfinished");
    solv_free((void *)h);
    return str;
  }
SWIGINTERN char const *Chksum___repr__(Chksum *self){
    const char *h = Chksum___str__(self);
    const char *str = solv_dupjoin("<Chksum ", h, ">");
    solv_free((void *)h);
    return str;
  }
SWIGINTERN void delete_SolvFp(SolvFp *self){
    if (self->fp)
      fclose(self->fp);
    free(self);
  }
SWIGINTERN int SolvFp_fileno(SolvFp *self){
    return self->fp ? fileno(self->fp) : -1;
  }
SWIGINTERN int SolvFp_dup(SolvFp *self){
    return self->fp ? dup(fileno(self->fp)) : -1;
  }
SWIGINTERN bool SolvFp_flush(SolvFp *self){
    if (!self->fp)
      return 1;
    return fflush(self->fp) == 0;
  }
SWIGINTERN bool SolvFp_close(SolvFp *self){
    bool ret;
    if (!self->fp)
      return 1;
    ret = fclose(self->fp) == 0;
    self->fp = 0;
    return ret;
  }

  SWIGINTERN SolvFp *solvfp_xfopen_fd(const char *fn, int fd, const char *mode) {
    SolvFp *sfp;
    FILE *fp;
    fd = dup(fd);
    fp = fd == -1 ? 0 : solv_xfopen_fd(fn, fd, mode);
    if (!fp)
      return 0;
    sfp = solv_calloc(1, sizeof(SolvFp));
    sfp->fp = fp;
    return sfp;
  }
  SWIGINTERN SolvFp *solvfp_xfopen(const char *fn, const char *mode) {
    SolvFp *sfp;
    FILE *fp;
    fp = solv_xfopen(fn, mode);
    if (!fp)
      return 0;
    sfp = solv_calloc(1, sizeof(SolvFp));
    sfp->fp = fp;
    return sfp;
  }

SWIGINTERN Problem *new_Problem(Solver *solv,Id id){
    Problem *p;
    p = solv_calloc(1, sizeof(*p));
    p->solv = solv;
    p->id = id;
    return p;
  }
SWIGINTERN XRule *Problem_findproblemrule(Problem *self){
    Id r = solver_findproblemrule(self->solv, self->id);
    return new_XRule(self->solv, r);
  }
SWIGINTERN Queue Problem_findallproblemrules(Problem *self,int unfiltered){
    Solver *solv = self->solv;
    Id probr;
    int i, j;
    Queue q;
    queue_init(&q);
    solver_findallproblemrules(solv, self->id, &q);
    if (!unfiltered)
      {
        for (i = j = 0; i < q.count; i++)
          {
            SolverRuleinfo rclass;
            probr = q.elements[i];
            rclass = solver_ruleclass(solv, probr);
            if (rclass == SOLVER_RULE_UPDATE || rclass == SOLVER_RULE_JOB)
              continue;
            q.elements[j++] = probr;
          }
        if (j)
          queue_truncate(&q, j);
      }
    return q;
  }
SWIGINTERN int Problem_solution_count(Problem *self){
    return solver_solution_count(self->solv, self->id);
  }
SWIGINTERN Queue Problem_solutions(Problem *self){
    Queue q;
    int i, cnt;
    queue_init(&q);
    cnt = solver_solution_count(self->solv, self->id);
    for (i = 1; i <= cnt; i++)
      queue_push(&q, i);
    return q;
  }
SWIGINTERN char const *Problem___str__(Problem *self){
    return solver_problem2str(self->solv, self->id);
  }
SWIGINTERN Solution *new_Solution(Problem *p,Id id){
    Solution *s;
    s = solv_calloc(1, sizeof(*s));
    s->solv = p->solv;
    s->problemid = p->id;
    s->id = id;
    return s;
  }
SWIGINTERN int Solution_element_count(Solution *self){
    return solver_solutionelement_count(self->solv, self->problemid, self->id);
  }
SWIGINTERN Queue Solution_elements(Solution *self,bool expandreplaces){
    Queue q;
    int i, cnt;
    queue_init(&q);
    cnt = solver_solutionelement_count(self->solv, self->problemid, self->id);
    for (i = 1; i <= cnt; i++)
      {
        Id p, rp, type;
        solver_next_solutionelement(self->solv, self->problemid, self->id, i - 1, &p, &rp);
        if (p > 0) {
          type = rp ? SOLVER_SOLUTION_REPLACE : SOLVER_SOLUTION_ERASE;
        } else {
          type = p;
          p = rp;
          rp = 0;
        }
        if (type == SOLVER_SOLUTION_REPLACE && expandreplaces) {
          int illegal = policy_is_illegal(self->solv, self->solv->pool->solvables + p, self->solv->pool->solvables + rp, 0);
          if (illegal) {
            if ((illegal & POLICY_ILLEGAL_DOWNGRADE) != 0) {
              queue_push2(&q, i, SOLVER_SOLUTION_REPLACE_DOWNGRADE);
              queue_push2(&q, p, rp);
            }
            if ((illegal & POLICY_ILLEGAL_ARCHCHANGE) != 0) {
              queue_push2(&q, i, SOLVER_SOLUTION_REPLACE_ARCHCHANGE);
              queue_push2(&q, p, rp);
            }
            if ((illegal & POLICY_ILLEGAL_VENDORCHANGE) != 0) {
              queue_push2(&q, i, SOLVER_SOLUTION_REPLACE_VENDORCHANGE);
              queue_push2(&q, p, rp);
            }
            if ((illegal & POLICY_ILLEGAL_NAMECHANGE) != 0) {
              queue_push2(&q, i, SOLVER_SOLUTION_REPLACE_NAMECHANGE);
              queue_push2(&q, p, rp);
            }
            continue;
          }
        }
        queue_push2(&q, i, type);
        queue_push2(&q, p, rp);
      }
    return q;
  }
SWIGINTERN Solutionelement *new_Solutionelement(Solver *solv,Id problemid,Id solutionid,Id id,Id type,Id p,Id rp){
    Solutionelement *e;
    e = solv_calloc(1, sizeof(*e));
    e->solv = solv;
    e->problemid = problemid;
    e->solutionid = id;
    e->id = id;
    e->type = type;
    e->p = p;
    e->rp = rp;
    return e;
  }
SWIGINTERN char const *Solutionelement_str(Solutionelement *self){
    Id p = self->type;
    Id rp = self->p;
    int illegal = 0;
    if (p == SOLVER_SOLUTION_ERASE)
      {
        p = rp;
        rp = 0;
      }
    else if (p == SOLVER_SOLUTION_REPLACE)
      {
        p = rp;
        rp = self->rp;
      }
    else if (p == SOLVER_SOLUTION_REPLACE_DOWNGRADE)
      illegal = POLICY_ILLEGAL_DOWNGRADE;
    else if (p == SOLVER_SOLUTION_REPLACE_ARCHCHANGE)
      illegal = POLICY_ILLEGAL_ARCHCHANGE;
    else if (p == SOLVER_SOLUTION_REPLACE_VENDORCHANGE)
      illegal = POLICY_ILLEGAL_VENDORCHANGE;
    else if (p == SOLVER_SOLUTION_REPLACE_NAMECHANGE)
      illegal = POLICY_ILLEGAL_NAMECHANGE;
    if (illegal)
      return pool_tmpjoin(self->solv->pool, "allow ", policy_illegal2str(self->solv, illegal, self->solv->pool->solvables + self->p, self->solv->pool->solvables + self->rp), 0);
    return solver_solutionelement2str(self->solv, p, rp);
  }
SWIGINTERN Queue Solutionelement_replaceelements(Solutionelement *self){
    Queue q;
    int illegal;

    queue_init(&q);
    if (self->type != SOLVER_SOLUTION_REPLACE || self->p <= 0 || self->rp <= 0)
      illegal = 0;
    else
      illegal = policy_is_illegal(self->solv, self->solv->pool->solvables + self->p, self->solv->pool->solvables + self->rp, 0);
    if ((illegal & POLICY_ILLEGAL_DOWNGRADE) != 0)
      queue_push(&q, SOLVER_SOLUTION_REPLACE_DOWNGRADE);
    if ((illegal & POLICY_ILLEGAL_ARCHCHANGE) != 0)
      queue_push(&q, SOLVER_SOLUTION_REPLACE_ARCHCHANGE);
    if ((illegal & POLICY_ILLEGAL_VENDORCHANGE) != 0)
      queue_push(&q, SOLVER_SOLUTION_REPLACE_VENDORCHANGE);
    if ((illegal & POLICY_ILLEGAL_NAMECHANGE) != 0)
      queue_push(&q, SOLVER_SOLUTION_REPLACE_NAMECHANGE);
    if (!q.count)
      queue_push(&q, self->type);
    return q;
  }
SWIGINTERN int Solutionelement_illegalreplace(Solutionelement *self){
    if (self->type != SOLVER_SOLUTION_REPLACE || self->p <= 0 || self->rp <= 0)
      return 0;
    return policy_is_illegal(self->solv, self->solv->pool->solvables + self->p, self->solv->pool->solvables + self->rp, 0);
  }

    SWIGINTERN XSolvable *Solutionelement_solvable_get(Solutionelement *e) {
      return new_XSolvable(e->solv->pool, e->p);
    }
    SWIGINTERN XSolvable *Solutionelement_replacement_get(Solutionelement *e) {
      return new_XSolvable(e->solv->pool, e->rp);
    }
    SWIGINTERN int Solutionelement_jobidx_get(Solutionelement *e) {
      if (e->type != SOLVER_SOLUTION_JOB && e->type != SOLVER_SOLUTION_POOLJOB)
        return -1;
      return (e->p - 1) / 2;
    }
  
SWIGINTERN Job *Solutionelement_Job(Solutionelement *self){
    Id extraflags = solver_solutionelement_extrajobflags(self->solv, self->problemid, self->solutionid);
    if (self->type == SOLVER_SOLUTION_JOB || self->type == SOLVER_SOLUTION_POOLJOB)
      return new_Job(self->solv->pool, SOLVER_NOOP, 0);
    if (self->type == SOLVER_SOLUTION_INFARCH || self->type == SOLVER_SOLUTION_DISTUPGRADE || self->type == SOLVER_SOLUTION_BEST)
      return new_Job(self->solv->pool, SOLVER_INSTALL|SOLVER_SOLVABLE|SOLVER_NOTBYUSER|extraflags, self->p);
    if (self->type == SOLVER_SOLUTION_REPLACE || self->type == SOLVER_SOLUTION_REPLACE_DOWNGRADE || self->type == SOLVER_SOLUTION_REPLACE_ARCHCHANGE || self->type == SOLVER_SOLUTION_REPLACE_VENDORCHANGE || self->type == SOLVER_SOLUTION_REPLACE_NAMECHANGE)
      return new_Job(self->solv->pool, SOLVER_INSTALL|SOLVER_SOLVABLE|SOLVER_NOTBYUSER|extraflags, self->rp);
    if (self->type == SOLVER_SOLUTION_ERASE)
      return new_Job(self->solv->pool, SOLVER_ERASE|SOLVER_SOLVABLE|extraflags, self->p);
    return 0;
  }
SWIGINTERN void delete_Alternative(Alternative *self){
    queue_free(&self->choices);
    solv_free(self);
  }

    SWIGINTERN XSolvable *Alternative_chosen_get(Alternative *a) {
      return new_XSolvable(a->solv->pool, a->chosen_id);
    }
    SWIGINTERN XRule *Alternative_rule_get(Alternative *a) {
      return new_XRule(a->solv, a->rid);
    }
    SWIGINTERN XSolvable *Alternative_depsolvable_get(Alternative *a) {
      return new_XSolvable(a->solv->pool, a->from_id);
    }
    SWIGINTERN Dep *Alternative_dep_get(Alternative *a) {
      return new_Dep(a->solv->pool, a->dep_id);
    }
  
SWIGINTERN Queue Alternative_choices_raw(Alternative *self){
    Queue r;
    queue_init_clone(&r, &self->choices);
    return r;
  }
SWIGINTERN Queue Alternative_choices(Alternative *self){
    int i;
    Queue r;
    queue_init_clone(&r, &self->choices);
    for (i = 0; i < r.count; i++)
      if (r.elements[i] < 0)
        r.elements[i] = -r.elements[i];
    return r;
  }
SWIGINTERN char const *Alternative___str__(Alternative *self){
    return solver_alternative2str(self->solv, self->type, self->type == SOLVER_ALTERNATIVE_TYPE_RULE ? self->rid : self->dep_id, self->from_id);
  }
SWIGINTERN void delete_Transaction(Transaction *self){
    transaction_free(self);
  }
SWIGINTERN bool Transaction_isempty(Transaction *self){
    return self->steps.count == 0;
  }
SWIGINTERN XSolvable *Transaction_othersolvable(Transaction *self,XSolvable *s){
    Id op = transaction_obs_pkg(self, s->id);
    return new_XSolvable(self->pool, op);
  }
SWIGINTERN Queue Transaction_allothersolvables(Transaction *self,XSolvable *s){
    Queue q;
    queue_init(&q);
    transaction_all_obs_pkgs(self, s->id, &q);
    return q;
  }
SWIGINTERN Queue Transaction_classify(Transaction *self,int mode){
    Queue q;
    queue_init(&q);
    transaction_classify(self, mode, &q);
    return q;
  }
SWIGINTERN Queue Transaction_newpackages(Transaction *self){
    Queue q;
    int cut;
    queue_init(&q);
    cut = transaction_installedresult(self, &q);
    queue_truncate(&q, cut);
    return q;
  }
SWIGINTERN Queue Transaction_keptpackages(Transaction *self){
    Queue q;
    int cut;
    queue_init(&q);
    cut = transaction_installedresult(self, &q);
    if (cut)
      queue_deleten(&q, 0, cut);
    return q;
  }
SWIGINTERN Queue Transaction_newsolvables(Transaction *self){
    Queue q;
    int cut;
    queue_init(&q);
    cut = transaction_installedresult(self, &q);
    queue_truncate(&q, cut);
    return q;
  }
SWIGINTERN Queue Transaction_keptsolvables(Transaction *self){
    Queue q;
    int cut;
    queue_init(&q);
    cut = transaction_installedresult(self, &q);
    if (cut)
      queue_deleten(&q, 0, cut);
    return q;
  }
SWIGINTERN Queue Transaction_steps(Transaction *self){
    Queue q;
    queue_init_clone(&q, &self->steps);
    return q;
  }
SWIGINTERN int Transaction_steptype(Transaction *self,XSolvable *s,int mode){
    return transaction_type(self, s->id, mode);
  }
SWIGINTERN int Transaction_calc_installsizechange(Transaction *self){
    return transaction_calc_installsizechange(self);
  }
SWIGINTERN void Transaction_order(Transaction *self,int flags){
    transaction_order(self, flags);
  }
SWIGINTERN TransactionClass *new_TransactionClass(Transaction *trans,int mode,Id type,int count,Id fromid,Id toid){
    TransactionClass *cl = solv_calloc(1, sizeof(*cl));
    cl->transaction = trans;
    cl->mode = mode;
    cl->type = type;
    cl->count = count;
    cl->fromid = fromid;
    cl->toid = toid;
    return cl;
  }
SWIGINTERN Queue TransactionClass_solvables(TransactionClass *self){
    Queue q;
    queue_init(&q);
    transaction_classify_pkgs(self->transaction, self->mode, self->type, self->fromid, self->toid, &q);
    return q;
  }

    SWIGINTERN const char *TransactionClass_fromstr_get(TransactionClass *cl) {
      return pool_id2str(cl->transaction->pool, cl->fromid);
    }
    SWIGINTERN const char *TransactionClass_tostr_get(TransactionClass *cl) {
      return pool_id2str(cl->transaction->pool, cl->toid);
    }
  
#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN int
_wrap_Selection_pool_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Selection_pool_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Selection_pool_get" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  result = (Pool *)(Pool *) ((arg1)->pool);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_Selection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Selection *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::new_Selection pool ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Selection" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (Selection *)new_Selection(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Selection,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Selection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Selection self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Selection" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  delete_Selection(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Selection_flags(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Selection_flags self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Selection_flags" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  result = (int)Selection_flags(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Selection_isempty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Selection_isempty self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Selection_isempty" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  result = (bool)Selection_isempty(arg1);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Selection_filter(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  Selection *arg2 = (Selection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Selection_filter self lsel ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Selection_filter" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Selection_filter" "', argument " "2"" of type '" "Selection *""'"); 
  }
  arg2 = (Selection *)(argp2);
  Selection_filter(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Selection_add(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  Selection *arg2 = (Selection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Selection_add self lsel ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Selection_add" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Selection_add" "', argument " "2"" of type '" "Selection *""'"); 
  }
  arg2 = (Selection *)(argp2);
  Selection_add(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Selection_add_raw(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  Id arg2 ;
  Id arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Selection_add_raw self how what ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Selection_add_raw" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Selection_add_raw" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Selection_add_raw" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  Selection_add_raw(arg1,arg2,arg3);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Selection_jobs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Selection_jobs self flags ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Selection_jobs" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Selection_jobs" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = Selection_jobs(arg1,arg2);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 2;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 2) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      Job * result = new_Job(arg1->pool, id, idp[1]);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Job,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Selection_solvables(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Selection_solvables self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Selection_solvables" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  result = Selection_solvables(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Selection___str__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Selection___str__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Selection___str__" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  result = (char *)Selection___str__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Selection___repr__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Selection *arg1 = (Selection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Selection___repr__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Selection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Selection___repr__" "', argument " "1"" of type '" "Selection *""'"); 
  }
  arg1 = (Selection *)(argp1);
  result = (char *)Selection___repr__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Selection(void *obj) {
Selection *arg1 = (Selection *) obj;
delete_Selection(arg1);
}
static swig_method swig_Selection_methods[] = {
    {"flags", _wrap_Selection_flags}, 
    {"isempty", _wrap_Selection_isempty}, 
    {"filter", _wrap_Selection_filter}, 
    {"add", _wrap_Selection_add}, 
    {"add_raw", _wrap_Selection_add_raw}, 
    {"jobs", _wrap_Selection_jobs}, 
    {"solvables", _wrap_Selection_solvables}, 
    {"__str__", _wrap_Selection___str__}, 
    {"__repr__", _wrap_Selection___repr__}, 
    {0,0}
};
static swig_attribute swig_Selection_attributes[] = {
    { "-pool",_wrap_Selection_pool_get, 0 },
    {0,0,0}
};
static swig_class *swig_Selection_bases[] = {0};
static const char * swig_Selection_base_names[] = {0};
static swig_class _wrap_class_Selection = { "Selection", &SWIGTYPE_p_Selection,_wrap_new_Selection, swig_delete_Selection, swig_Selection_methods, swig_Selection_attributes, swig_Selection_bases,swig_Selection_base_names, &swig_module };
SWIGINTERN int
_wrap_Dep_pool_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Dep_pool_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dep_pool_get" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  result = (Pool *)(Pool *) ((arg1)->pool);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dep_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Dep_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dep_id_get" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  result = (Id)(Id) ((arg1)->id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_Dep(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Dep *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::new_Dep pool id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Dep" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Dep" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (Dep *)new_Dep(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dep,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dep_Rel(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  int arg2 ;
  DepId arg3 ;
  bool arg4 = (bool) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  DepId val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  Dep *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo|o:solv::Dep_Rel self flags evrid ?create? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dep_Rel" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dep_Rel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Dep_Rel" "', argument " "3"" of type '" "DepId""'");
  } 
  arg3 = (DepId)(val3);
  if (objc > 4) {
    ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Dep_Rel" "', argument " "4"" of type '" "bool""'");
    } 
    arg4 = (bool)(val4);
  }
  result = (Dep *)Dep_Rel(arg1,arg2,arg3,arg4);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dep,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dep_Selection_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Selection *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Dep_Selection_name self ?setflags? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dep_Selection_name" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dep_Selection_name" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (Selection *)Dep_Selection_name(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Selection,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dep_Selection_provides(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Selection *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Dep_Selection_provides self ?setflags? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dep_Selection_provides" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dep_Selection_provides" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (Selection *)Dep_Selection_provides(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Selection,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dep_str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Dep_str self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dep_str" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  result = (char *)Dep_str(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dep___eq__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  Dep *arg2 = (Dep *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Dep___eq__ self s ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dep___eq__" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Dep___eq__" "', argument " "2"" of type '" "Dep *""'"); 
  }
  arg2 = (Dep *)(argp2);
  result = (bool)Dep___eq__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dep___ne__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  Dep *arg2 = (Dep *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Dep___ne__ self s ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dep___ne__" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Dep___ne__" "', argument " "2"" of type '" "Dep *""'"); 
  }
  arg2 = (Dep *)(argp2);
  result = (bool)Dep___ne__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dep___str__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Dep___str__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dep___str__" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  result = (char *)Dep___str__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dep___repr__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Dep___repr__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dep___repr__" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  result = (char *)Dep___repr__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  free((char*)result);
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Dep(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dep *arg1 = (Dep *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Dep self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dep, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Dep" "', argument " "1"" of type '" "Dep *""'"); 
  }
  arg1 = (Dep *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Dep(void *obj) {
Dep *arg1 = (Dep *) obj;
free((char *) arg1);
}
static swig_method swig_Dep_methods[] = {
    {"Rel", _wrap_Dep_Rel}, 
    {"Selection_name", _wrap_Dep_Selection_name}, 
    {"Selection_provides", _wrap_Dep_Selection_provides}, 
    {"str", _wrap_Dep_str}, 
    {"__eq__", _wrap_Dep___eq__}, 
    {"__ne__", _wrap_Dep___ne__}, 
    {"__str__", _wrap_Dep___str__}, 
    {"__repr__", _wrap_Dep___repr__}, 
    {0,0}
};
static swig_attribute swig_Dep_attributes[] = {
    { "-pool",_wrap_Dep_pool_get, 0 },
    { "-id",_wrap_Dep_id_get, 0 },
    {0,0,0}
};
static swig_class *swig_Dep_bases[] = {0};
static const char * swig_Dep_base_names[] = {0};
static swig_class _wrap_class_Dep = { "Dep", &SWIGTYPE_p_Dep,_wrap_new_Dep, swig_delete_Dep, swig_Dep_methods, swig_Dep_attributes, swig_Dep_bases,swig_Dep_base_names, &swig_module };
SWIGINTERN int
_wrap_new_Dataiterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Repo *arg2 = (Repo *) 0 ;
  Id arg3 ;
  Id arg4 ;
  char *arg5 = (char *) 0 ;
  int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  Dataiterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:solv::new_Dataiterator pool repo p key match flags ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Dataiterator" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Dataiterator" "', argument " "2"" of type '" "Repo *""'"); 
  }
  arg2 = (Repo *)(argp2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Dataiterator" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Dataiterator" "', argument " "4"" of type '" "Id""'");
  } 
  arg4 = (Id)(val4);
  res5 = SWIG_AsCharPtrAndSize(objv[5], &buf5, NULL, &alloc5);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_Dataiterator" "', argument " "5"" of type '" "char const *""'");
  }
  arg5 = (char *)(buf5);
  ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Dataiterator" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  result = (Dataiterator *)new_Dataiterator(arg1,arg2,arg3,arg4,(char const *)arg5,arg6);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dataiterator,0));
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return TCL_OK;
fail:
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Dataiterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dataiterator *arg1 = (Dataiterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Dataiterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dataiterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Dataiterator" "', argument " "1"" of type '" "Dataiterator *""'"); 
  }
  arg1 = (Dataiterator *)(argp1);
  delete_Dataiterator(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dataiterator___next__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dataiterator *arg1 = (Dataiterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Datamatch *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Dataiterator___next__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dataiterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataiterator___next__" "', argument " "1"" of type '" "Dataiterator *""'"); 
  }
  arg1 = (Dataiterator *)(argp1);
  result = (Datamatch *)Dataiterator___next__(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Datamatch,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dataiterator_prepend_keyname(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dataiterator *arg1 = (Dataiterator *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Dataiterator_prepend_keyname self key ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dataiterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataiterator_prepend_keyname" "', argument " "1"" of type '" "Dataiterator *""'"); 
  }
  arg1 = (Dataiterator *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Dataiterator_prepend_keyname" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  Dataiterator_prepend_keyname(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Dataiterator_skip_solvable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Dataiterator *arg1 = (Dataiterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Dataiterator_skip_solvable self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Dataiterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Dataiterator_skip_solvable" "', argument " "1"" of type '" "Dataiterator *""'"); 
  }
  arg1 = (Dataiterator *)(argp1);
  Dataiterator_skip_solvable(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Dataiterator(void *obj) {
Dataiterator *arg1 = (Dataiterator *) obj;
delete_Dataiterator(arg1);
}
static swig_method swig_Dataiterator_methods[] = {
    {"__next__", _wrap_Dataiterator___next__}, 
    {"prepend_keyname", _wrap_Dataiterator_prepend_keyname}, 
    {"skip_solvable", _wrap_Dataiterator_skip_solvable}, 
    {0,0}
};
static swig_attribute swig_Dataiterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Dataiterator_bases[] = {0};
static const char * swig_Dataiterator_base_names[] = {0};
static swig_class _wrap_class_Dataiterator = { "Dataiterator", &SWIGTYPE_p_Dataiterator,_wrap_new_Dataiterator, swig_delete_Dataiterator, swig_Dataiterator_methods, swig_Dataiterator_attributes, swig_Dataiterator_bases,swig_Dataiterator_base_names, &swig_module };
SWIGINTERN int
_wrap_XSolvable_pool_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_pool_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_pool_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (Pool *)(Pool *) ((arg1)->pool);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_id_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (Id)(Id) ((arg1)->id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_XSolvable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::new_XSolvable pool id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XSolvable" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XSolvable" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (XSolvable *)new_XSolvable(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_str self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_str" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (char *)XSolvable_str(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_lookup_str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_lookup_str self keyname ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_lookup_str" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_lookup_str" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (char *)XSolvable_lookup_str(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_lookup_id(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_lookup_id self keyname ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_lookup_id" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_lookup_id" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (Id)XSolvable_lookup_id(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_lookup_num(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  unsigned long long arg3 = (unsigned long long) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned long long val3 ;
  int ecode3 = 0 ;
  unsigned long long result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::XSolvable_lookup_num self keyname ?notfound? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_lookup_num" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_lookup_num" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_unsigned_SS_long_SS_long SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XSolvable_lookup_num" "', argument " "3"" of type '" "unsigned long long""'");
    } 
    arg3 = (unsigned long long)(val3);
  }
  result = (unsigned long long)XSolvable_lookup_num(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_unsigned_SS_long_SS_long((unsigned long long)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_lookup_void(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_lookup_void self keyname ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_lookup_void" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_lookup_void" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (bool)XSolvable_lookup_void(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_lookup_checksum(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Chksum *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_lookup_checksum self keyname ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_lookup_checksum" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_lookup_checksum" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (Chksum *)XSolvable_lookup_checksum(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Chksum,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_lookup_idarray(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  Id arg3 = (Id) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::XSolvable_lookup_idarray self keyname ?marker? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_lookup_idarray" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_lookup_idarray" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XSolvable_lookup_idarray" "', argument " "3"" of type '" "Id""'");
    } 
    arg3 = (Id)(val3);
  }
  result = XSolvable_lookup_idarray(arg1,arg2,arg3);
  {
    Tcl_Obj *objvx[(&result)->count];
    int i;
    
    for (i = 0; i < (&result)->count; i++) {
      objvx[i] = SWIG_From_int((&result)->elements[i]);
    }
    
    Tcl_SetObjResult(interp, Tcl_NewListObj((&result)->count, objvx));
    
    queue_free(&result);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_lookup_deparray(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  Id arg3 = (Id) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::XSolvable_lookup_deparray self keyname ?marker? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_lookup_deparray" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_lookup_deparray" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XSolvable_lookup_deparray" "', argument " "3"" of type '" "Id""'");
    } 
    arg3 = (Id)(val3);
  }
  result = XSolvable_lookup_deparray(arg1,arg2,arg3);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      Dep * result = new_Dep(arg1->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dep,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_lookup_location(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  char *result = 0 ;
  
  arg2 = &temp2;
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_lookup_location self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_lookup_location" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (char *)XSolvable_lookup_location(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (SWIG_IsTmpObj(res2)) {
    Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_unsigned_SS_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_unsigned_int, new_flags));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_Dataiterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  Dataiterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|oo:solv::XSolvable_Dataiterator self key ?match? ?flags? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_Dataiterator" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_Dataiterator" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  if (objc > 3) {
    res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XSolvable_Dataiterator" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (objc > 4) {
    ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "XSolvable_Dataiterator" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  result = (Dataiterator *)XSolvable_Dataiterator(arg1,arg2,(char const *)arg3,arg4);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dataiterator,0));
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_OK;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_installable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_installable self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_installable" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (bool)XSolvable_installable(arg1);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_isinstalled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_isinstalled self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_isinstalled" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (bool)XSolvable_isinstalled(arg1);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_name_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_name_set self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_name_set" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XSolvable_name_set" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  XSolvable_name_set(arg1,(char const *)arg2);
  
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_name_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_name_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_name_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (char *)XSolvable_name_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_nameid_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_nameid_set self nameid ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_nameid_set" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_nameid_set" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  XSolvable_nameid_set(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_nameid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_nameid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_nameid_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (Id)XSolvable_nameid_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_evr_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_evr_set self evr ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_evr_set" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XSolvable_evr_set" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  XSolvable_evr_set(arg1,(char const *)arg2);
  
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_evr_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_evr_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_evr_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (char *)XSolvable_evr_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_evrid_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_evrid_set self evrid ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_evrid_set" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_evrid_set" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  XSolvable_evrid_set(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_evrid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_evrid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_evrid_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (Id)XSolvable_evrid_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_arch_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_arch_set self arch ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_arch_set" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XSolvable_arch_set" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  XSolvable_arch_set(arg1,(char const *)arg2);
  
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_arch_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_arch_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_arch_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (char *)XSolvable_arch_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_archid_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_archid_set self archid ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_archid_set" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_archid_set" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  XSolvable_archid_set(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_archid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_archid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_archid_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (Id)XSolvable_archid_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_vendor_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_vendor_set self vendor ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_vendor_set" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XSolvable_vendor_set" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  XSolvable_vendor_set(arg1,(char const *)arg2);
  
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_vendor_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_vendor_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_vendor_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (char *)XSolvable_vendor_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_vendorid_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_vendorid_set self vendorid ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_vendorid_set" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_vendorid_set" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  XSolvable_vendorid_set(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_vendorid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_vendorid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_vendorid_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (Id)XSolvable_vendorid_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_repo_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Repo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable_repo_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_repo_get" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (Repo *)XSolvable_repo_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_add_provides(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  DepId arg2 ;
  Id arg3 = (Id) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DepId val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::XSolvable_add_provides self id ?marker? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_add_provides" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_add_provides" "', argument " "2"" of type '" "DepId""'");
  } 
  arg2 = (DepId)(val2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XSolvable_add_provides" "', argument " "3"" of type '" "Id""'");
    } 
    arg3 = (Id)(val3);
  }
  XSolvable_add_provides(arg1,arg2,arg3);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_add_obsoletes(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  DepId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DepId val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_add_obsoletes self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_add_obsoletes" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_add_obsoletes" "', argument " "2"" of type '" "DepId""'");
  } 
  arg2 = (DepId)(val2);
  XSolvable_add_obsoletes(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_add_conflicts(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  DepId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DepId val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_add_conflicts self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_add_conflicts" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_add_conflicts" "', argument " "2"" of type '" "DepId""'");
  } 
  arg2 = (DepId)(val2);
  XSolvable_add_conflicts(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_add_requires(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  DepId arg2 ;
  Id arg3 = (Id) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DepId val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::XSolvable_add_requires self id ?marker? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_add_requires" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_add_requires" "', argument " "2"" of type '" "DepId""'");
  } 
  arg2 = (DepId)(val2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XSolvable_add_requires" "', argument " "3"" of type '" "Id""'");
    } 
    arg3 = (Id)(val3);
  }
  XSolvable_add_requires(arg1,arg2,arg3);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_add_recommends(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  DepId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DepId val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_add_recommends self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_add_recommends" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_add_recommends" "', argument " "2"" of type '" "DepId""'");
  } 
  arg2 = (DepId)(val2);
  XSolvable_add_recommends(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_add_suggests(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  DepId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DepId val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_add_suggests self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_add_suggests" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_add_suggests" "', argument " "2"" of type '" "DepId""'");
  } 
  arg2 = (DepId)(val2);
  XSolvable_add_suggests(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_add_supplements(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  DepId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DepId val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_add_supplements self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_add_supplements" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_add_supplements" "', argument " "2"" of type '" "DepId""'");
  } 
  arg2 = (DepId)(val2);
  XSolvable_add_supplements(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_add_enhances(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  DepId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DepId val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_add_enhances self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_add_enhances" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_add_enhances" "', argument " "2"" of type '" "DepId""'");
  } 
  arg2 = (DepId)(val2);
  XSolvable_add_enhances(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_unset(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_unset self keyname ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_unset" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_unset" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  XSolvable_unset(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_add_deparray(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  Id arg2 ;
  DepId arg3 ;
  Id arg4 = (Id) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  DepId val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo|o:solv::XSolvable_add_deparray self keyname id ?marker? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_add_deparray" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_add_deparray" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XSolvable_add_deparray" "', argument " "3"" of type '" "DepId""'");
  } 
  arg3 = (DepId)(val3);
  if (objc > 4) {
    ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "XSolvable_add_deparray" "', argument " "4"" of type '" "Id""'");
    } 
    arg4 = (Id)(val4);
  }
  XSolvable_add_deparray(arg1,arg2,arg3,arg4);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_Selection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Selection *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::XSolvable_Selection self ?setflags? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_Selection" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XSolvable_Selection" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (Selection *)XSolvable_Selection(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Selection,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_identical(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  XSolvable *arg2 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_identical self s2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_identical" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XSolvable_identical" "', argument " "2"" of type '" "XSolvable *""'"); 
  }
  arg2 = (XSolvable *)(argp2);
  result = (bool)XSolvable_identical(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable_evrcmp(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  XSolvable *arg2 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable_evrcmp self s2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable_evrcmp" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XSolvable_evrcmp" "', argument " "2"" of type '" "XSolvable *""'"); 
  }
  arg2 = (XSolvable *)(argp2);
  result = (int)XSolvable_evrcmp(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable___eq__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  XSolvable *arg2 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable___eq__ self s ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable___eq__" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XSolvable___eq__" "', argument " "2"" of type '" "XSolvable *""'"); 
  }
  arg2 = (XSolvable *)(argp2);
  result = (bool)XSolvable___eq__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable___ne__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  XSolvable *arg2 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XSolvable___ne__ self s ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable___ne__" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XSolvable___ne__" "', argument " "2"" of type '" "XSolvable *""'"); 
  }
  arg2 = (XSolvable *)(argp2);
  result = (bool)XSolvable___ne__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable___str__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable___str__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable___str__" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (char *)XSolvable___str__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XSolvable___repr__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XSolvable___repr__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XSolvable___repr__" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  result = (char *)XSolvable___repr__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  free((char*)result);
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_XSolvable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XSolvable *arg1 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_XSolvable self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XSolvable, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XSolvable" "', argument " "1"" of type '" "XSolvable *""'"); 
  }
  arg1 = (XSolvable *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_XSolvable(void *obj) {
XSolvable *arg1 = (XSolvable *) obj;
free((char *) arg1);
}
static swig_method swig_XSolvable_methods[] = {
    {"str", _wrap_XSolvable_str}, 
    {"lookup_str", _wrap_XSolvable_lookup_str}, 
    {"lookup_id", _wrap_XSolvable_lookup_id}, 
    {"lookup_num", _wrap_XSolvable_lookup_num}, 
    {"lookup_void", _wrap_XSolvable_lookup_void}, 
    {"lookup_checksum", _wrap_XSolvable_lookup_checksum}, 
    {"lookup_idarray", _wrap_XSolvable_lookup_idarray}, 
    {"lookup_deparray", _wrap_XSolvable_lookup_deparray}, 
    {"lookup_location", _wrap_XSolvable_lookup_location}, 
    {"Dataiterator", _wrap_XSolvable_Dataiterator}, 
    {"installable", _wrap_XSolvable_installable}, 
    {"isinstalled", _wrap_XSolvable_isinstalled}, 
    {"add_provides", _wrap_XSolvable_add_provides}, 
    {"add_obsoletes", _wrap_XSolvable_add_obsoletes}, 
    {"add_conflicts", _wrap_XSolvable_add_conflicts}, 
    {"add_requires", _wrap_XSolvable_add_requires}, 
    {"add_recommends", _wrap_XSolvable_add_recommends}, 
    {"add_suggests", _wrap_XSolvable_add_suggests}, 
    {"add_supplements", _wrap_XSolvable_add_supplements}, 
    {"add_enhances", _wrap_XSolvable_add_enhances}, 
    {"unset", _wrap_XSolvable_unset}, 
    {"add_deparray", _wrap_XSolvable_add_deparray}, 
    {"Selection", _wrap_XSolvable_Selection}, 
    {"identical", _wrap_XSolvable_identical}, 
    {"evrcmp", _wrap_XSolvable_evrcmp}, 
    {"__eq__", _wrap_XSolvable___eq__}, 
    {"__ne__", _wrap_XSolvable___ne__}, 
    {"__str__", _wrap_XSolvable___str__}, 
    {"__repr__", _wrap_XSolvable___repr__}, 
    {0,0}
};
static swig_attribute swig_XSolvable_attributes[] = {
    { "-pool",_wrap_XSolvable_pool_get, 0 },
    { "-id",_wrap_XSolvable_id_get, 0 },
    { "-name",_wrap_XSolvable_name_get, _wrap_XSolvable_name_set},
    { "-nameid",_wrap_XSolvable_nameid_get, _wrap_XSolvable_nameid_set},
    { "-evr",_wrap_XSolvable_evr_get, _wrap_XSolvable_evr_set},
    { "-evrid",_wrap_XSolvable_evrid_get, _wrap_XSolvable_evrid_set},
    { "-arch",_wrap_XSolvable_arch_get, _wrap_XSolvable_arch_set},
    { "-archid",_wrap_XSolvable_archid_get, _wrap_XSolvable_archid_set},
    { "-vendor",_wrap_XSolvable_vendor_get, _wrap_XSolvable_vendor_set},
    { "-vendorid",_wrap_XSolvable_vendorid_get, _wrap_XSolvable_vendorid_set},
    { "-repo",_wrap_XSolvable_repo_get, 0 },
    {0,0,0}
};
static swig_class *swig_XSolvable_bases[] = {0};
static const char * swig_XSolvable_base_names[] = {0};
static swig_class _wrap_class_XSolvable = { "XSolvable", &SWIGTYPE_p_XSolvable,_wrap_new_XSolvable, swig_delete_XSolvable, swig_XSolvable_methods, swig_XSolvable_attributes, swig_XSolvable_bases,swig_XSolvable_base_names, &swig_module };
SWIGINTERN int
_wrap_Ruleinfo_solv_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Ruleinfo *arg1 = (Ruleinfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Solver *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Ruleinfo_solv_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Ruleinfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Ruleinfo_solv_get" "', argument " "1"" of type '" "Ruleinfo *""'"); 
  }
  arg1 = (Ruleinfo *)(argp1);
  result = (Solver *)(Solver *) ((arg1)->solv);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solver,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Ruleinfo_type_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Ruleinfo *arg1 = (Ruleinfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Ruleinfo_type_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Ruleinfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Ruleinfo_type_get" "', argument " "1"" of type '" "Ruleinfo *""'"); 
  }
  arg1 = (Ruleinfo *)(argp1);
  result = (Id)(Id) ((arg1)->type);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Ruleinfo_dep_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Ruleinfo *arg1 = (Ruleinfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Ruleinfo_dep_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Ruleinfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Ruleinfo_dep_id_get" "', argument " "1"" of type '" "Ruleinfo *""'"); 
  }
  arg1 = (Ruleinfo *)(argp1);
  result = (Id)(Id) ((arg1)->dep_id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_Ruleinfo(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRule *arg1 = (XRule *) 0 ;
  Id arg2 ;
  Id arg3 ;
  Id arg4 ;
  Id arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  Ruleinfo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:solv::new_Ruleinfo r type source target dep_id ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Ruleinfo" "', argument " "1"" of type '" "XRule *""'"); 
  }
  arg1 = (XRule *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Ruleinfo" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Ruleinfo" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Ruleinfo" "', argument " "4"" of type '" "Id""'");
  } 
  arg4 = (Id)(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Ruleinfo" "', argument " "5"" of type '" "Id""'");
  } 
  arg5 = (Id)(val5);
  result = (Ruleinfo *)new_Ruleinfo(arg1,arg2,arg3,arg4,arg5);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Ruleinfo,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Ruleinfo_solvable_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Ruleinfo *arg1 = (Ruleinfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Ruleinfo_solvable_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Ruleinfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Ruleinfo_solvable_get" "', argument " "1"" of type '" "Ruleinfo *""'"); 
  }
  arg1 = (Ruleinfo *)(argp1);
  result = (XSolvable *)Ruleinfo_solvable_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Ruleinfo_othersolvable_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Ruleinfo *arg1 = (Ruleinfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Ruleinfo_othersolvable_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Ruleinfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Ruleinfo_othersolvable_get" "', argument " "1"" of type '" "Ruleinfo *""'"); 
  }
  arg1 = (Ruleinfo *)(argp1);
  result = (XSolvable *)Ruleinfo_othersolvable_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Ruleinfo_dep_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Ruleinfo *arg1 = (Ruleinfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Dep *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Ruleinfo_dep_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Ruleinfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Ruleinfo_dep_get" "', argument " "1"" of type '" "Ruleinfo *""'"); 
  }
  arg1 = (Ruleinfo *)(argp1);
  result = (Dep *)Ruleinfo_dep_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dep,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Ruleinfo_problemstr(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Ruleinfo *arg1 = (Ruleinfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Ruleinfo_problemstr self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Ruleinfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Ruleinfo_problemstr" "', argument " "1"" of type '" "Ruleinfo *""'"); 
  }
  arg1 = (Ruleinfo *)(argp1);
  result = (char *)Ruleinfo_problemstr(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Ruleinfo(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Ruleinfo *arg1 = (Ruleinfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Ruleinfo self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Ruleinfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Ruleinfo" "', argument " "1"" of type '" "Ruleinfo *""'"); 
  }
  arg1 = (Ruleinfo *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Ruleinfo(void *obj) {
Ruleinfo *arg1 = (Ruleinfo *) obj;
free((char *) arg1);
}
static swig_method swig_Ruleinfo_methods[] = {
    {"problemstr", _wrap_Ruleinfo_problemstr}, 
    {0,0}
};
static swig_attribute swig_Ruleinfo_attributes[] = {
    { "-solv",_wrap_Ruleinfo_solv_get, 0 },
    { "-type",_wrap_Ruleinfo_type_get, 0 },
    { "-dep_id",_wrap_Ruleinfo_dep_id_get, 0 },
    { "-solvable",_wrap_Ruleinfo_solvable_get, 0 },
    { "-othersolvable",_wrap_Ruleinfo_othersolvable_get, 0 },
    { "-dep",_wrap_Ruleinfo_dep_get, 0 },
    {0,0,0}
};
static swig_class *swig_Ruleinfo_bases[] = {0};
static const char * swig_Ruleinfo_base_names[] = {0};
static swig_class _wrap_class_Ruleinfo = { "Ruleinfo", &SWIGTYPE_p_Ruleinfo,_wrap_new_Ruleinfo, swig_delete_Ruleinfo, swig_Ruleinfo_methods, swig_Ruleinfo_attributes, swig_Ruleinfo_bases,swig_Ruleinfo_base_names, &swig_module };
SWIGINTERN int
_wrap_XRule_solv_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRule *arg1 = (XRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Solver *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRule_solv_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRule_solv_get" "', argument " "1"" of type '" "XRule *""'"); 
  }
  arg1 = (XRule *)(argp1);
  result = (Solver *)(Solver *) ((arg1)->solv);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solver,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRule_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRule *arg1 = (XRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRule_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRule_id_get" "', argument " "1"" of type '" "XRule *""'"); 
  }
  arg1 = (XRule *)(argp1);
  result = (Id)(Id) ((arg1)->id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_XRule(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  XRule *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::new_XRule solv id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XRule" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XRule" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (XRule *)new_XRule(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XRule,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRule_type_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRule *arg1 = (XRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRule_type_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRule_type_get" "', argument " "1"" of type '" "XRule *""'"); 
  }
  arg1 = (XRule *)(argp1);
  result = (int)XRule_type_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRule_info(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRule *arg1 = (XRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Ruleinfo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRule_info self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRule_info" "', argument " "1"" of type '" "XRule *""'"); 
  }
  arg1 = (XRule *)(argp1);
  result = (Ruleinfo *)XRule_info(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Ruleinfo,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRule_allinfos(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRule *arg1 = (XRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRule_allinfos self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRule_allinfos" "', argument " "1"" of type '" "XRule *""'"); 
  }
  arg1 = (XRule *)(argp1);
  result = XRule_allinfos(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 4;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 4) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      Ruleinfo * result = new_Ruleinfo(arg1, id, idp[1], idp[2], idp[3]);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Ruleinfo,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRule___eq__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRule *arg1 = (XRule *) 0 ;
  XRule *arg2 = (XRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XRule___eq__ self xr ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRule___eq__" "', argument " "1"" of type '" "XRule *""'"); 
  }
  arg1 = (XRule *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XRule___eq__" "', argument " "2"" of type '" "XRule *""'"); 
  }
  arg2 = (XRule *)(argp2);
  result = (bool)XRule___eq__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRule___ne__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRule *arg1 = (XRule *) 0 ;
  XRule *arg2 = (XRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XRule___ne__ self xr ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRule___ne__" "', argument " "1"" of type '" "XRule *""'"); 
  }
  arg1 = (XRule *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XRule___ne__" "', argument " "2"" of type '" "XRule *""'"); 
  }
  arg2 = (XRule *)(argp2);
  result = (bool)XRule___ne__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRule___repr__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRule *arg1 = (XRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRule___repr__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRule___repr__" "', argument " "1"" of type '" "XRule *""'"); 
  }
  arg1 = (XRule *)(argp1);
  result = (char *)XRule___repr__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  free((char*)result);
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_XRule(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRule *arg1 = (XRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_XRule self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XRule" "', argument " "1"" of type '" "XRule *""'"); 
  }
  arg1 = (XRule *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_XRule(void *obj) {
XRule *arg1 = (XRule *) obj;
free((char *) arg1);
}
static swig_method swig_XRule_methods[] = {
    {"info", _wrap_XRule_info}, 
    {"allinfos", _wrap_XRule_allinfos}, 
    {"__eq__", _wrap_XRule___eq__}, 
    {"__ne__", _wrap_XRule___ne__}, 
    {"__repr__", _wrap_XRule___repr__}, 
    {0,0}
};
static swig_attribute swig_XRule_attributes[] = {
    { "-solv",_wrap_XRule_solv_get, 0 },
    { "-id",_wrap_XRule_id_get, 0 },
    { "-type",_wrap_XRule_type_get, 0 },
    {0,0,0}
};
static swig_class *swig_XRule_bases[] = {0};
static const char * swig_XRule_base_names[] = {0};
static swig_class _wrap_class_XRule = { "XRule", &SWIGTYPE_p_XRule,_wrap_new_XRule, swig_delete_XRule, swig_XRule_methods, swig_XRule_attributes, swig_XRule_bases,swig_XRule_base_names, &swig_module };
SWIGINTERN int
_wrap_XRepodata_repo_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Repo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRepodata_repo_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_repo_get" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  result = (Repo *)(Repo *) ((arg1)->repo);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRepodata_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_id_get" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  result = (Id)(Id) ((arg1)->id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_XRepodata(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  XRepodata *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::new_XRepodata repo id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XRepodata" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XRepodata" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (XRepodata *)new_XRepodata(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XRepodata,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_new_handle(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRepodata_new_handle self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_new_handle" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  result = (Id)XRepodata_new_handle(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_set_id(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  Id arg2 ;
  Id arg3 ;
  DepId arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  DepId val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:solv::XRepodata_set_id self solvid keyname id ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_set_id" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_set_id" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XRepodata_set_id" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  ecode4 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "XRepodata_set_id" "', argument " "4"" of type '" "DepId""'");
  } 
  arg4 = (DepId)(val4);
  XRepodata_set_id(arg1,arg2,arg3,arg4);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_set_str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  Id arg2 ;
  Id arg3 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:solv::XRepodata_set_str self solvid keyname str ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_set_str" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_set_str" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XRepodata_set_str" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XRepodata_set_str" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = (char *)(buf4);
  XRepodata_set_str(arg1,arg2,arg3,(char const *)arg4);
  
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return TCL_OK;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_set_poolstr(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  Id arg2 ;
  Id arg3 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:solv::XRepodata_set_poolstr self solvid keyname str ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_set_poolstr" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_set_poolstr" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XRepodata_set_poolstr" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XRepodata_set_poolstr" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = (char *)(buf4);
  XRepodata_set_poolstr(arg1,arg2,arg3,(char const *)arg4);
  
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return TCL_OK;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_add_idarray(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  Id arg2 ;
  Id arg3 ;
  DepId arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  DepId val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:solv::XRepodata_add_idarray self solvid keyname id ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_add_idarray" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_add_idarray" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XRepodata_add_idarray" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  ecode4 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "XRepodata_add_idarray" "', argument " "4"" of type '" "DepId""'");
  } 
  arg4 = (DepId)(val4);
  XRepodata_add_idarray(arg1,arg2,arg3,arg4);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_add_flexarray(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  Id arg2 ;
  Id arg3 ;
  Id arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:solv::XRepodata_add_flexarray self solvid keyname handle ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_add_flexarray" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_add_flexarray" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XRepodata_add_flexarray" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "XRepodata_add_flexarray" "', argument " "4"" of type '" "Id""'");
  } 
  arg4 = (Id)(val4);
  XRepodata_add_flexarray(arg1,arg2,arg3,arg4);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_set_checksum(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  Id arg2 ;
  Id arg3 ;
  Chksum *arg4 = (Chksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:solv::XRepodata_set_checksum self solvid keyname chksum ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_set_checksum" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_set_checksum" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XRepodata_set_checksum" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XRepodata_set_checksum" "', argument " "4"" of type '" "Chksum *""'"); 
  }
  arg4 = (Chksum *)(argp4);
  XRepodata_set_checksum(arg1,arg2,arg3,arg4);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_lookup_str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  Id arg2 ;
  Id arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::XRepodata_lookup_str self solvid keyname ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_lookup_str" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_lookup_str" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XRepodata_lookup_str" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  result = (char *)XRepodata_lookup_str(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_lookup_idarray(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  Id arg2 ;
  Id arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::XRepodata_lookup_idarray self solvid keyname ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_lookup_idarray" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_lookup_idarray" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XRepodata_lookup_idarray" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  result = XRepodata_lookup_idarray(arg1,arg2,arg3);
  {
    Tcl_Obj *objvx[(&result)->count];
    int i;
    
    for (i = 0; i < (&result)->count; i++) {
      objvx[i] = SWIG_From_int((&result)->elements[i]);
    }
    
    Tcl_SetObjResult(interp, Tcl_NewListObj((&result)->count, objvx));
    
    queue_free(&result);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_lookup_checksum(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  Id arg2 ;
  Id arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Chksum *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::XRepodata_lookup_checksum self solvid keyname ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_lookup_checksum" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_lookup_checksum" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XRepodata_lookup_checksum" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  result = (Chksum *)XRepodata_lookup_checksum(arg1,arg2,arg3);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Chksum,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_internalize(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRepodata_internalize self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_internalize" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  XRepodata_internalize(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_create_stubs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRepodata_create_stubs self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_create_stubs" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  XRepodata_create_stubs(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_write(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FILE *val2 ;
  int ecode2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XRepodata_write self fp ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_write" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsValSolvFpPtr SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_write" "', argument " "2"" of type '" "FILE *""'");
  } 
  arg2 = (FILE *)(val2);
  result = (bool)XRepodata_write(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_add_solv(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FILE *val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::XRepodata_add_solv self fp ?flags? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_add_solv" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  ecode2 = SWIG_AsValSolvFpPtr SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XRepodata_add_solv" "', argument " "2"" of type '" "FILE *""'");
  } 
  arg2 = (FILE *)(val2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XRepodata_add_solv" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  result = (bool)XRepodata_add_solv(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata_extend_to_repo(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRepodata_extend_to_repo self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata_extend_to_repo" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  XRepodata_extend_to_repo(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata___eq__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  XRepodata *arg2 = (XRepodata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XRepodata___eq__ self xr ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata___eq__" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XRepodata___eq__" "', argument " "2"" of type '" "XRepodata *""'"); 
  }
  arg2 = (XRepodata *)(argp2);
  result = (bool)XRepodata___eq__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata___ne__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  XRepodata *arg2 = (XRepodata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::XRepodata___ne__ self xr ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata___ne__" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XRepodata___ne__" "', argument " "2"" of type '" "XRepodata *""'"); 
  }
  arg2 = (XRepodata *)(argp2);
  result = (bool)XRepodata___ne__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_XRepodata___repr__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::XRepodata___repr__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XRepodata___repr__" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  result = (char *)XRepodata___repr__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  free((char*)result);
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_XRepodata(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XRepodata *arg1 = (XRepodata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_XRepodata self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_XRepodata, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XRepodata" "', argument " "1"" of type '" "XRepodata *""'"); 
  }
  arg1 = (XRepodata *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_XRepodata(void *obj) {
XRepodata *arg1 = (XRepodata *) obj;
free((char *) arg1);
}
static swig_method swig_XRepodata_methods[] = {
    {"new_handle", _wrap_XRepodata_new_handle}, 
    {"set_id", _wrap_XRepodata_set_id}, 
    {"set_str", _wrap_XRepodata_set_str}, 
    {"set_poolstr", _wrap_XRepodata_set_poolstr}, 
    {"add_idarray", _wrap_XRepodata_add_idarray}, 
    {"add_flexarray", _wrap_XRepodata_add_flexarray}, 
    {"set_checksum", _wrap_XRepodata_set_checksum}, 
    {"lookup_str", _wrap_XRepodata_lookup_str}, 
    {"lookup_idarray", _wrap_XRepodata_lookup_idarray}, 
    {"lookup_checksum", _wrap_XRepodata_lookup_checksum}, 
    {"internalize", _wrap_XRepodata_internalize}, 
    {"create_stubs", _wrap_XRepodata_create_stubs}, 
    {"write", _wrap_XRepodata_write}, 
    {"add_solv", _wrap_XRepodata_add_solv}, 
    {"extend_to_repo", _wrap_XRepodata_extend_to_repo}, 
    {"__eq__", _wrap_XRepodata___eq__}, 
    {"__ne__", _wrap_XRepodata___ne__}, 
    {"__repr__", _wrap_XRepodata___repr__}, 
    {0,0}
};
static swig_attribute swig_XRepodata_attributes[] = {
    { "-repo",_wrap_XRepodata_repo_get, 0 },
    { "-id",_wrap_XRepodata_id_get, 0 },
    {0,0,0}
};
static swig_class *swig_XRepodata_bases[] = {0};
static const char * swig_XRepodata_base_names[] = {0};
static swig_class _wrap_class_XRepodata = { "XRepodata", &SWIGTYPE_p_XRepodata,_wrap_new_XRepodata, swig_delete_XRepodata, swig_XRepodata_methods, swig_XRepodata_attributes, swig_XRepodata_bases,swig_XRepodata_base_names, &swig_module };
SWIGINTERN int
_wrap_new_Pool_solvable_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool_solvable_iterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::new_Pool_solvable_iterator pool ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pool_solvable_iterator" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (Pool_solvable_iterator *)new_Pool_solvable_iterator(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool_solvable_iterator,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_solvable_iterator___next__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool_solvable_iterator *arg1 = (Pool_solvable_iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_solvable_iterator___next__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool_solvable_iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_solvable_iterator___next__" "', argument " "1"" of type '" "Pool_solvable_iterator *""'"); 
  }
  arg1 = (Pool_solvable_iterator *)(argp1);
  result = (XSolvable *)Pool_solvable_iterator___next__(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_solvable_iterator___getitem__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool_solvable_iterator *arg1 = (Pool_solvable_iterator *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_solvable_iterator___getitem__ self key ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool_solvable_iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_solvable_iterator___getitem__" "', argument " "1"" of type '" "Pool_solvable_iterator *""'"); 
  }
  arg1 = (Pool_solvable_iterator *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_solvable_iterator___getitem__" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (XSolvable *)Pool_solvable_iterator___getitem__(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_solvable_iterator___len__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool_solvable_iterator *arg1 = (Pool_solvable_iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_solvable_iterator___len__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool_solvable_iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_solvable_iterator___len__" "', argument " "1"" of type '" "Pool_solvable_iterator *""'"); 
  }
  arg1 = (Pool_solvable_iterator *)(argp1);
  result = (int)Pool_solvable_iterator___len__(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Pool_solvable_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool_solvable_iterator *arg1 = (Pool_solvable_iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Pool_solvable_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool_solvable_iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Pool_solvable_iterator" "', argument " "1"" of type '" "Pool_solvable_iterator *""'"); 
  }
  arg1 = (Pool_solvable_iterator *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Pool_solvable_iterator(void *obj) {
Pool_solvable_iterator *arg1 = (Pool_solvable_iterator *) obj;
free((char *) arg1);
}
static swig_method swig_Pool_solvable_iterator_methods[] = {
    {"__next__", _wrap_Pool_solvable_iterator___next__}, 
    {"__getitem__", _wrap_Pool_solvable_iterator___getitem__}, 
    {"__len__", _wrap_Pool_solvable_iterator___len__}, 
    {0,0}
};
static swig_attribute swig_Pool_solvable_iterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Pool_solvable_iterator_bases[] = {0};
static const char * swig_Pool_solvable_iterator_base_names[] = {0};
static swig_class _wrap_class_Pool_solvable_iterator = { "Pool_solvable_iterator", &SWIGTYPE_p_Pool_solvable_iterator,_wrap_new_Pool_solvable_iterator, swig_delete_Pool_solvable_iterator, swig_Pool_solvable_iterator_methods, swig_Pool_solvable_iterator_attributes, swig_Pool_solvable_iterator_bases,swig_Pool_solvable_iterator_base_names, &swig_module };
SWIGINTERN int
_wrap_new_Pool_repo_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool_repo_iterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::new_Pool_repo_iterator pool ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pool_repo_iterator" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (Pool_repo_iterator *)new_Pool_repo_iterator(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool_repo_iterator,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_repo_iterator___next__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool_repo_iterator *arg1 = (Pool_repo_iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Repo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_repo_iterator___next__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool_repo_iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_repo_iterator___next__" "', argument " "1"" of type '" "Pool_repo_iterator *""'"); 
  }
  arg1 = (Pool_repo_iterator *)(argp1);
  result = (Repo *)Pool_repo_iterator___next__(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_repo_iterator___getitem__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool_repo_iterator *arg1 = (Pool_repo_iterator *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Repo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_repo_iterator___getitem__ self key ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool_repo_iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_repo_iterator___getitem__" "', argument " "1"" of type '" "Pool_repo_iterator *""'"); 
  }
  arg1 = (Pool_repo_iterator *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_repo_iterator___getitem__" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (Repo *)Pool_repo_iterator___getitem__(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_repo_iterator___len__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool_repo_iterator *arg1 = (Pool_repo_iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_repo_iterator___len__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool_repo_iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_repo_iterator___len__" "', argument " "1"" of type '" "Pool_repo_iterator *""'"); 
  }
  arg1 = (Pool_repo_iterator *)(argp1);
  result = (int)Pool_repo_iterator___len__(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Pool_repo_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool_repo_iterator *arg1 = (Pool_repo_iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Pool_repo_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool_repo_iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Pool_repo_iterator" "', argument " "1"" of type '" "Pool_repo_iterator *""'"); 
  }
  arg1 = (Pool_repo_iterator *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Pool_repo_iterator(void *obj) {
Pool_repo_iterator *arg1 = (Pool_repo_iterator *) obj;
free((char *) arg1);
}
static swig_method swig_Pool_repo_iterator_methods[] = {
    {"__next__", _wrap_Pool_repo_iterator___next__}, 
    {"__getitem__", _wrap_Pool_repo_iterator___getitem__}, 
    {"__len__", _wrap_Pool_repo_iterator___len__}, 
    {0,0}
};
static swig_attribute swig_Pool_repo_iterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Pool_repo_iterator_bases[] = {0};
static const char * swig_Pool_repo_iterator_base_names[] = {0};
static swig_class _wrap_class_Pool_repo_iterator = { "Pool_repo_iterator", &SWIGTYPE_p_Pool_repo_iterator,_wrap_new_Pool_repo_iterator, swig_delete_Pool_repo_iterator, swig_Pool_repo_iterator_methods, swig_Pool_repo_iterator_attributes, swig_Pool_repo_iterator_bases,swig_Pool_repo_iterator_base_names, &swig_module };
SWIGINTERN int
_wrap_new_Repo_solvable_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Repo_solvable_iterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::new_Repo_solvable_iterator repo ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Repo_solvable_iterator" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (Repo_solvable_iterator *)new_Repo_solvable_iterator(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo_solvable_iterator,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_solvable_iterator___next__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo_solvable_iterator *arg1 = (Repo_solvable_iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_solvable_iterator___next__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo_solvable_iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_solvable_iterator___next__" "', argument " "1"" of type '" "Repo_solvable_iterator *""'"); 
  }
  arg1 = (Repo_solvable_iterator *)(argp1);
  result = (XSolvable *)Repo_solvable_iterator___next__(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_solvable_iterator___getitem__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo_solvable_iterator *arg1 = (Repo_solvable_iterator *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Repo_solvable_iterator___getitem__ self key ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo_solvable_iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_solvable_iterator___getitem__" "', argument " "1"" of type '" "Repo_solvable_iterator *""'"); 
  }
  arg1 = (Repo_solvable_iterator *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_solvable_iterator___getitem__" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (XSolvable *)Repo_solvable_iterator___getitem__(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_solvable_iterator___len__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo_solvable_iterator *arg1 = (Repo_solvable_iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_solvable_iterator___len__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo_solvable_iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_solvable_iterator___len__" "', argument " "1"" of type '" "Repo_solvable_iterator *""'"); 
  }
  arg1 = (Repo_solvable_iterator *)(argp1);
  result = (int)Repo_solvable_iterator___len__(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Repo_solvable_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo_solvable_iterator *arg1 = (Repo_solvable_iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Repo_solvable_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo_solvable_iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Repo_solvable_iterator" "', argument " "1"" of type '" "Repo_solvable_iterator *""'"); 
  }
  arg1 = (Repo_solvable_iterator *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Repo_solvable_iterator(void *obj) {
Repo_solvable_iterator *arg1 = (Repo_solvable_iterator *) obj;
free((char *) arg1);
}
static swig_method swig_Repo_solvable_iterator_methods[] = {
    {"__next__", _wrap_Repo_solvable_iterator___next__}, 
    {"__getitem__", _wrap_Repo_solvable_iterator___getitem__}, 
    {"__len__", _wrap_Repo_solvable_iterator___len__}, 
    {0,0}
};
static swig_attribute swig_Repo_solvable_iterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Repo_solvable_iterator_bases[] = {0};
static const char * swig_Repo_solvable_iterator_base_names[] = {0};
static swig_class _wrap_class_Repo_solvable_iterator = { "Repo_solvable_iterator", &SWIGTYPE_p_Repo_solvable_iterator,_wrap_new_Repo_solvable_iterator, swig_delete_Repo_solvable_iterator, swig_Repo_solvable_iterator_methods, swig_Repo_solvable_iterator_attributes, swig_Repo_solvable_iterator_bases,swig_Repo_solvable_iterator_base_names, &swig_module };
SWIGINTERN int
_wrap_Datamatch_pool_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_pool_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_pool_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (Pool *)(Pool *) ((arg1)->pool);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_repo_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Repo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_repo_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_repo_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (Repo *)(Repo *) ((arg1)->repo);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_solvid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_solvid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_solvid_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (Id)(Id) ((arg1)->solvid);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Datamatch(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Datamatch self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Datamatch" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  delete_Datamatch(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_solvable_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_solvable_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_solvable_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (XSolvable *)Datamatch_solvable_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_key_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_key_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_key_id_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (Id)Datamatch_key_id_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_key_idstr_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_key_idstr_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_key_idstr_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (char *)Datamatch_key_idstr_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_type_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_type_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_type_id_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (Id)Datamatch_type_id_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_type_idstr_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_type_idstr_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_type_idstr_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (char *)Datamatch_type_idstr_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_id_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (Id)Datamatch_id_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_idstr_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_idstr_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_idstr_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (char *)Datamatch_idstr_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_str_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_str_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_str_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (char *)Datamatch_str_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_binary_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  BinaryBlob result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_binary_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_binary_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = Datamatch_binary_get(arg1);
  Tcl_SetObjResult(interp, SWIG_FromCharPtrAndSize((&result)->data, (&result)->len));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_num_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long long result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_num_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_num_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (unsigned long long)Datamatch_num_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_unsigned_SS_long_SS_long((unsigned long long)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_num2_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_num2_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_num2_get" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (unsigned int)Datamatch_num2_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_unsigned_SS_int((unsigned int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_pos(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Datapos *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_pos self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_pos" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (Datapos *)Datamatch_pos(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Datapos,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch_parentpos(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Datapos *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch_parentpos self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch_parentpos" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (Datapos *)Datamatch_parentpos(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Datapos,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datamatch___str__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datamatch *arg1 = (Datamatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datamatch___str__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datamatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datamatch___str__" "', argument " "1"" of type '" "Datamatch *""'"); 
  }
  arg1 = (Datamatch *)(argp1);
  result = (char *)Datamatch___str__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Datamatch(void *obj) {
Datamatch *arg1 = (Datamatch *) obj;
delete_Datamatch(arg1);
}
static swig_method swig_Datamatch_methods[] = {
    {"pos", _wrap_Datamatch_pos}, 
    {"parentpos", _wrap_Datamatch_parentpos}, 
    {"__str__", _wrap_Datamatch___str__}, 
    {0,0}
};
static swig_attribute swig_Datamatch_attributes[] = {
    { "-pool",_wrap_Datamatch_pool_get, 0 },
    { "-repo",_wrap_Datamatch_repo_get, 0 },
    { "-solvid",_wrap_Datamatch_solvid_get, 0 },
    { "-solvable",_wrap_Datamatch_solvable_get, 0 },
    { "-key_id",_wrap_Datamatch_key_id_get, 0 },
    { "-key_idstr",_wrap_Datamatch_key_idstr_get, 0 },
    { "-type_id",_wrap_Datamatch_type_id_get, 0 },
    { "-type_idstr",_wrap_Datamatch_type_idstr_get, 0 },
    { "-id",_wrap_Datamatch_id_get, 0 },
    { "-idstr",_wrap_Datamatch_idstr_get, 0 },
    { "-str",_wrap_Datamatch_str_get, 0 },
    { "-binary",_wrap_Datamatch_binary_get, 0 },
    { "-num",_wrap_Datamatch_num_get, 0 },
    { "-num2",_wrap_Datamatch_num2_get, 0 },
    {0,0,0}
};
static swig_class *swig_Datamatch_bases[] = {0};
static const char * swig_Datamatch_base_names[] = {0};
static swig_class _wrap_class_Datamatch = { "Datamatch", &SWIGTYPE_p_Datamatch,0, swig_delete_Datamatch, swig_Datamatch_methods, swig_Datamatch_attributes, swig_Datamatch_bases,swig_Datamatch_base_names, &swig_module };
SWIGINTERN int
_wrap_Datapos_repo_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Repo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datapos_repo_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datapos_repo_get" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  result = (Repo *)(Repo *) ((arg1)->repo);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datapos_lookup_id(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Datapos_lookup_id self keyname ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datapos_lookup_id" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Datapos_lookup_id" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (Id)Datapos_lookup_id(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datapos_lookup_str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Datapos_lookup_str self keyname ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datapos_lookup_str" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Datapos_lookup_str" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (char *)Datapos_lookup_str(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datapos_lookup_num(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  Id arg2 ;
  unsigned long long arg3 = (unsigned long long) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned long long val3 ;
  int ecode3 = 0 ;
  unsigned long long result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::Datapos_lookup_num self keyname ?notfound? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datapos_lookup_num" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Datapos_lookup_num" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_unsigned_SS_long_SS_long SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Datapos_lookup_num" "', argument " "3"" of type '" "unsigned long long""'");
    } 
    arg3 = (unsigned long long)(val3);
  }
  result = (unsigned long long)Datapos_lookup_num(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_unsigned_SS_long_SS_long((unsigned long long)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datapos_lookup_void(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Datapos_lookup_void self keyname ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datapos_lookup_void" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Datapos_lookup_void" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (bool)Datapos_lookup_void(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datapos_lookup_checksum(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Chksum *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Datapos_lookup_checksum self keyname ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datapos_lookup_checksum" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Datapos_lookup_checksum" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (Chksum *)Datapos_lookup_checksum(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Chksum,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datapos_lookup_deltaseq(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datapos_lookup_deltaseq self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datapos_lookup_deltaseq" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  result = (char *)Datapos_lookup_deltaseq(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datapos_lookup_deltalocation(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  char *result = 0 ;
  
  arg2 = &temp2;
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Datapos_lookup_deltalocation self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datapos_lookup_deltalocation" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  result = (char *)Datapos_lookup_deltalocation(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (SWIG_IsTmpObj(res2)) {
    Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_From_unsigned_SS_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_unsigned_int, new_flags));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datapos_lookup_idarray(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Datapos_lookup_idarray self keyname ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datapos_lookup_idarray" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Datapos_lookup_idarray" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = Datapos_lookup_idarray(arg1,arg2);
  {
    Tcl_Obj *objvx[(&result)->count];
    int i;
    
    for (i = 0; i < (&result)->count; i++) {
      objvx[i] = SWIG_From_int((&result)->elements[i]);
    }
    
    Tcl_SetObjResult(interp, Tcl_NewListObj((&result)->count, objvx));
    
    queue_free(&result);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Datapos_Dataiterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  Id arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  Dataiterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|oo:solv::Datapos_Dataiterator self key ?match? ?flags? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Datapos_Dataiterator" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Datapos_Dataiterator" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  if (objc > 3) {
    res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Datapos_Dataiterator" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (objc > 4) {
    ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Datapos_Dataiterator" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  result = (Dataiterator *)Datapos_Dataiterator(arg1,arg2,(char const *)arg3,arg4);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dataiterator,0));
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_OK;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Datapos(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Datapos *arg1 = (Datapos *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Datapos self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Datapos, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Datapos" "', argument " "1"" of type '" "Datapos *""'"); 
  }
  arg1 = (Datapos *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Datapos(void *obj) {
Datapos *arg1 = (Datapos *) obj;
free((char *) arg1);
}
static swig_method swig_Datapos_methods[] = {
    {"lookup_id", _wrap_Datapos_lookup_id}, 
    {"lookup_str", _wrap_Datapos_lookup_str}, 
    {"lookup_num", _wrap_Datapos_lookup_num}, 
    {"lookup_void", _wrap_Datapos_lookup_void}, 
    {"lookup_checksum", _wrap_Datapos_lookup_checksum}, 
    {"lookup_deltaseq", _wrap_Datapos_lookup_deltaseq}, 
    {"lookup_deltalocation", _wrap_Datapos_lookup_deltalocation}, 
    {"lookup_idarray", _wrap_Datapos_lookup_idarray}, 
    {"Dataiterator", _wrap_Datapos_Dataiterator}, 
    {0,0}
};
static swig_attribute swig_Datapos_attributes[] = {
    { "-repo",_wrap_Datapos_repo_get, 0 },
    {0,0,0}
};
static swig_class *swig_Datapos_bases[] = {0};
static const char * swig_Datapos_base_names[] = {0};
static swig_class _wrap_class_Datapos = { "Datapos", &SWIGTYPE_p_Datapos,0, swig_delete_Datapos, swig_Datapos_methods, swig_Datapos_attributes, swig_Datapos_bases,swig_Datapos_base_names, &swig_module };
SWIGINTERN int
_wrap_Job_pool_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Job_pool_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job_pool_get" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  result = (Pool *)(Pool *) ((arg1)->pool);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Job_how_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Job_how_set self how ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job_how_set" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Job_how_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->how = arg2;
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Job_how_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Job_how_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job_how_get" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  result = (int) ((arg1)->how);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Job_what_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Job_what_set self what ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job_what_set" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Job_what_set" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  if (arg1) (arg1)->what = arg2;
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Job_what_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Job_what_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job_what_get" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  result = (Id) ((arg1)->what);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_Job(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  int arg2 ;
  Id arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Job *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::new_Job pool how what ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Job" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Job" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Job" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  result = (Job *)new_Job(arg1,arg2,arg3);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Job,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Job_solvables(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Job_solvables self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job_solvables" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  result = Job_solvables(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Job_isemptyupdate(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Job_isemptyupdate self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job_isemptyupdate" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  result = (bool)Job_isemptyupdate(arg1);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Job___eq__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  Job *arg2 = (Job *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Job___eq__ self j ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job___eq__" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Job___eq__" "', argument " "2"" of type '" "Job *""'"); 
  }
  arg2 = (Job *)(argp2);
  result = (bool)Job___eq__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Job___ne__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  Job *arg2 = (Job *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Job___ne__ self j ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job___ne__" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Job___ne__" "', argument " "2"" of type '" "Job *""'"); 
  }
  arg2 = (Job *)(argp2);
  result = (bool)Job___ne__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Job___str__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Job___str__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job___str__" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  result = (char *)Job___str__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Job___repr__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Job___repr__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Job___repr__" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  result = (char *)Job___repr__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Job(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Job *arg1 = (Job *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Job self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Job, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Job" "', argument " "1"" of type '" "Job *""'"); 
  }
  arg1 = (Job *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Job(void *obj) {
Job *arg1 = (Job *) obj;
free((char *) arg1);
}
static swig_method swig_Job_methods[] = {
    {"solvables", _wrap_Job_solvables}, 
    {"isemptyupdate", _wrap_Job_isemptyupdate}, 
    {"__eq__", _wrap_Job___eq__}, 
    {"__ne__", _wrap_Job___ne__}, 
    {"__str__", _wrap_Job___str__}, 
    {"__repr__", _wrap_Job___repr__}, 
    {0,0}
};
static swig_attribute swig_Job_attributes[] = {
    { "-pool",_wrap_Job_pool_get, 0 },
    { "-how",_wrap_Job_how_get, _wrap_Job_how_set},
    { "-what",_wrap_Job_what_get, _wrap_Job_what_set},
    {0,0,0}
};
static swig_class *swig_Job_bases[] = {0};
static const char * swig_Job_base_names[] = {0};
static swig_class _wrap_class_Job = { "Job", &SWIGTYPE_p_Job,_wrap_new_Job, swig_delete_Job, swig_Job_methods, swig_Job_attributes, swig_Job_bases,swig_Job_base_names, &swig_module };
SWIGINTERN int
_wrap_Pool_appdata_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  AppObjectPtr arg2 = (AppObjectPtr) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_appdata_set self appdata ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_appdata_set" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TclObj, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pool_appdata_set" "', argument " "2"" of type '" "AppObjectPtr""'"); 
  }
  arg2 = (AppObjectPtr)(argp2);
  if (arg1) (arg1)->appdata = arg2;
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_appdata_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  AppObjectPtr result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_appdata_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_appdata_get" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (AppObjectPtr) ((arg1)->appdata);
  {
    Tcl_SetObjResult(interp, result ? result : Tcl_NewObj());
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_Pool(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":solv::new_Pool ") == TCL_ERROR) SWIG_fail;
  result = (Pool *)new_Pool();
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_set_debuglevel(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_set_debuglevel self level ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_set_debuglevel" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_set_debuglevel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  Pool_set_debuglevel(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_set_flag(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Pool_set_flag self flag value ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_set_flag" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_set_flag" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_set_flag" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (int)Pool_set_flag(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_get_flag(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_get_flag self flag ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_get_flag" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_get_flag" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = (int)Pool_get_flag(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_set_rootdir(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_set_rootdir self rootdir ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_set_rootdir" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pool_set_rootdir" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  Pool_set_rootdir(arg1,(char const *)arg2);
  
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_get_rootdir(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_get_rootdir self flag ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_get_rootdir" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_get_rootdir" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = (char *)Pool_get_rootdir(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_set_loadcallback(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Tcl_Obj *arg2 = (Tcl_Obj *) 0 ;
  Tcl_Interp *arg3 = (Tcl_Interp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  {
    arg3 = interp;
  }
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_set_loadcallback self callable ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_set_loadcallback" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  arg2 = objv[2];
  Pool_set_loadcallback(arg1,arg2,arg3);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Pool(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Pool self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Pool" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  delete_Pool(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_free(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  disown_helper result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_free self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_free" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = Pool_free(arg1);
  {
    SWIG_ConvertPtr(objv[1], &argp1, SWIGTYPE_p_Pool, SWIG_POINTER_DISOWN | 0);
    
    
    
    
    
    Tcl_SetObjResult(interp, SWIG_From_int((int)(0)));
    
    
    
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_disown(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  disown_helper result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_disown self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_disown" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = Pool_disown(arg1);
  {
    SWIG_ConvertPtr(objv[1], &argp1, SWIGTYPE_p_Pool, SWIG_POINTER_DISOWN | 0);
    
    
    
    
    
    Tcl_SetObjResult(interp, SWIG_From_int((int)(0)));
    
    
    
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_str2id(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 = (bool) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::Pool_str2id self str ?create? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_str2id" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pool_str2id" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_str2id" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = (bool)(val3);
  }
  result = (Id)Pool_str2id(arg1,(char const *)arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_Dep(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 = (bool) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  Dep *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::Pool_Dep self str ?create? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_Dep" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pool_Dep" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_Dep" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = (bool)(val3);
  }
  result = (Dep *)Pool_Dep(arg1,(char const *)arg2,arg3);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dep,0));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_id2str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_id2str self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_id2str" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_id2str" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (char *)Pool_id2str(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_dep2str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_dep2str self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_dep2str" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_dep2str" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (char *)Pool_dep2str(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_rel2id(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  Id arg3 ;
  int arg4 ;
  bool arg5 = (bool) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo|o:solv::Pool_rel2id self name evr flags ?create? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_rel2id" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_rel2id" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_rel2id" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Pool_rel2id" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  if (objc > 5) {
    ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Pool_rel2id" "', argument " "5"" of type '" "bool""'");
    } 
    arg5 = (bool)(val5);
  }
  result = (Id)Pool_rel2id(arg1,arg2,arg3,arg4,arg5);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_id2langid(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  char *arg3 = (char *) 0 ;
  bool arg4 = (bool) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo|o:solv::Pool_id2langid self id lang ?create? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_id2langid" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_id2langid" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pool_id2langid" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  if (objc > 4) {
    ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Pool_id2langid" "', argument " "4"" of type '" "bool""'");
    } 
    arg4 = (bool)(val4);
  }
  result = (Id)Pool_id2langid(arg1,arg2,(char const *)arg3,arg4);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_OK;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_setarch(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Pool_setarch self ?arch? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_setarch" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  if (objc > 2) {
    res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pool_setarch" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
  }
  Pool_setarch(arg1,(char const *)arg2);
  
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_add_repo(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Repo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_add_repo self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_add_repo" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pool_add_repo" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  result = (Repo *)Pool_add_repo(arg1,(char const *)arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo,0));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_lookup_str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  Id arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Pool_lookup_str self entry keyname ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_lookup_str" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_lookup_str" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_lookup_str" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  result = (char *)Pool_lookup_str(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_lookup_id(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  Id arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Pool_lookup_id self entry keyname ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_lookup_id" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_lookup_id" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_lookup_id" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  result = (Id)Pool_lookup_id(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_lookup_num(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  Id arg3 ;
  unsigned long long arg4 = (unsigned long long) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned long long val4 ;
  int ecode4 = 0 ;
  unsigned long long result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo|o:solv::Pool_lookup_num self entry keyname ?notfound? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_lookup_num" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_lookup_num" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_lookup_num" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  if (objc > 4) {
    ecode4 = SWIG_AsVal_unsigned_SS_long_SS_long SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Pool_lookup_num" "', argument " "4"" of type '" "unsigned long long""'");
    } 
    arg4 = (unsigned long long)(val4);
  }
  result = (unsigned long long)Pool_lookup_num(arg1,arg2,arg3,arg4);
  Tcl_SetObjResult(interp,SWIG_From_unsigned_SS_long_SS_long((unsigned long long)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_lookup_void(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  Id arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Pool_lookup_void self entry keyname ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_lookup_void" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_lookup_void" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_lookup_void" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  result = (bool)Pool_lookup_void(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_lookup_checksum(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  Id arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Chksum *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Pool_lookup_checksum self entry keyname ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_lookup_checksum" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_lookup_checksum" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_lookup_checksum" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  result = (Chksum *)Pool_lookup_checksum(arg1,arg2,arg3);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Chksum,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_Dataiterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  Dataiterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|oo:solv::Pool_Dataiterator self key ?match? ?flags? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_Dataiterator" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_Dataiterator" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  if (objc > 3) {
    res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pool_Dataiterator" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (objc > 4) {
    ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Pool_Dataiterator" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  result = (Dataiterator *)Pool_Dataiterator(arg1,arg2,(char const *)arg3,arg4);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dataiterator,0));
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_OK;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_Dataiterator_solvid(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  Id arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  Dataiterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo|oo:solv::Pool_Dataiterator_solvid self p key ?match? ?flags? ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_Dataiterator_solvid" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_Dataiterator_solvid" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_Dataiterator_solvid" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  if (objc > 4) {
    res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Pool_Dataiterator_solvid" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (objc > 5) {
    ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Pool_Dataiterator_solvid" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  result = (Dataiterator *)Pool_Dataiterator_solvid(arg1,arg2,arg3,(char const *)arg4,arg5);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dataiterator,0));
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return TCL_OK;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_solvid2str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_solvid2str self solvid ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_solvid2str" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_solvid2str" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (char *)Pool_solvid2str(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_addfileprovides(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_addfileprovides self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_addfileprovides" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  Pool_addfileprovides(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_addfileprovides_queue(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_addfileprovides_queue self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_addfileprovides_queue" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = Pool_addfileprovides_queue(arg1);
  {
    Tcl_Obj *objvx[(&result)->count];
    int i;
    
    for (i = 0; i < (&result)->count; i++) {
      objvx[i] = SWIG_From_int((&result)->elements[i]);
    }
    
    Tcl_SetObjResult(interp, Tcl_NewListObj((&result)->count, objvx));
    
    queue_free(&result);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_createwhatprovides(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_createwhatprovides self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_createwhatprovides" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  Pool_createwhatprovides(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_id2solvable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_id2solvable self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_id2solvable" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_id2solvable" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (XSolvable *)Pool_id2solvable(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_solvables_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool_solvable_iterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_solvables_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_solvables_get" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (Pool_solvable_iterator *)Pool_solvables_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool_solvable_iterator,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_solvables_iter(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool_solvable_iterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_solvables_iter self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_solvables_iter" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (Pool_solvable_iterator *)Pool_solvables_iter(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool_solvable_iterator,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_id2repo(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Repo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_id2repo self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_id2repo" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_id2repo" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (Repo *)Pool_id2repo(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_repos_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool_repo_iterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_repos_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_repos_get" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (Pool_repo_iterator *)Pool_repos_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool_repo_iterator,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_repos_iter(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool_repo_iterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_repos_iter self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_repos_iter" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (Pool_repo_iterator *)Pool_repos_iter(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool_repo_iterator,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_installed_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Repo *arg2 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_installed_set self installed ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_installed_set" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Repo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pool_installed_set" "', argument " "2"" of type '" "Repo *""'"); 
  }
  arg2 = (Repo *)(argp2);
  Pool_installed_set(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_installed_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Repo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_installed_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_installed_get" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (Repo *)Pool_installed_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_errstr_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_errstr_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_errstr_get" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (char *)Pool_errstr_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_matchprovidingids(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Pool_matchprovidingids self match flags ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_matchprovidingids" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pool_matchprovidingids" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_matchprovidingids" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = Pool_matchprovidingids(arg1,(char const *)arg2,arg3);
  {
    Tcl_Obj *objvx[(&result)->count];
    int i;
    
    for (i = 0; i < (&result)->count; i++) {
      objvx[i] = SWIG_From_int((&result)->elements[i]);
    }
    
    Tcl_SetObjResult(interp, Tcl_NewListObj((&result)->count, objvx));
    
    queue_free(&result);
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_Job(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  int arg2 ;
  Id arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Job *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Pool_Job self how what ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_Job" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_Job" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_Job" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  result = (Job *)Pool_Job(arg1,arg2,arg3);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Job,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_whatprovides(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  DepId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DepId val2 ;
  int ecode2 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_whatprovides self dep ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_whatprovides" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_whatprovides" "', argument " "2"" of type '" "DepId""'");
  } 
  arg2 = (DepId)(val2);
  result = Pool_whatprovides(arg1,arg2);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_towhatprovides(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Queue arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  {
    queue_init(&arg2);
  }
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_towhatprovides self q ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_towhatprovides" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  {
    /* Check if is a list */
    int retval = TCL_OK;
    int size = 0;
    int i = 0;
    
    if (TCL_OK != (retval = Tcl_ListObjLength(interp, objv[2], &size))) {
      Tcl_SetObjResult(interp, Tcl_NewStringObj("argument is not a list", -1));
      return retval;
    }
    
    queue_init(&arg2);
    
    for (i = 0; i < size; i++) {
      Tcl_Obj *o = NULL;
      int v;
      
      if (TCL_OK != (retval = Tcl_ListObjIndex(interp, objv[2], i, &o))) {
        queue_free(&arg2);
        Tcl_SetObjResult(interp, Tcl_NewStringObj("failed to retrieve a list member", -1));
        return retval;
      }
      
      int e = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(o, &v);
      if (!SWIG_IsOK(e)) {
        queue_free(&arg2);
        SWIG_exception_fail(SWIG_ArgError(e), "list must contain only integers");
        return TCL_ERROR;
      }
      
      queue_push(&arg2, v);
    }
  }
  result = (Id)Pool_towhatprovides(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  {
    queue_free(&arg2);
  }
  return TCL_OK;
fail:
  {
    queue_free(&arg2);
  }
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_whatmatchesdep(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Id arg2 ;
  DepId arg3 ;
  Id arg4 = (Id) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  DepId val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo|o:solv::Pool_whatmatchesdep self keyname dep ?marker? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_whatmatchesdep" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_whatmatchesdep" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_whatmatchesdep" "', argument " "3"" of type '" "DepId""'");
  } 
  arg3 = (DepId)(val3);
  if (objc > 4) {
    ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Pool_whatmatchesdep" "', argument " "4"" of type '" "Id""'");
    } 
    arg4 = (Id)(val4);
  }
  result = Pool_whatmatchesdep(arg1,arg2,arg3,arg4);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_isknownarch(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  DepId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  DepId val2 ;
  int ecode2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_isknownarch self id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_isknownarch" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  ecode2 = SWIG_AsValDepId SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_isknownarch" "', argument " "2"" of type '" "DepId""'");
  } 
  arg2 = (DepId)(val2);
  result = (bool)Pool_isknownarch(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_Solver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Solver *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_Solver self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_Solver" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (Solver *)Pool_Solver(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solver,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_Selection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Selection *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_Selection self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_Selection" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = (Selection *)Pool_Selection(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Selection,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_Selection_all(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Selection *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Pool_Selection_all self ?setflags? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_Selection_all" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pool_Selection_all" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (Selection *)Pool_Selection_all(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Selection,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_select(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Selection *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Pool_select self name flags ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_select" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pool_select" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pool_select" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (Selection *)Pool_select(arg1,(char const *)arg2,arg3);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Selection,0));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_setpooljobs_helper(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  Queue arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  {
    queue_init(&arg2);
  }
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Pool_setpooljobs_helper self jobs ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_setpooljobs_helper" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  {
    /* Check if is a list */
    int retval = TCL_OK;
    int size = 0;
    int i = 0;
    
    if (TCL_OK != (retval = Tcl_ListObjLength(interp, objv[2], &size))) {
      Tcl_SetObjResult(interp, Tcl_NewStringObj("argument is not a list", -1));
      return retval;
    }
    
    queue_init(&arg2);
    
    for (i = 0; i < size; i++) {
      Tcl_Obj *o = NULL;
      int v;
      
      if (TCL_OK != (retval = Tcl_ListObjIndex(interp, objv[2], i, &o))) {
        queue_free(&arg2);
        Tcl_SetObjResult(interp, Tcl_NewStringObj("failed to retrieve a list member", -1));
        return retval;
      }
      
      int e = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(o, &v);
      if (!SWIG_IsOK(e)) {
        queue_free(&arg2);
        SWIG_exception_fail(SWIG_ArgError(e), "list must contain only integers");
        return TCL_ERROR;
      }
      
      queue_push(&arg2, v);
    }
  }
  Pool_setpooljobs_helper(arg1,arg2);
  
  {
    queue_free(&arg2);
  }
  return TCL_OK;
fail:
  {
    queue_free(&arg2);
  }
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pool_getpooljobs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pool *arg1 = (Pool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Pool_getpooljobs self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pool_getpooljobs" "', argument " "1"" of type '" "Pool *""'"); 
  }
  arg1 = (Pool *)(argp1);
  result = Pool_getpooljobs(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 2;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 2) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      Job * result = new_Job(arg1, id, idp[1]);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Job,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Pool(void *obj) {
Pool *arg1 = (Pool *) obj;
delete_Pool(arg1);
}
static swig_method swig_Pool_methods[] = {
    {"set_debuglevel", _wrap_Pool_set_debuglevel}, 
    {"set_flag", _wrap_Pool_set_flag}, 
    {"get_flag", _wrap_Pool_get_flag}, 
    {"set_rootdir", _wrap_Pool_set_rootdir}, 
    {"get_rootdir", _wrap_Pool_get_rootdir}, 
    {"set_loadcallback", _wrap_Pool_set_loadcallback}, 
    {"free", _wrap_Pool_free}, 
    {"disown", _wrap_Pool_disown}, 
    {"str2id", _wrap_Pool_str2id}, 
    {"Dep", _wrap_Pool_Dep}, 
    {"id2str", _wrap_Pool_id2str}, 
    {"dep2str", _wrap_Pool_dep2str}, 
    {"rel2id", _wrap_Pool_rel2id}, 
    {"id2langid", _wrap_Pool_id2langid}, 
    {"setarch", _wrap_Pool_setarch}, 
    {"add_repo", _wrap_Pool_add_repo}, 
    {"lookup_str", _wrap_Pool_lookup_str}, 
    {"lookup_id", _wrap_Pool_lookup_id}, 
    {"lookup_num", _wrap_Pool_lookup_num}, 
    {"lookup_void", _wrap_Pool_lookup_void}, 
    {"lookup_checksum", _wrap_Pool_lookup_checksum}, 
    {"Dataiterator", _wrap_Pool_Dataiterator}, 
    {"Dataiterator_solvid", _wrap_Pool_Dataiterator_solvid}, 
    {"solvid2str", _wrap_Pool_solvid2str}, 
    {"addfileprovides", _wrap_Pool_addfileprovides}, 
    {"addfileprovides_queue", _wrap_Pool_addfileprovides_queue}, 
    {"createwhatprovides", _wrap_Pool_createwhatprovides}, 
    {"id2solvable", _wrap_Pool_id2solvable}, 
    {"solvables_iter", _wrap_Pool_solvables_iter}, 
    {"id2repo", _wrap_Pool_id2repo}, 
    {"repos_iter", _wrap_Pool_repos_iter}, 
    {"matchprovidingids", _wrap_Pool_matchprovidingids}, 
    {"Job", _wrap_Pool_Job}, 
    {"whatprovides", _wrap_Pool_whatprovides}, 
    {"towhatprovides", _wrap_Pool_towhatprovides}, 
    {"whatmatchesdep", _wrap_Pool_whatmatchesdep}, 
    {"isknownarch", _wrap_Pool_isknownarch}, 
    {"Solver", _wrap_Pool_Solver}, 
    {"Selection", _wrap_Pool_Selection}, 
    {"Selection_all", _wrap_Pool_Selection_all}, 
    {"select", _wrap_Pool_select}, 
    {"setpooljobs_helper", _wrap_Pool_setpooljobs_helper}, 
    {"getpooljobs", _wrap_Pool_getpooljobs}, 
    {0,0}
};
static swig_attribute swig_Pool_attributes[] = {
    { "-appdata",_wrap_Pool_appdata_get, _wrap_Pool_appdata_set},
    { "-solvables",_wrap_Pool_solvables_get, 0 },
    { "-repos",_wrap_Pool_repos_get, 0 },
    { "-installed",_wrap_Pool_installed_get, _wrap_Pool_installed_set},
    { "-errstr",_wrap_Pool_errstr_get, 0 },
    {0,0,0}
};
static swig_class *swig_Pool_bases[] = {0};
static const char * swig_Pool_base_names[] = {0};
static swig_class _wrap_class_Pool = { "Pool", &SWIGTYPE_p_Pool,_wrap_new_Pool, swig_delete_Pool, swig_Pool_methods, swig_Pool_attributes, swig_Pool_bases,swig_Pool_base_names, &swig_module };
SWIGINTERN int
_wrap_Repo_pool_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_pool_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_pool_get" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (Pool *)(Pool *) ((arg1)->pool);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_name_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_name_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_name_get" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (char *)(char *) ((arg1)->name);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_priority_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Repo_priority_set self priority ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_priority_set" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_priority_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->priority = arg2;
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_priority_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_priority_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_priority_get" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (int) ((arg1)->priority);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_subpriority_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Repo_subpriority_set self subpriority ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_subpriority_set" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_subpriority_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->subpriority = arg2;
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_subpriority_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_subpriority_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_subpriority_get" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (int) ((arg1)->subpriority);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_nsolvables_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_nsolvables_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_nsolvables_get" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (int)(int) ((arg1)->nsolvables);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_appdata_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  AppObjectPtr arg2 = (AppObjectPtr) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Repo_appdata_set self appdata ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_appdata_set" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TclObj, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Repo_appdata_set" "', argument " "2"" of type '" "AppObjectPtr""'"); 
  }
  arg2 = (AppObjectPtr)(argp2);
  if (arg1) (arg1)->appdata = arg2;
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_appdata_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  AppObjectPtr result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_appdata_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_appdata_get" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (AppObjectPtr) ((arg1)->appdata);
  {
    Tcl_SetObjResult(interp, result ? result : Tcl_NewObj());
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_free(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  bool arg2 = (bool) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Repo_free self ?reuseids? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_free" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_free" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = (bool)(val2);
  }
  Repo_free(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_empty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  bool arg2 = (bool) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Repo_empty self ?reuseids? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_empty" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_empty" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = (bool)(val2);
  }
  Repo_empty(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_isempty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_isempty self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_isempty" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (bool)Repo_isempty(arg1);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_add_solv__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::Repo_add_solv self name ?flags? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_add_solv" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Repo_add_solv" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Repo_add_solv" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  result = (bool)Repo_add_solv__SWIG_0(arg1,(char const *)arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_add_solv__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FILE *val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::Repo_add_solv self fp ?flags? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_add_solv" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  ecode2 = SWIG_AsValSolvFpPtr SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_add_solv" "', argument " "2"" of type '" "FILE *""'");
  } 
  arg2 = (FILE *)(val2);
  if (objc > 3) {
    ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Repo_add_solv" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  result = (bool)Repo_add_solv__SWIG_1(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_add_solv(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Tcl_Obj *CONST *argv = objv+1;
  int argc = objc-1;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Repo, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsValSolvFpPtr SWIG_TCL_CALL_ARGS_2(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        if (argc <= 2) {
          return _wrap_Repo_add_solv__SWIG_1(clientData, interp, objc, argv - 1);
        }
        {
          int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Repo_add_solv__SWIG_1(clientData, interp, objc, argv - 1);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Repo, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        if (argc <= 2) {
          return _wrap_Repo_add_solv__SWIG_0(clientData, interp, objc, argv - 1);
        }
        {
          int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_Repo_add_solv__SWIG_0(clientData, interp, objc, argv - 1);
        }
      }
    }
  }
  
  Tcl_SetResult(interp,(char *) "Wrong number or type of arguments for overloaded function 'Repo_add_solv'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Repo::add_solv(char const *,int)\n"
    "    Repo::add_solv(FILE *,int)\n", TCL_STATIC);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_add_solvable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_add_solvable self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_add_solvable" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (XSolvable *)Repo_add_solvable(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_internalize(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_internalize self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_internalize" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  Repo_internalize(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_write(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FILE *val2 ;
  int ecode2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Repo_write self fp ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_write" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  ecode2 = SWIG_AsValSolvFpPtr SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_write" "', argument " "2"" of type '" "FILE *""'");
  } 
  arg2 = (FILE *)(val2);
  result = (bool)Repo_write(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_write_first_repodata(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FILE *val2 ;
  int ecode2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Repo_write_first_repodata self fp ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_write_first_repodata" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  ecode2 = SWIG_AsValSolvFpPtr SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_write_first_repodata" "', argument " "2"" of type '" "FILE *""'");
  } 
  arg2 = (FILE *)(val2);
  result = (bool)Repo_write_first_repodata(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_Dataiterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  Id arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  Dataiterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|oo:solv::Repo_Dataiterator self key ?match? ?flags? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_Dataiterator" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_Dataiterator" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  if (objc > 3) {
    res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Repo_Dataiterator" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (objc > 4) {
    ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Repo_Dataiterator" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  result = (Dataiterator *)Repo_Dataiterator(arg1,arg2,(char const *)arg3,arg4);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dataiterator,0));
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_OK;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_Dataiterator_meta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  Id arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  Dataiterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|oo:solv::Repo_Dataiterator_meta self key ?match? ?flags? ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_Dataiterator_meta" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_Dataiterator_meta" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  if (objc > 3) {
    res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Repo_Dataiterator_meta" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (objc > 4) {
    ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Repo_Dataiterator_meta" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  result = (Dataiterator *)Repo_Dataiterator_meta(arg1,arg2,(char const *)arg3,arg4);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dataiterator,0));
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_OK;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_id_get" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (Id)Repo_id_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_solvables_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Repo_solvable_iterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_solvables_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_solvables_get" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (Repo_solvable_iterator *)Repo_solvables_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo_solvable_iterator,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_meta_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Datapos *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_meta_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_meta_get" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (Datapos *)Repo_meta_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Datapos,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_solvables_iter(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Repo_solvable_iterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_solvables_iter self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_solvables_iter" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (Repo_solvable_iterator *)Repo_solvables_iter(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Repo_solvable_iterator,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_add_repodata(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  XRepodata *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Repo_add_repodata self ?flags? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_add_repodata" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_add_repodata" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (XRepodata *)Repo_add_repodata(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XRepodata,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_create_stubs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_create_stubs self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_create_stubs" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  Repo_create_stubs(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_iscontiguous(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_iscontiguous self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_iscontiguous" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (bool)Repo_iscontiguous(arg1);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_first_repodata(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XRepodata *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo_first_repodata self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_first_repodata" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (XRepodata *)Repo_first_repodata(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XRepodata,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo_Selection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Selection *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Repo_Selection self ?setflags? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo_Selection" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Repo_Selection" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (Selection *)Repo_Selection(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Selection,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo___eq__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  Repo *arg2 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Repo___eq__ self repo ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo___eq__" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Repo___eq__" "', argument " "2"" of type '" "Repo *""'"); 
  }
  arg2 = (Repo *)(argp2);
  result = (bool)Repo___eq__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo___ne__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  Repo *arg2 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Repo___ne__ self repo ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo___ne__" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Repo___ne__" "', argument " "2"" of type '" "Repo *""'"); 
  }
  arg2 = (Repo *)(argp2);
  result = (bool)Repo___ne__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo___str__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo___str__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo___str__" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (char *)Repo___str__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  free((char*)result);
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Repo___repr__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Repo *arg1 = (Repo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Repo___repr__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Repo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Repo___repr__" "', argument " "1"" of type '" "Repo *""'"); 
  }
  arg1 = (Repo *)(argp1);
  result = (char *)Repo___repr__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  free((char*)result);
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Repo_methods[] = {
    {"free", _wrap_Repo_free}, 
    {"empty", _wrap_Repo_empty}, 
    {"isempty", _wrap_Repo_isempty}, 
    {"add_solv", _wrap_Repo_add_solv}, 
    {"add_solvable", _wrap_Repo_add_solvable}, 
    {"internalize", _wrap_Repo_internalize}, 
    {"write", _wrap_Repo_write}, 
    {"write_first_repodata", _wrap_Repo_write_first_repodata}, 
    {"Dataiterator", _wrap_Repo_Dataiterator}, 
    {"Dataiterator_meta", _wrap_Repo_Dataiterator_meta}, 
    {"solvables_iter", _wrap_Repo_solvables_iter}, 
    {"add_repodata", _wrap_Repo_add_repodata}, 
    {"create_stubs", _wrap_Repo_create_stubs}, 
    {"iscontiguous", _wrap_Repo_iscontiguous}, 
    {"first_repodata", _wrap_Repo_first_repodata}, 
    {"Selection", _wrap_Repo_Selection}, 
    {"__eq__", _wrap_Repo___eq__}, 
    {"__ne__", _wrap_Repo___ne__}, 
    {"__str__", _wrap_Repo___str__}, 
    {"__repr__", _wrap_Repo___repr__}, 
    {0,0}
};
static swig_attribute swig_Repo_attributes[] = {
    { "-pool",_wrap_Repo_pool_get, 0 },
    { "-name",_wrap_Repo_name_get, 0 },
    { "-priority",_wrap_Repo_priority_get, _wrap_Repo_priority_set},
    { "-subpriority",_wrap_Repo_subpriority_get, _wrap_Repo_subpriority_set},
    { "-nsolvables",_wrap_Repo_nsolvables_get, 0 },
    { "-appdata",_wrap_Repo_appdata_get, _wrap_Repo_appdata_set},
    { "-id",_wrap_Repo_id_get, 0 },
    { "-solvables",_wrap_Repo_solvables_get, 0 },
    { "-meta",_wrap_Repo_meta_get, 0 },
    {0,0,0}
};
static swig_class *swig_Repo_bases[] = {0};
static const char * swig_Repo_base_names[] = {0};
static swig_class _wrap_class_Repo = { "Repo", &SWIGTYPE_p_Repo,0,0, swig_Repo_methods, swig_Repo_attributes, swig_Repo_bases,swig_Repo_base_names, &swig_module };
SWIGINTERN int
_wrap_Solver_pool_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solver_pool_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solver_pool_get" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  result = (Pool *)(Pool *) ((arg1)->pool);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Solver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Solver self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Solver" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  delete_Solver(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solver_set_flag(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Solver_set_flag self flag value ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solver_set_flag" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Solver_set_flag" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Solver_set_flag" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (int)Solver_set_flag(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solver_get_flag(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Solver_get_flag self flag ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solver_get_flag" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Solver_get_flag" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = (int)Solver_get_flag(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solver_solve_helper(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  Queue arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  {
    queue_init(&arg2);
  }
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Solver_solve_helper self jobs ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solver_solve_helper" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  {
    /* Check if is a list */
    int retval = TCL_OK;
    int size = 0;
    int i = 0;
    
    if (TCL_OK != (retval = Tcl_ListObjLength(interp, objv[2], &size))) {
      Tcl_SetObjResult(interp, Tcl_NewStringObj("argument is not a list", -1));
      return retval;
    }
    
    queue_init(&arg2);
    
    for (i = 0; i < size; i++) {
      Tcl_Obj *o = NULL;
      int v;
      
      if (TCL_OK != (retval = Tcl_ListObjIndex(interp, objv[2], i, &o))) {
        queue_free(&arg2);
        Tcl_SetObjResult(interp, Tcl_NewStringObj("failed to retrieve a list member", -1));
        return retval;
      }
      
      int e = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(o, &v);
      if (!SWIG_IsOK(e)) {
        queue_free(&arg2);
        SWIG_exception_fail(SWIG_ArgError(e), "list must contain only integers");
        return TCL_ERROR;
      }
      
      queue_push(&arg2, v);
    }
  }
  result = Solver_solve_helper(arg1,arg2);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      Problem * result = new_Problem(arg1, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Problem,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  {
    queue_free(&arg2);
  }
  return TCL_OK;
fail:
  {
    queue_free(&arg2);
  }
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solver_transaction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Transaction *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solver_transaction self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solver_transaction" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  result = (Transaction *)Solver_transaction(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Transaction,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solver_describe_decision(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  XSolvable *arg2 = (XSolvable *) 0 ;
  XRule **arg3 = (XRule **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  XRule *temp3 ;
  int result;
  
  arg3 = &temp3;
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Solver_describe_decision self s ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solver_describe_decision" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Solver_describe_decision" "', argument " "2"" of type '" "XSolvable *""'"); 
  }
  arg2 = (XSolvable *)(argp2);
  result = (int)Solver_describe_decision(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),SWIG_NewPointerObj((void*)(*arg3), SWIGTYPE_p_XRule, SWIG_POINTER_OWN |  0 ));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solver_alternatives_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solver_alternatives_count self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solver_alternatives_count" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  result = (int)Solver_alternatives_count(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solver_alternative(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Alternative *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Solver_alternative self aid ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solver_alternative" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Solver_alternative" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (Alternative *)Solver_alternative(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Alternative,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solver_all_alternatives(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solver_all_alternatives self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solver_all_alternatives" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  result = Solver_all_alternatives(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      Alternative * result = Solver_alternative(arg1, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Alternative,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Solver(void *obj) {
Solver *arg1 = (Solver *) obj;
delete_Solver(arg1);
}
static swig_method swig_Solver_methods[] = {
    {"set_flag", _wrap_Solver_set_flag}, 
    {"get_flag", _wrap_Solver_get_flag}, 
    {"solve_helper", _wrap_Solver_solve_helper}, 
    {"transaction", _wrap_Solver_transaction}, 
    {"describe_decision", _wrap_Solver_describe_decision}, 
    {"alternatives_count", _wrap_Solver_alternatives_count}, 
    {"alternative", _wrap_Solver_alternative}, 
    {"all_alternatives", _wrap_Solver_all_alternatives}, 
    {0,0}
};
static swig_attribute swig_Solver_attributes[] = {
    { "-pool",_wrap_Solver_pool_get, 0 },
    {0,0,0}
};
static swig_class *swig_Solver_bases[] = {0};
static const char * swig_Solver_base_names[] = {0};
static swig_class _wrap_class_Solver = { "Solver", &SWIGTYPE_p_Solver,0, swig_delete_Solver, swig_Solver_methods, swig_Solver_attributes, swig_Solver_bases,swig_Solver_base_names, &swig_module };
SWIGINTERN int
_wrap_new_Chksum__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Id arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Chksum *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::new_Chksum type ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Chksum" "', argument " "1"" of type '" "Id""'");
  } 
  arg1 = (Id)(val1);
  result = (Chksum *)new_Chksum__SWIG_0(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Chksum,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_Chksum__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Id arg1 ;
  char *arg2 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Chksum *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::new_Chksum type hex ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Chksum" "', argument " "1"" of type '" "Id""'");
  } 
  arg1 = (Id)(val1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Chksum" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  result = (Chksum *)new_Chksum__SWIG_1(arg1,(char const *)arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Chksum,0));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_Chksum(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Tcl_Obj *CONST *argv = objv+1;
  int argc = objc-1;
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_Chksum__SWIG_0(clientData, interp, objc, argv - 1);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_Chksum__SWIG_1(clientData, interp, objc, argv - 1);
      }
    }
  }
  
  Tcl_SetResult(interp,(char *) "Wrong number or type of arguments for overloaded function 'new_Chksum'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Chksum::Chksum(Id)\n"
    "    Chksum::Chksum(Id,char const *)\n", TCL_STATIC);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Chksum(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Chksum self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Chksum" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  delete_Chksum(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum_type_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Chksum_type_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum_type_get" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  result = (Id)Chksum_type_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum_add(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  size_t size2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Chksum_add self str ?len? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum_add" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, &size2, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Chksum_add" "', argument " "2"" of type '" "const char *""'");
    
  }
  arg2 = (unsigned char *)buf2;
  arg3 = size2;
  Chksum_add(arg1,(unsigned char const *)arg2,arg3);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum_add_fp(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FILE *val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Chksum_add_fp self fp ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum_add_fp" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  ecode2 = SWIG_AsValSolvFpPtr SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Chksum_add_fp" "', argument " "2"" of type '" "FILE *""'");
  } 
  arg2 = (FILE *)(val2);
  Chksum_add_fp(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum_add_fd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Chksum_add_fd self fd ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum_add_fd" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Chksum_add_fd" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  Chksum_add_fd(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum_add_stat(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Chksum_add_stat self filename ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum_add_stat" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Chksum_add_stat" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  Chksum_add_stat(arg1,(char const *)arg2);
  
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum_add_fstat(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Chksum_add_fstat self fd ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum_add_fstat" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Chksum_add_fstat" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  Chksum_add_fstat(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum_raw(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  BinaryBlob result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Chksum_raw self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum_raw" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  result = Chksum_raw(arg1);
  Tcl_SetObjResult(interp, SWIG_FromCharPtrAndSize((&result)->data, (&result)->len));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum_hex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Chksum_hex self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum_hex" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  result = (char *)Chksum_hex(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  free((char*)result);
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum_typestr(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Chksum_typestr self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum_typestr" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  result = (char *)Chksum_typestr(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum___eq__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  Chksum *arg2 = (Chksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Chksum___eq__ self chk ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum___eq__" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Chksum___eq__" "', argument " "2"" of type '" "Chksum *""'"); 
  }
  arg2 = (Chksum *)(argp2);
  result = (bool)Chksum___eq__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum___ne__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  Chksum *arg2 = (Chksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Chksum___ne__ self chk ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum___ne__" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Chksum___ne__" "', argument " "2"" of type '" "Chksum *""'"); 
  }
  arg2 = (Chksum *)(argp2);
  result = (bool)Chksum___ne__(arg1,arg2);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum___str__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Chksum___str__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum___str__" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  result = (char *)Chksum___str__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  free((char*)result);
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Chksum___repr__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Chksum *arg1 = (Chksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Chksum___repr__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Chksum, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Chksum___repr__" "', argument " "1"" of type '" "Chksum *""'"); 
  }
  arg1 = (Chksum *)(argp1);
  result = (char *)Chksum___repr__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  free((char*)result);
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Chksum(void *obj) {
Chksum *arg1 = (Chksum *) obj;
delete_Chksum(arg1);
}
static swig_method swig_Chksum_methods[] = {
    {"add", _wrap_Chksum_add}, 
    {"add_fp", _wrap_Chksum_add_fp}, 
    {"add_fd", _wrap_Chksum_add_fd}, 
    {"add_stat", _wrap_Chksum_add_stat}, 
    {"add_fstat", _wrap_Chksum_add_fstat}, 
    {"raw", _wrap_Chksum_raw}, 
    {"hex", _wrap_Chksum_hex}, 
    {"typestr", _wrap_Chksum_typestr}, 
    {"__eq__", _wrap_Chksum___eq__}, 
    {"__ne__", _wrap_Chksum___ne__}, 
    {"__str__", _wrap_Chksum___str__}, 
    {"__repr__", _wrap_Chksum___repr__}, 
    {0,0}
};
static swig_attribute swig_Chksum_attributes[] = {
    { "-type",_wrap_Chksum_type_get, 0 },
    {0,0,0}
};
static swig_class *swig_Chksum_bases[] = {0};
static const char * swig_Chksum_base_names[] = {0};
static swig_class _wrap_class_Chksum = { "Chksum", &SWIGTYPE_p_Chksum,_wrap_new_Chksum, swig_delete_Chksum, swig_Chksum_methods, swig_Chksum_attributes, swig_Chksum_bases,swig_Chksum_base_names, &swig_module };
SWIGINTERN int
_wrap_delete_SolvFp(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SolvFp *arg1 = (SolvFp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_SolvFp self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_SolvFp, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SolvFp" "', argument " "1"" of type '" "SolvFp *""'"); 
  }
  arg1 = (SolvFp *)(argp1);
  delete_SolvFp(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_SolvFp_fileno(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SolvFp *arg1 = (SolvFp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::SolvFp_fileno self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_SolvFp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolvFp_fileno" "', argument " "1"" of type '" "SolvFp *""'"); 
  }
  arg1 = (SolvFp *)(argp1);
  result = (int)SolvFp_fileno(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_SolvFp_dup(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SolvFp *arg1 = (SolvFp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::SolvFp_dup self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_SolvFp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolvFp_dup" "', argument " "1"" of type '" "SolvFp *""'"); 
  }
  arg1 = (SolvFp *)(argp1);
  result = (int)SolvFp_dup(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_SolvFp_flush(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SolvFp *arg1 = (SolvFp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::SolvFp_flush self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_SolvFp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolvFp_flush" "', argument " "1"" of type '" "SolvFp *""'"); 
  }
  arg1 = (SolvFp *)(argp1);
  result = (bool)SolvFp_flush(arg1);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_SolvFp_close(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SolvFp *arg1 = (SolvFp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::SolvFp_close self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_SolvFp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolvFp_close" "', argument " "1"" of type '" "SolvFp *""'"); 
  }
  arg1 = (SolvFp *)(argp1);
  result = (bool)SolvFp_close(arg1);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_SolvFp(void *obj) {
SolvFp *arg1 = (SolvFp *) obj;
delete_SolvFp(arg1);
}
static swig_method swig_SolvFp_methods[] = {
    {"fileno", _wrap_SolvFp_fileno}, 
    {"dup", _wrap_SolvFp_dup}, 
    {"flush", _wrap_SolvFp_flush}, 
    {"close", _wrap_SolvFp_close}, 
    {0,0}
};
static swig_attribute swig_SolvFp_attributes[] = {
    {0,0,0}
};
static swig_class *swig_SolvFp_bases[] = {0};
static const char * swig_SolvFp_base_names[] = {0};
static swig_class _wrap_class_SolvFp = { "SolvFp", &SWIGTYPE_p_SolvFp,0, swig_delete_SolvFp, swig_SolvFp_methods, swig_SolvFp_attributes, swig_SolvFp_bases,swig_SolvFp_base_names, &swig_module };
SWIGINTERN int
_wrap_xfopen(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  SolvFp *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::xfopen fn ?mode? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "xfopen" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  if (objc > 2) {
    res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "xfopen" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
  }
  result = (SolvFp *)solvfp_xfopen((char const *)arg1,(char const *)arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_SolvFp,0));
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_xfopen_fd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  SolvFp *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo|o:solv::xfopen_fd fn fd ?mode? ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "xfopen_fd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "xfopen_fd" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (objc > 3) {
    res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "xfopen_fd" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  result = (SolvFp *)solvfp_xfopen_fd((char const *)arg1,arg2,(char const *)arg3);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_SolvFp,0));
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Problem_solv_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Problem *arg1 = (Problem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Solver *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Problem_solv_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Problem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Problem_solv_get" "', argument " "1"" of type '" "Problem *""'"); 
  }
  arg1 = (Problem *)(argp1);
  result = (Solver *)(Solver *) ((arg1)->solv);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solver,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Problem_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Problem *arg1 = (Problem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Problem_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Problem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Problem_id_get" "', argument " "1"" of type '" "Problem *""'"); 
  }
  arg1 = (Problem *)(argp1);
  result = (Id)(Id) ((arg1)->id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_Problem(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Problem *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::new_Problem solv id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Problem" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Problem" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (Problem *)new_Problem(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Problem,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Problem_findproblemrule(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Problem *arg1 = (Problem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XRule *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Problem_findproblemrule self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Problem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Problem_findproblemrule" "', argument " "1"" of type '" "Problem *""'"); 
  }
  arg1 = (Problem *)(argp1);
  result = (XRule *)Problem_findproblemrule(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XRule,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Problem_findallproblemrules(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Problem *arg1 = (Problem *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Problem_findallproblemrules self ?unfiltered? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Problem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Problem_findallproblemrules" "', argument " "1"" of type '" "Problem *""'"); 
  }
  arg1 = (Problem *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Problem_findallproblemrules" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = Problem_findallproblemrules(arg1,arg2);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XRule * result = new_XRule(arg1->solv, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XRule,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Problem_solution_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Problem *arg1 = (Problem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Problem_solution_count self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Problem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Problem_solution_count" "', argument " "1"" of type '" "Problem *""'"); 
  }
  arg1 = (Problem *)(argp1);
  result = (int)Problem_solution_count(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Problem_solutions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Problem *arg1 = (Problem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Problem_solutions self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Problem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Problem_solutions" "', argument " "1"" of type '" "Problem *""'"); 
  }
  arg1 = (Problem *)(argp1);
  result = Problem_solutions(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      Solution * result = new_Solution(arg1, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solution,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Problem___str__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Problem *arg1 = (Problem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Problem___str__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Problem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Problem___str__" "', argument " "1"" of type '" "Problem *""'"); 
  }
  arg1 = (Problem *)(argp1);
  result = (char *)Problem___str__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Problem(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Problem *arg1 = (Problem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Problem self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Problem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Problem" "', argument " "1"" of type '" "Problem *""'"); 
  }
  arg1 = (Problem *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Problem(void *obj) {
Problem *arg1 = (Problem *) obj;
free((char *) arg1);
}
static swig_method swig_Problem_methods[] = {
    {"findproblemrule", _wrap_Problem_findproblemrule}, 
    {"findallproblemrules", _wrap_Problem_findallproblemrules}, 
    {"solution_count", _wrap_Problem_solution_count}, 
    {"solutions", _wrap_Problem_solutions}, 
    {"__str__", _wrap_Problem___str__}, 
    {0,0}
};
static swig_attribute swig_Problem_attributes[] = {
    { "-solv",_wrap_Problem_solv_get, 0 },
    { "-id",_wrap_Problem_id_get, 0 },
    {0,0,0}
};
static swig_class *swig_Problem_bases[] = {0};
static const char * swig_Problem_base_names[] = {0};
static swig_class _wrap_class_Problem = { "Problem", &SWIGTYPE_p_Problem,_wrap_new_Problem, swig_delete_Problem, swig_Problem_methods, swig_Problem_attributes, swig_Problem_bases,swig_Problem_base_names, &swig_module };
SWIGINTERN int
_wrap_Solution_solv_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solution *arg1 = (Solution *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Solver *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solution_solv_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solution, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solution_solv_get" "', argument " "1"" of type '" "Solution *""'"); 
  }
  arg1 = (Solution *)(argp1);
  result = (Solver *)(Solver *) ((arg1)->solv);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solver,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solution_problemid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solution *arg1 = (Solution *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solution_problemid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solution, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solution_problemid_get" "', argument " "1"" of type '" "Solution *""'"); 
  }
  arg1 = (Solution *)(argp1);
  result = (Id)(Id) ((arg1)->problemid);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solution_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solution *arg1 = (Solution *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solution_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solution, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solution_id_get" "', argument " "1"" of type '" "Solution *""'"); 
  }
  arg1 = (Solution *)(argp1);
  result = (Id)(Id) ((arg1)->id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_Solution(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Problem *arg1 = (Problem *) 0 ;
  Id arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Solution *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::new_Solution p id ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Problem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Solution" "', argument " "1"" of type '" "Problem *""'"); 
  }
  arg1 = (Problem *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Solution" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  result = (Solution *)new_Solution(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solution,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solution_element_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solution *arg1 = (Solution *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solution_element_count self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solution, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solution_element_count" "', argument " "1"" of type '" "Solution *""'"); 
  }
  arg1 = (Solution *)(argp1);
  result = (int)Solution_element_count(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solution_elements(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solution *arg1 = (Solution *) 0 ;
  bool arg2 = (bool) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Solution_elements self ?expandreplaces? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solution, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solution_elements" "', argument " "1"" of type '" "Solution *""'"); 
  }
  arg1 = (Solution *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Solution_elements" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = (bool)(val2);
  }
  result = Solution_elements(arg1,arg2);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 4;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 4) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      Solutionelement * result = new_Solutionelement(arg1->solv, arg1->problemid, arg1->id, id, idp[1], idp[2], idp[3]);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solutionelement,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Solution(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solution *arg1 = (Solution *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Solution self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solution, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Solution" "', argument " "1"" of type '" "Solution *""'"); 
  }
  arg1 = (Solution *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Solution(void *obj) {
Solution *arg1 = (Solution *) obj;
free((char *) arg1);
}
static swig_method swig_Solution_methods[] = {
    {"element_count", _wrap_Solution_element_count}, 
    {"elements", _wrap_Solution_elements}, 
    {0,0}
};
static swig_attribute swig_Solution_attributes[] = {
    { "-solv",_wrap_Solution_solv_get, 0 },
    { "-problemid",_wrap_Solution_problemid_get, 0 },
    { "-id",_wrap_Solution_id_get, 0 },
    {0,0,0}
};
static swig_class *swig_Solution_bases[] = {0};
static const char * swig_Solution_base_names[] = {0};
static swig_class _wrap_class_Solution = { "Solution", &SWIGTYPE_p_Solution,_wrap_new_Solution, swig_delete_Solution, swig_Solution_methods, swig_Solution_attributes, swig_Solution_bases,swig_Solution_base_names, &swig_module };
SWIGINTERN int
_wrap_Solutionelement_solv_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Solver *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_solv_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_solv_get" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (Solver *)(Solver *) ((arg1)->solv);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solver,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_problemid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_problemid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_problemid_get" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (Id)(Id) ((arg1)->problemid);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_solutionid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_solutionid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_solutionid_get" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (Id)(Id) ((arg1)->solutionid);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_id_get" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (Id)(Id) ((arg1)->id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_type_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_type_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_type_get" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (Id)(Id) ((arg1)->type);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_Solutionelement(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solver *arg1 = (Solver *) 0 ;
  Id arg2 ;
  Id arg3 ;
  Id arg4 ;
  Id arg5 ;
  Id arg6 ;
  Id arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  Solutionelement *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:solv::new_Solutionelement solv problemid solutionid id type p rp ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solver, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Solutionelement" "', argument " "1"" of type '" "Solver *""'"); 
  }
  arg1 = (Solver *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Solutionelement" "', argument " "2"" of type '" "Id""'");
  } 
  arg2 = (Id)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Solutionelement" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Solutionelement" "', argument " "4"" of type '" "Id""'");
  } 
  arg4 = (Id)(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Solutionelement" "', argument " "5"" of type '" "Id""'");
  } 
  arg5 = (Id)(val5);
  ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Solutionelement" "', argument " "6"" of type '" "Id""'");
  } 
  arg6 = (Id)(val6);
  ecode7 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Solutionelement" "', argument " "7"" of type '" "Id""'");
  } 
  arg7 = (Id)(val7);
  result = (Solutionelement *)new_Solutionelement(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solutionelement,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_str(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_str self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_str" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (char *)Solutionelement_str(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_replaceelements(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_replaceelements self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_replaceelements" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = Solutionelement_replaceelements(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      Solutionelement * result = new_Solutionelement(arg1->solv, arg1->problemid, arg1->solutionid, arg1->id, id, arg1->p, arg1->rp);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solutionelement,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_illegalreplace(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_illegalreplace self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_illegalreplace" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (int)Solutionelement_illegalreplace(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_solvable_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_solvable_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_solvable_get" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (XSolvable *)Solutionelement_solvable_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_replacement_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_replacement_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_replacement_get" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (XSolvable *)Solutionelement_replacement_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_jobidx_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_jobidx_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_jobidx_get" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (int)Solutionelement_jobidx_get(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Solutionelement_Job(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Job *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Solutionelement_Job self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Solutionelement_Job" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  result = (Job *)Solutionelement_Job(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Job,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Solutionelement(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Solutionelement *arg1 = (Solutionelement *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Solutionelement self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Solutionelement, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Solutionelement" "', argument " "1"" of type '" "Solutionelement *""'"); 
  }
  arg1 = (Solutionelement *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Solutionelement(void *obj) {
Solutionelement *arg1 = (Solutionelement *) obj;
free((char *) arg1);
}
static swig_method swig_Solutionelement_methods[] = {
    {"str", _wrap_Solutionelement_str}, 
    {"replaceelements", _wrap_Solutionelement_replaceelements}, 
    {"illegalreplace", _wrap_Solutionelement_illegalreplace}, 
    {"Job", _wrap_Solutionelement_Job}, 
    {0,0}
};
static swig_attribute swig_Solutionelement_attributes[] = {
    { "-solv",_wrap_Solutionelement_solv_get, 0 },
    { "-problemid",_wrap_Solutionelement_problemid_get, 0 },
    { "-solutionid",_wrap_Solutionelement_solutionid_get, 0 },
    { "-id",_wrap_Solutionelement_id_get, 0 },
    { "-type",_wrap_Solutionelement_type_get, 0 },
    { "-solvable",_wrap_Solutionelement_solvable_get, 0 },
    { "-replacement",_wrap_Solutionelement_replacement_get, 0 },
    { "-jobidx",_wrap_Solutionelement_jobidx_get, 0 },
    {0,0,0}
};
static swig_class *swig_Solutionelement_bases[] = {0};
static const char * swig_Solutionelement_base_names[] = {0};
static swig_class _wrap_class_Solutionelement = { "Solutionelement", &SWIGTYPE_p_Solutionelement,_wrap_new_Solutionelement, swig_delete_Solutionelement, swig_Solutionelement_methods, swig_Solutionelement_attributes, swig_Solutionelement_bases,swig_Solutionelement_base_names, &swig_module };
SWIGINTERN int
_wrap_Alternative_solv_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Solver *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_solv_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_solv_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (Solver *)(Solver *) ((arg1)->solv);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Solver,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_type_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_type_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_type_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (Id)(Id) ((arg1)->type);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_rid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_rid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_rid_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (Id)(Id) ((arg1)->rid);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_from_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_from_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_from_id_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (Id)(Id) ((arg1)->from_id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_dep_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_dep_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_dep_id_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (Id)(Id) ((arg1)->dep_id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_chosen_id_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_chosen_id_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_chosen_id_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (Id)(Id) ((arg1)->chosen_id);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_level_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Alternative_level_set self level ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_level_set" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Alternative_level_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->level = arg2;
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_level_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_level_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_level_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (int) ((arg1)->level);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Alternative(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Alternative self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Alternative" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  delete_Alternative(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_chosen_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_chosen_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_chosen_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (XSolvable *)Alternative_chosen_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_rule_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XRule *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_rule_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_rule_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (XRule *)Alternative_rule_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XRule,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_depsolvable_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_depsolvable_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_depsolvable_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (XSolvable *)Alternative_depsolvable_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_dep_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Dep *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_dep_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_dep_get" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (Dep *)Alternative_dep_get(arg1);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Dep,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_choices_raw(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_choices_raw self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_choices_raw" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = Alternative_choices_raw(arg1);
  {
    Tcl_Obj *objvx[(&result)->count];
    int i;
    
    for (i = 0; i < (&result)->count; i++) {
      objvx[i] = SWIG_From_int((&result)->elements[i]);
    }
    
    Tcl_SetObjResult(interp, Tcl_NewListObj((&result)->count, objvx));
    
    queue_free(&result);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative_choices(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative_choices self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative_choices" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = Alternative_choices(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1->solv->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Alternative___str__(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Alternative *arg1 = (Alternative *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Alternative___str__ self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Alternative, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Alternative___str__" "', argument " "1"" of type '" "Alternative *""'"); 
  }
  arg1 = (Alternative *)(argp1);
  result = (char *)Alternative___str__(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Alternative(void *obj) {
Alternative *arg1 = (Alternative *) obj;
delete_Alternative(arg1);
}
static swig_method swig_Alternative_methods[] = {
    {"choices_raw", _wrap_Alternative_choices_raw}, 
    {"choices", _wrap_Alternative_choices}, 
    {"__str__", _wrap_Alternative___str__}, 
    {0,0}
};
static swig_attribute swig_Alternative_attributes[] = {
    { "-solv",_wrap_Alternative_solv_get, 0 },
    { "-type",_wrap_Alternative_type_get, 0 },
    { "-rid",_wrap_Alternative_rid_get, 0 },
    { "-from_id",_wrap_Alternative_from_id_get, 0 },
    { "-dep_id",_wrap_Alternative_dep_id_get, 0 },
    { "-chosen_id",_wrap_Alternative_chosen_id_get, 0 },
    { "-level",_wrap_Alternative_level_get, _wrap_Alternative_level_set},
    { "-chosen",_wrap_Alternative_chosen_get, 0 },
    { "-rule",_wrap_Alternative_rule_get, 0 },
    { "-depsolvable",_wrap_Alternative_depsolvable_get, 0 },
    { "-dep",_wrap_Alternative_dep_get, 0 },
    {0,0,0}
};
static swig_class *swig_Alternative_bases[] = {0};
static const char * swig_Alternative_base_names[] = {0};
static swig_class _wrap_class_Alternative = { "Alternative", &SWIGTYPE_p_Alternative,0, swig_delete_Alternative, swig_Alternative_methods, swig_Alternative_attributes, swig_Alternative_bases,swig_Alternative_base_names, &swig_module };
SWIGINTERN int
_wrap_Transaction_pool_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pool *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Transaction_pool_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_pool_get" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  result = (Pool *)(Pool *) ((arg1)->pool);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Pool,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_Transaction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_Transaction self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Transaction" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  delete_Transaction(arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_isempty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Transaction_isempty self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_isempty" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  result = (bool)Transaction_isempty(arg1);
  Tcl_SetObjResult(interp,SWIG_From_bool((bool)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_othersolvable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  XSolvable *arg2 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  XSolvable *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Transaction_othersolvable self s ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_othersolvable" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Transaction_othersolvable" "', argument " "2"" of type '" "XSolvable *""'"); 
  }
  arg2 = (XSolvable *)(argp2);
  result = (XSolvable *)Transaction_othersolvable(arg1,arg2);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_allothersolvables(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  XSolvable *arg2 = (XSolvable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:solv::Transaction_allothersolvables self s ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_allothersolvables" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Transaction_allothersolvables" "', argument " "2"" of type '" "XSolvable *""'"); 
  }
  arg2 = (XSolvable *)(argp2);
  result = Transaction_allothersolvables(arg1,arg2);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_classify(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Transaction_classify self ?mode? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_classify" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Transaction_classify" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = Transaction_classify(arg1,arg2);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 4;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 4) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      TransactionClass * result = new_TransactionClass(arg1, arg2, id, idp[1], idp[2], idp[3]);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_TransactionClass,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_newpackages(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Transaction_newpackages self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_newpackages" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  result = Transaction_newpackages(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_keptpackages(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Transaction_keptpackages self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_keptpackages" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  result = Transaction_keptpackages(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_newsolvables(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Transaction_newsolvables self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_newsolvables" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  result = Transaction_newsolvables(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_keptsolvables(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Transaction_keptsolvables self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_keptsolvables" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  result = Transaction_keptsolvables(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_steps(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Transaction_steps self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_steps" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  result = Transaction_steps(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_steptype(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  XSolvable *arg2 = (XSolvable *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:solv::Transaction_steptype self s mode ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_steptype" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_XSolvable, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Transaction_steptype" "', argument " "2"" of type '" "XSolvable *""'"); 
  }
  arg2 = (XSolvable *)(argp2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Transaction_steptype" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (int)Transaction_steptype(arg1,arg2,arg3);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_calc_installsizechange(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::Transaction_calc_installsizechange self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_calc_installsizechange" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  result = (int)Transaction_calc_installsizechange(arg1);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Transaction_order(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o|o:solv::Transaction_order self ?flags? ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction_order" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  if (objc > 2) {
    ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Transaction_order" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  Transaction_order(arg1,arg2);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_Transaction(void *obj) {
Transaction *arg1 = (Transaction *) obj;
delete_Transaction(arg1);
}
static swig_method swig_Transaction_methods[] = {
    {"isempty", _wrap_Transaction_isempty}, 
    {"othersolvable", _wrap_Transaction_othersolvable}, 
    {"allothersolvables", _wrap_Transaction_allothersolvables}, 
    {"classify", _wrap_Transaction_classify}, 
    {"newpackages", _wrap_Transaction_newpackages}, 
    {"keptpackages", _wrap_Transaction_keptpackages}, 
    {"newsolvables", _wrap_Transaction_newsolvables}, 
    {"keptsolvables", _wrap_Transaction_keptsolvables}, 
    {"steps", _wrap_Transaction_steps}, 
    {"steptype", _wrap_Transaction_steptype}, 
    {"calc_installsizechange", _wrap_Transaction_calc_installsizechange}, 
    {"order", _wrap_Transaction_order}, 
    {0,0}
};
static swig_attribute swig_Transaction_attributes[] = {
    { "-pool",_wrap_Transaction_pool_get, 0 },
    {0,0,0}
};
static swig_class *swig_Transaction_bases[] = {0};
static const char * swig_Transaction_base_names[] = {0};
static swig_class _wrap_class_Transaction = { "Transaction", &SWIGTYPE_p_Transaction,0, swig_delete_Transaction, swig_Transaction_methods, swig_Transaction_attributes, swig_Transaction_bases,swig_Transaction_base_names, &swig_module };
SWIGINTERN int
_wrap_TransactionClass_transaction_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TransactionClass *arg1 = (TransactionClass *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Transaction *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::TransactionClass_transaction_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TransactionClass, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TransactionClass_transaction_get" "', argument " "1"" of type '" "TransactionClass *""'"); 
  }
  arg1 = (TransactionClass *)(argp1);
  result = (Transaction *)(Transaction *) ((arg1)->transaction);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Transaction,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TransactionClass_type_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TransactionClass *arg1 = (TransactionClass *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::TransactionClass_type_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TransactionClass, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TransactionClass_type_get" "', argument " "1"" of type '" "TransactionClass *""'"); 
  }
  arg1 = (TransactionClass *)(argp1);
  result = (Id)(Id) ((arg1)->type);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TransactionClass_fromid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TransactionClass *arg1 = (TransactionClass *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::TransactionClass_fromid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TransactionClass, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TransactionClass_fromid_get" "', argument " "1"" of type '" "TransactionClass *""'"); 
  }
  arg1 = (TransactionClass *)(argp1);
  result = (Id)(Id) ((arg1)->fromid);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TransactionClass_toid_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TransactionClass *arg1 = (TransactionClass *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Id result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::TransactionClass_toid_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TransactionClass, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TransactionClass_toid_get" "', argument " "1"" of type '" "TransactionClass *""'"); 
  }
  arg1 = (TransactionClass *)(argp1);
  result = (Id)(Id) ((arg1)->toid);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TransactionClass_count_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TransactionClass *arg1 = (TransactionClass *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::TransactionClass_count_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TransactionClass, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TransactionClass_count_get" "', argument " "1"" of type '" "TransactionClass *""'"); 
  }
  arg1 = (TransactionClass *)(argp1);
  result = (int)(int) ((arg1)->count);
  Tcl_SetObjResult(interp,SWIG_From_int((int)(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_TransactionClass(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Transaction *arg1 = (Transaction *) 0 ;
  int arg2 ;
  Id arg3 ;
  int arg4 ;
  Id arg5 ;
  Id arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  TransactionClass *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:solv::new_TransactionClass trans mode type count fromid toid ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_TransactionClass" "', argument " "1"" of type '" "Transaction *""'"); 
  }
  arg1 = (Transaction *)(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_TransactionClass" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_TransactionClass" "', argument " "3"" of type '" "Id""'");
  } 
  arg3 = (Id)(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_TransactionClass" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_TransactionClass" "', argument " "5"" of type '" "Id""'");
  } 
  arg5 = (Id)(val5);
  ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_TransactionClass" "', argument " "6"" of type '" "Id""'");
  } 
  arg6 = (Id)(val6);
  result = (TransactionClass *)new_TransactionClass(arg1,arg2,arg3,arg4,arg5,arg6);
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_TransactionClass,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TransactionClass_solvables(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TransactionClass *arg1 = (TransactionClass *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Queue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::TransactionClass_solvables self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TransactionClass, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TransactionClass_solvables" "', argument " "1"" of type '" "TransactionClass *""'"); 
  }
  arg1 = (TransactionClass *)(argp1);
  result = TransactionClass_solvables(arg1);
  
  {
    /* scope is needed to make the goto of SWIG_exception_fail work */
    int i;
    int cnt = (&result)->count / 1;
    Id *idp = (&result)->elements;
    Tcl_Obj *objvx[cnt];
    
    for (i = 0; i < cnt; i++, idp += 1) {
      Id id = *idp;
#define result resultx
#define Tcl_SetObjResult(i, x) resultobj = x
      XSolvable * result = new_XSolvable(arg1->transaction->pool, id);
      Tcl_Obj *resultobj;
      Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_XSolvable,0));
      objvx[i] = resultobj;
#undef Tcl_SetObjResult
#undef result
    }
    queue_free(&result);
    Tcl_SetObjResult(interp, Tcl_NewListObj(cnt, objvx));
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TransactionClass_fromstr_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TransactionClass *arg1 = (TransactionClass *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::TransactionClass_fromstr_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TransactionClass, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TransactionClass_fromstr_get" "', argument " "1"" of type '" "TransactionClass *""'"); 
  }
  arg1 = (TransactionClass *)(argp1);
  result = (char *)TransactionClass_fromstr_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TransactionClass_tostr_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TransactionClass *arg1 = (TransactionClass *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::TransactionClass_tostr_get self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TransactionClass, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TransactionClass_tostr_get" "', argument " "1"" of type '" "TransactionClass *""'"); 
  }
  arg1 = (TransactionClass *)(argp1);
  result = (char *)TransactionClass_tostr_get(arg1);
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_TransactionClass(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TransactionClass *arg1 = (TransactionClass *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:solv::delete_TransactionClass self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TransactionClass, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TransactionClass" "', argument " "1"" of type '" "TransactionClass *""'"); 
  }
  arg1 = (TransactionClass *)(argp1);
  free((char *) arg1);
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_TransactionClass(void *obj) {
TransactionClass *arg1 = (TransactionClass *) obj;
free((char *) arg1);
}
static swig_method swig_TransactionClass_methods[] = {
    {"solvables", _wrap_TransactionClass_solvables}, 
    {0,0}
};
static swig_attribute swig_TransactionClass_attributes[] = {
    { "-transaction",_wrap_TransactionClass_transaction_get, 0 },
    { "-type",_wrap_TransactionClass_type_get, 0 },
    { "-fromid",_wrap_TransactionClass_fromid_get, 0 },
    { "-toid",_wrap_TransactionClass_toid_get, 0 },
    { "-count",_wrap_TransactionClass_count_get, 0 },
    { "-fromstr",_wrap_TransactionClass_fromstr_get, 0 },
    { "-tostr",_wrap_TransactionClass_tostr_get, 0 },
    {0,0,0}
};
static swig_class *swig_TransactionClass_bases[] = {0};
static const char * swig_TransactionClass_base_names[] = {0};
static swig_class _wrap_class_TransactionClass = { "TransactionClass", &SWIGTYPE_p_TransactionClass,_wrap_new_TransactionClass, swig_delete_TransactionClass, swig_TransactionClass_methods, swig_TransactionClass_attributes, swig_TransactionClass_bases,swig_TransactionClass_base_names, &swig_module };

static swig_command_info swig_commands[] = {
    { SWIG_prefix "Selection_pool_get", (swig_wrapper_func) _wrap_Selection_pool_get, NULL},
    { SWIG_prefix "new_Selection", (swig_wrapper_func) _wrap_new_Selection, NULL},
    { SWIG_prefix "delete_Selection", (swig_wrapper_func) _wrap_delete_Selection, NULL},
    { SWIG_prefix "Selection_flags", (swig_wrapper_func) _wrap_Selection_flags, NULL},
    { SWIG_prefix "Selection_isempty", (swig_wrapper_func) _wrap_Selection_isempty, NULL},
    { SWIG_prefix "Selection_filter", (swig_wrapper_func) _wrap_Selection_filter, NULL},
    { SWIG_prefix "Selection_add", (swig_wrapper_func) _wrap_Selection_add, NULL},
    { SWIG_prefix "Selection_add_raw", (swig_wrapper_func) _wrap_Selection_add_raw, NULL},
    { SWIG_prefix "Selection_jobs", (swig_wrapper_func) _wrap_Selection_jobs, NULL},
    { SWIG_prefix "Selection_solvables", (swig_wrapper_func) _wrap_Selection_solvables, NULL},
    { SWIG_prefix "Selection___str__", (swig_wrapper_func) _wrap_Selection___str__, NULL},
    { SWIG_prefix "Selection___repr__", (swig_wrapper_func) _wrap_Selection___repr__, NULL},
    { SWIG_prefix "Selection", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Selection},
    { SWIG_prefix "Dep_pool_get", (swig_wrapper_func) _wrap_Dep_pool_get, NULL},
    { SWIG_prefix "Dep_id_get", (swig_wrapper_func) _wrap_Dep_id_get, NULL},
    { SWIG_prefix "new_Dep", (swig_wrapper_func) _wrap_new_Dep, NULL},
    { SWIG_prefix "Dep_Rel", (swig_wrapper_func) _wrap_Dep_Rel, NULL},
    { SWIG_prefix "Dep_Selection_name", (swig_wrapper_func) _wrap_Dep_Selection_name, NULL},
    { SWIG_prefix "Dep_Selection_provides", (swig_wrapper_func) _wrap_Dep_Selection_provides, NULL},
    { SWIG_prefix "Dep_str", (swig_wrapper_func) _wrap_Dep_str, NULL},
    { SWIG_prefix "Dep___eq__", (swig_wrapper_func) _wrap_Dep___eq__, NULL},
    { SWIG_prefix "Dep___ne__", (swig_wrapper_func) _wrap_Dep___ne__, NULL},
    { SWIG_prefix "Dep___str__", (swig_wrapper_func) _wrap_Dep___str__, NULL},
    { SWIG_prefix "Dep___repr__", (swig_wrapper_func) _wrap_Dep___repr__, NULL},
    { SWIG_prefix "delete_Dep", (swig_wrapper_func) _wrap_delete_Dep, NULL},
    { SWIG_prefix "Dep", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Dep},
    { SWIG_prefix "new_Dataiterator", (swig_wrapper_func) _wrap_new_Dataiterator, NULL},
    { SWIG_prefix "delete_Dataiterator", (swig_wrapper_func) _wrap_delete_Dataiterator, NULL},
    { SWIG_prefix "Dataiterator___next__", (swig_wrapper_func) _wrap_Dataiterator___next__, NULL},
    { SWIG_prefix "Dataiterator_prepend_keyname", (swig_wrapper_func) _wrap_Dataiterator_prepend_keyname, NULL},
    { SWIG_prefix "Dataiterator_skip_solvable", (swig_wrapper_func) _wrap_Dataiterator_skip_solvable, NULL},
    { SWIG_prefix "Dataiterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Dataiterator},
    { SWIG_prefix "XSolvable_pool_get", (swig_wrapper_func) _wrap_XSolvable_pool_get, NULL},
    { SWIG_prefix "XSolvable_id_get", (swig_wrapper_func) _wrap_XSolvable_id_get, NULL},
    { SWIG_prefix "new_XSolvable", (swig_wrapper_func) _wrap_new_XSolvable, NULL},
    { SWIG_prefix "XSolvable_str", (swig_wrapper_func) _wrap_XSolvable_str, NULL},
    { SWIG_prefix "XSolvable_lookup_str", (swig_wrapper_func) _wrap_XSolvable_lookup_str, NULL},
    { SWIG_prefix "XSolvable_lookup_id", (swig_wrapper_func) _wrap_XSolvable_lookup_id, NULL},
    { SWIG_prefix "XSolvable_lookup_num", (swig_wrapper_func) _wrap_XSolvable_lookup_num, NULL},
    { SWIG_prefix "XSolvable_lookup_void", (swig_wrapper_func) _wrap_XSolvable_lookup_void, NULL},
    { SWIG_prefix "XSolvable_lookup_checksum", (swig_wrapper_func) _wrap_XSolvable_lookup_checksum, NULL},
    { SWIG_prefix "XSolvable_lookup_idarray", (swig_wrapper_func) _wrap_XSolvable_lookup_idarray, NULL},
    { SWIG_prefix "XSolvable_lookup_deparray", (swig_wrapper_func) _wrap_XSolvable_lookup_deparray, NULL},
    { SWIG_prefix "XSolvable_lookup_location", (swig_wrapper_func) _wrap_XSolvable_lookup_location, NULL},
    { SWIG_prefix "XSolvable_Dataiterator", (swig_wrapper_func) _wrap_XSolvable_Dataiterator, NULL},
    { SWIG_prefix "XSolvable_installable", (swig_wrapper_func) _wrap_XSolvable_installable, NULL},
    { SWIG_prefix "XSolvable_isinstalled", (swig_wrapper_func) _wrap_XSolvable_isinstalled, NULL},
    { SWIG_prefix "XSolvable_name_set", (swig_wrapper_func) _wrap_XSolvable_name_set, NULL},
    { SWIG_prefix "XSolvable_name_get", (swig_wrapper_func) _wrap_XSolvable_name_get, NULL},
    { SWIG_prefix "XSolvable_nameid_set", (swig_wrapper_func) _wrap_XSolvable_nameid_set, NULL},
    { SWIG_prefix "XSolvable_nameid_get", (swig_wrapper_func) _wrap_XSolvable_nameid_get, NULL},
    { SWIG_prefix "XSolvable_evr_set", (swig_wrapper_func) _wrap_XSolvable_evr_set, NULL},
    { SWIG_prefix "XSolvable_evr_get", (swig_wrapper_func) _wrap_XSolvable_evr_get, NULL},
    { SWIG_prefix "XSolvable_evrid_set", (swig_wrapper_func) _wrap_XSolvable_evrid_set, NULL},
    { SWIG_prefix "XSolvable_evrid_get", (swig_wrapper_func) _wrap_XSolvable_evrid_get, NULL},
    { SWIG_prefix "XSolvable_arch_set", (swig_wrapper_func) _wrap_XSolvable_arch_set, NULL},
    { SWIG_prefix "XSolvable_arch_get", (swig_wrapper_func) _wrap_XSolvable_arch_get, NULL},
    { SWIG_prefix "XSolvable_archid_set", (swig_wrapper_func) _wrap_XSolvable_archid_set, NULL},
    { SWIG_prefix "XSolvable_archid_get", (swig_wrapper_func) _wrap_XSolvable_archid_get, NULL},
    { SWIG_prefix "XSolvable_vendor_set", (swig_wrapper_func) _wrap_XSolvable_vendor_set, NULL},
    { SWIG_prefix "XSolvable_vendor_get", (swig_wrapper_func) _wrap_XSolvable_vendor_get, NULL},
    { SWIG_prefix "XSolvable_vendorid_set", (swig_wrapper_func) _wrap_XSolvable_vendorid_set, NULL},
    { SWIG_prefix "XSolvable_vendorid_get", (swig_wrapper_func) _wrap_XSolvable_vendorid_get, NULL},
    { SWIG_prefix "XSolvable_repo_get", (swig_wrapper_func) _wrap_XSolvable_repo_get, NULL},
    { SWIG_prefix "XSolvable_add_provides", (swig_wrapper_func) _wrap_XSolvable_add_provides, NULL},
    { SWIG_prefix "XSolvable_add_obsoletes", (swig_wrapper_func) _wrap_XSolvable_add_obsoletes, NULL},
    { SWIG_prefix "XSolvable_add_conflicts", (swig_wrapper_func) _wrap_XSolvable_add_conflicts, NULL},
    { SWIG_prefix "XSolvable_add_requires", (swig_wrapper_func) _wrap_XSolvable_add_requires, NULL},
    { SWIG_prefix "XSolvable_add_recommends", (swig_wrapper_func) _wrap_XSolvable_add_recommends, NULL},
    { SWIG_prefix "XSolvable_add_suggests", (swig_wrapper_func) _wrap_XSolvable_add_suggests, NULL},
    { SWIG_prefix "XSolvable_add_supplements", (swig_wrapper_func) _wrap_XSolvable_add_supplements, NULL},
    { SWIG_prefix "XSolvable_add_enhances", (swig_wrapper_func) _wrap_XSolvable_add_enhances, NULL},
    { SWIG_prefix "XSolvable_unset", (swig_wrapper_func) _wrap_XSolvable_unset, NULL},
    { SWIG_prefix "XSolvable_add_deparray", (swig_wrapper_func) _wrap_XSolvable_add_deparray, NULL},
    { SWIG_prefix "XSolvable_Selection", (swig_wrapper_func) _wrap_XSolvable_Selection, NULL},
    { SWIG_prefix "XSolvable_identical", (swig_wrapper_func) _wrap_XSolvable_identical, NULL},
    { SWIG_prefix "XSolvable_evrcmp", (swig_wrapper_func) _wrap_XSolvable_evrcmp, NULL},
    { SWIG_prefix "XSolvable___eq__", (swig_wrapper_func) _wrap_XSolvable___eq__, NULL},
    { SWIG_prefix "XSolvable___ne__", (swig_wrapper_func) _wrap_XSolvable___ne__, NULL},
    { SWIG_prefix "XSolvable___str__", (swig_wrapper_func) _wrap_XSolvable___str__, NULL},
    { SWIG_prefix "XSolvable___repr__", (swig_wrapper_func) _wrap_XSolvable___repr__, NULL},
    { SWIG_prefix "delete_XSolvable", (swig_wrapper_func) _wrap_delete_XSolvable, NULL},
    { SWIG_prefix "XSolvable", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_XSolvable},
    { SWIG_prefix "Ruleinfo_solv_get", (swig_wrapper_func) _wrap_Ruleinfo_solv_get, NULL},
    { SWIG_prefix "Ruleinfo_type_get", (swig_wrapper_func) _wrap_Ruleinfo_type_get, NULL},
    { SWIG_prefix "Ruleinfo_dep_id_get", (swig_wrapper_func) _wrap_Ruleinfo_dep_id_get, NULL},
    { SWIG_prefix "new_Ruleinfo", (swig_wrapper_func) _wrap_new_Ruleinfo, NULL},
    { SWIG_prefix "Ruleinfo_solvable_get", (swig_wrapper_func) _wrap_Ruleinfo_solvable_get, NULL},
    { SWIG_prefix "Ruleinfo_othersolvable_get", (swig_wrapper_func) _wrap_Ruleinfo_othersolvable_get, NULL},
    { SWIG_prefix "Ruleinfo_dep_get", (swig_wrapper_func) _wrap_Ruleinfo_dep_get, NULL},
    { SWIG_prefix "Ruleinfo_problemstr", (swig_wrapper_func) _wrap_Ruleinfo_problemstr, NULL},
    { SWIG_prefix "delete_Ruleinfo", (swig_wrapper_func) _wrap_delete_Ruleinfo, NULL},
    { SWIG_prefix "Ruleinfo", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Ruleinfo},
    { SWIG_prefix "XRule_solv_get", (swig_wrapper_func) _wrap_XRule_solv_get, NULL},
    { SWIG_prefix "XRule_id_get", (swig_wrapper_func) _wrap_XRule_id_get, NULL},
    { SWIG_prefix "new_XRule", (swig_wrapper_func) _wrap_new_XRule, NULL},
    { SWIG_prefix "XRule_type_get", (swig_wrapper_func) _wrap_XRule_type_get, NULL},
    { SWIG_prefix "XRule_info", (swig_wrapper_func) _wrap_XRule_info, NULL},
    { SWIG_prefix "XRule_allinfos", (swig_wrapper_func) _wrap_XRule_allinfos, NULL},
    { SWIG_prefix "XRule___eq__", (swig_wrapper_func) _wrap_XRule___eq__, NULL},
    { SWIG_prefix "XRule___ne__", (swig_wrapper_func) _wrap_XRule___ne__, NULL},
    { SWIG_prefix "XRule___repr__", (swig_wrapper_func) _wrap_XRule___repr__, NULL},
    { SWIG_prefix "delete_XRule", (swig_wrapper_func) _wrap_delete_XRule, NULL},
    { SWIG_prefix "XRule", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_XRule},
    { SWIG_prefix "XRepodata_repo_get", (swig_wrapper_func) _wrap_XRepodata_repo_get, NULL},
    { SWIG_prefix "XRepodata_id_get", (swig_wrapper_func) _wrap_XRepodata_id_get, NULL},
    { SWIG_prefix "new_XRepodata", (swig_wrapper_func) _wrap_new_XRepodata, NULL},
    { SWIG_prefix "XRepodata_new_handle", (swig_wrapper_func) _wrap_XRepodata_new_handle, NULL},
    { SWIG_prefix "XRepodata_set_id", (swig_wrapper_func) _wrap_XRepodata_set_id, NULL},
    { SWIG_prefix "XRepodata_set_str", (swig_wrapper_func) _wrap_XRepodata_set_str, NULL},
    { SWIG_prefix "XRepodata_set_poolstr", (swig_wrapper_func) _wrap_XRepodata_set_poolstr, NULL},
    { SWIG_prefix "XRepodata_add_idarray", (swig_wrapper_func) _wrap_XRepodata_add_idarray, NULL},
    { SWIG_prefix "XRepodata_add_flexarray", (swig_wrapper_func) _wrap_XRepodata_add_flexarray, NULL},
    { SWIG_prefix "XRepodata_set_checksum", (swig_wrapper_func) _wrap_XRepodata_set_checksum, NULL},
    { SWIG_prefix "XRepodata_lookup_str", (swig_wrapper_func) _wrap_XRepodata_lookup_str, NULL},
    { SWIG_prefix "XRepodata_lookup_idarray", (swig_wrapper_func) _wrap_XRepodata_lookup_idarray, NULL},
    { SWIG_prefix "XRepodata_lookup_checksum", (swig_wrapper_func) _wrap_XRepodata_lookup_checksum, NULL},
    { SWIG_prefix "XRepodata_internalize", (swig_wrapper_func) _wrap_XRepodata_internalize, NULL},
    { SWIG_prefix "XRepodata_create_stubs", (swig_wrapper_func) _wrap_XRepodata_create_stubs, NULL},
    { SWIG_prefix "XRepodata_write", (swig_wrapper_func) _wrap_XRepodata_write, NULL},
    { SWIG_prefix "XRepodata_add_solv", (swig_wrapper_func) _wrap_XRepodata_add_solv, NULL},
    { SWIG_prefix "XRepodata_extend_to_repo", (swig_wrapper_func) _wrap_XRepodata_extend_to_repo, NULL},
    { SWIG_prefix "XRepodata___eq__", (swig_wrapper_func) _wrap_XRepodata___eq__, NULL},
    { SWIG_prefix "XRepodata___ne__", (swig_wrapper_func) _wrap_XRepodata___ne__, NULL},
    { SWIG_prefix "XRepodata___repr__", (swig_wrapper_func) _wrap_XRepodata___repr__, NULL},
    { SWIG_prefix "delete_XRepodata", (swig_wrapper_func) _wrap_delete_XRepodata, NULL},
    { SWIG_prefix "XRepodata", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_XRepodata},
    { SWIG_prefix "new_Pool_solvable_iterator", (swig_wrapper_func) _wrap_new_Pool_solvable_iterator, NULL},
    { SWIG_prefix "Pool_solvable_iterator___next__", (swig_wrapper_func) _wrap_Pool_solvable_iterator___next__, NULL},
    { SWIG_prefix "Pool_solvable_iterator___getitem__", (swig_wrapper_func) _wrap_Pool_solvable_iterator___getitem__, NULL},
    { SWIG_prefix "Pool_solvable_iterator___len__", (swig_wrapper_func) _wrap_Pool_solvable_iterator___len__, NULL},
    { SWIG_prefix "delete_Pool_solvable_iterator", (swig_wrapper_func) _wrap_delete_Pool_solvable_iterator, NULL},
    { SWIG_prefix "Pool_solvable_iterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Pool_solvable_iterator},
    { SWIG_prefix "new_Pool_repo_iterator", (swig_wrapper_func) _wrap_new_Pool_repo_iterator, NULL},
    { SWIG_prefix "Pool_repo_iterator___next__", (swig_wrapper_func) _wrap_Pool_repo_iterator___next__, NULL},
    { SWIG_prefix "Pool_repo_iterator___getitem__", (swig_wrapper_func) _wrap_Pool_repo_iterator___getitem__, NULL},
    { SWIG_prefix "Pool_repo_iterator___len__", (swig_wrapper_func) _wrap_Pool_repo_iterator___len__, NULL},
    { SWIG_prefix "delete_Pool_repo_iterator", (swig_wrapper_func) _wrap_delete_Pool_repo_iterator, NULL},
    { SWIG_prefix "Pool_repo_iterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Pool_repo_iterator},
    { SWIG_prefix "new_Repo_solvable_iterator", (swig_wrapper_func) _wrap_new_Repo_solvable_iterator, NULL},
    { SWIG_prefix "Repo_solvable_iterator___next__", (swig_wrapper_func) _wrap_Repo_solvable_iterator___next__, NULL},
    { SWIG_prefix "Repo_solvable_iterator___getitem__", (swig_wrapper_func) _wrap_Repo_solvable_iterator___getitem__, NULL},
    { SWIG_prefix "Repo_solvable_iterator___len__", (swig_wrapper_func) _wrap_Repo_solvable_iterator___len__, NULL},
    { SWIG_prefix "delete_Repo_solvable_iterator", (swig_wrapper_func) _wrap_delete_Repo_solvable_iterator, NULL},
    { SWIG_prefix "Repo_solvable_iterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Repo_solvable_iterator},
    { SWIG_prefix "Datamatch_pool_get", (swig_wrapper_func) _wrap_Datamatch_pool_get, NULL},
    { SWIG_prefix "Datamatch_repo_get", (swig_wrapper_func) _wrap_Datamatch_repo_get, NULL},
    { SWIG_prefix "Datamatch_solvid_get", (swig_wrapper_func) _wrap_Datamatch_solvid_get, NULL},
    { SWIG_prefix "delete_Datamatch", (swig_wrapper_func) _wrap_delete_Datamatch, NULL},
    { SWIG_prefix "Datamatch_solvable_get", (swig_wrapper_func) _wrap_Datamatch_solvable_get, NULL},
    { SWIG_prefix "Datamatch_key_id_get", (swig_wrapper_func) _wrap_Datamatch_key_id_get, NULL},
    { SWIG_prefix "Datamatch_key_idstr_get", (swig_wrapper_func) _wrap_Datamatch_key_idstr_get, NULL},
    { SWIG_prefix "Datamatch_type_id_get", (swig_wrapper_func) _wrap_Datamatch_type_id_get, NULL},
    { SWIG_prefix "Datamatch_type_idstr_get", (swig_wrapper_func) _wrap_Datamatch_type_idstr_get, NULL},
    { SWIG_prefix "Datamatch_id_get", (swig_wrapper_func) _wrap_Datamatch_id_get, NULL},
    { SWIG_prefix "Datamatch_idstr_get", (swig_wrapper_func) _wrap_Datamatch_idstr_get, NULL},
    { SWIG_prefix "Datamatch_str_get", (swig_wrapper_func) _wrap_Datamatch_str_get, NULL},
    { SWIG_prefix "Datamatch_binary_get", (swig_wrapper_func) _wrap_Datamatch_binary_get, NULL},
    { SWIG_prefix "Datamatch_num_get", (swig_wrapper_func) _wrap_Datamatch_num_get, NULL},
    { SWIG_prefix "Datamatch_num2_get", (swig_wrapper_func) _wrap_Datamatch_num2_get, NULL},
    { SWIG_prefix "Datamatch_pos", (swig_wrapper_func) _wrap_Datamatch_pos, NULL},
    { SWIG_prefix "Datamatch_parentpos", (swig_wrapper_func) _wrap_Datamatch_parentpos, NULL},
    { SWIG_prefix "Datamatch___str__", (swig_wrapper_func) _wrap_Datamatch___str__, NULL},
    { SWIG_prefix "Datamatch", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Datamatch},
    { SWIG_prefix "Datapos_repo_get", (swig_wrapper_func) _wrap_Datapos_repo_get, NULL},
    { SWIG_prefix "Datapos_lookup_id", (swig_wrapper_func) _wrap_Datapos_lookup_id, NULL},
    { SWIG_prefix "Datapos_lookup_str", (swig_wrapper_func) _wrap_Datapos_lookup_str, NULL},
    { SWIG_prefix "Datapos_lookup_num", (swig_wrapper_func) _wrap_Datapos_lookup_num, NULL},
    { SWIG_prefix "Datapos_lookup_void", (swig_wrapper_func) _wrap_Datapos_lookup_void, NULL},
    { SWIG_prefix "Datapos_lookup_checksum", (swig_wrapper_func) _wrap_Datapos_lookup_checksum, NULL},
    { SWIG_prefix "Datapos_lookup_deltaseq", (swig_wrapper_func) _wrap_Datapos_lookup_deltaseq, NULL},
    { SWIG_prefix "Datapos_lookup_deltalocation", (swig_wrapper_func) _wrap_Datapos_lookup_deltalocation, NULL},
    { SWIG_prefix "Datapos_lookup_idarray", (swig_wrapper_func) _wrap_Datapos_lookup_idarray, NULL},
    { SWIG_prefix "Datapos_Dataiterator", (swig_wrapper_func) _wrap_Datapos_Dataiterator, NULL},
    { SWIG_prefix "delete_Datapos", (swig_wrapper_func) _wrap_delete_Datapos, NULL},
    { SWIG_prefix "Datapos", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Datapos},
    { SWIG_prefix "Job_pool_get", (swig_wrapper_func) _wrap_Job_pool_get, NULL},
    { SWIG_prefix "Job_how_set", (swig_wrapper_func) _wrap_Job_how_set, NULL},
    { SWIG_prefix "Job_how_get", (swig_wrapper_func) _wrap_Job_how_get, NULL},
    { SWIG_prefix "Job_what_set", (swig_wrapper_func) _wrap_Job_what_set, NULL},
    { SWIG_prefix "Job_what_get", (swig_wrapper_func) _wrap_Job_what_get, NULL},
    { SWIG_prefix "new_Job", (swig_wrapper_func) _wrap_new_Job, NULL},
    { SWIG_prefix "Job_solvables", (swig_wrapper_func) _wrap_Job_solvables, NULL},
    { SWIG_prefix "Job_isemptyupdate", (swig_wrapper_func) _wrap_Job_isemptyupdate, NULL},
    { SWIG_prefix "Job___eq__", (swig_wrapper_func) _wrap_Job___eq__, NULL},
    { SWIG_prefix "Job___ne__", (swig_wrapper_func) _wrap_Job___ne__, NULL},
    { SWIG_prefix "Job___str__", (swig_wrapper_func) _wrap_Job___str__, NULL},
    { SWIG_prefix "Job___repr__", (swig_wrapper_func) _wrap_Job___repr__, NULL},
    { SWIG_prefix "delete_Job", (swig_wrapper_func) _wrap_delete_Job, NULL},
    { SWIG_prefix "Job", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Job},
    { SWIG_prefix "Pool_appdata_set", (swig_wrapper_func) _wrap_Pool_appdata_set, NULL},
    { SWIG_prefix "Pool_appdata_get", (swig_wrapper_func) _wrap_Pool_appdata_get, NULL},
    { SWIG_prefix "new_Pool", (swig_wrapper_func) _wrap_new_Pool, NULL},
    { SWIG_prefix "Pool_set_debuglevel", (swig_wrapper_func) _wrap_Pool_set_debuglevel, NULL},
    { SWIG_prefix "Pool_set_flag", (swig_wrapper_func) _wrap_Pool_set_flag, NULL},
    { SWIG_prefix "Pool_get_flag", (swig_wrapper_func) _wrap_Pool_get_flag, NULL},
    { SWIG_prefix "Pool_set_rootdir", (swig_wrapper_func) _wrap_Pool_set_rootdir, NULL},
    { SWIG_prefix "Pool_get_rootdir", (swig_wrapper_func) _wrap_Pool_get_rootdir, NULL},
    { SWIG_prefix "Pool_set_loadcallback", (swig_wrapper_func) _wrap_Pool_set_loadcallback, NULL},
    { SWIG_prefix "delete_Pool", (swig_wrapper_func) _wrap_delete_Pool, NULL},
    { SWIG_prefix "Pool_free", (swig_wrapper_func) _wrap_Pool_free, NULL},
    { SWIG_prefix "Pool_disown", (swig_wrapper_func) _wrap_Pool_disown, NULL},
    { SWIG_prefix "Pool_str2id", (swig_wrapper_func) _wrap_Pool_str2id, NULL},
    { SWIG_prefix "Pool_Dep", (swig_wrapper_func) _wrap_Pool_Dep, NULL},
    { SWIG_prefix "Pool_id2str", (swig_wrapper_func) _wrap_Pool_id2str, NULL},
    { SWIG_prefix "Pool_dep2str", (swig_wrapper_func) _wrap_Pool_dep2str, NULL},
    { SWIG_prefix "Pool_rel2id", (swig_wrapper_func) _wrap_Pool_rel2id, NULL},
    { SWIG_prefix "Pool_id2langid", (swig_wrapper_func) _wrap_Pool_id2langid, NULL},
    { SWIG_prefix "Pool_setarch", (swig_wrapper_func) _wrap_Pool_setarch, NULL},
    { SWIG_prefix "Pool_add_repo", (swig_wrapper_func) _wrap_Pool_add_repo, NULL},
    { SWIG_prefix "Pool_lookup_str", (swig_wrapper_func) _wrap_Pool_lookup_str, NULL},
    { SWIG_prefix "Pool_lookup_id", (swig_wrapper_func) _wrap_Pool_lookup_id, NULL},
    { SWIG_prefix "Pool_lookup_num", (swig_wrapper_func) _wrap_Pool_lookup_num, NULL},
    { SWIG_prefix "Pool_lookup_void", (swig_wrapper_func) _wrap_Pool_lookup_void, NULL},
    { SWIG_prefix "Pool_lookup_checksum", (swig_wrapper_func) _wrap_Pool_lookup_checksum, NULL},
    { SWIG_prefix "Pool_Dataiterator", (swig_wrapper_func) _wrap_Pool_Dataiterator, NULL},
    { SWIG_prefix "Pool_Dataiterator_solvid", (swig_wrapper_func) _wrap_Pool_Dataiterator_solvid, NULL},
    { SWIG_prefix "Pool_solvid2str", (swig_wrapper_func) _wrap_Pool_solvid2str, NULL},
    { SWIG_prefix "Pool_addfileprovides", (swig_wrapper_func) _wrap_Pool_addfileprovides, NULL},
    { SWIG_prefix "Pool_addfileprovides_queue", (swig_wrapper_func) _wrap_Pool_addfileprovides_queue, NULL},
    { SWIG_prefix "Pool_createwhatprovides", (swig_wrapper_func) _wrap_Pool_createwhatprovides, NULL},
    { SWIG_prefix "Pool_id2solvable", (swig_wrapper_func) _wrap_Pool_id2solvable, NULL},
    { SWIG_prefix "Pool_solvables_get", (swig_wrapper_func) _wrap_Pool_solvables_get, NULL},
    { SWIG_prefix "Pool_solvables_iter", (swig_wrapper_func) _wrap_Pool_solvables_iter, NULL},
    { SWIG_prefix "Pool_id2repo", (swig_wrapper_func) _wrap_Pool_id2repo, NULL},
    { SWIG_prefix "Pool_repos_get", (swig_wrapper_func) _wrap_Pool_repos_get, NULL},
    { SWIG_prefix "Pool_repos_iter", (swig_wrapper_func) _wrap_Pool_repos_iter, NULL},
    { SWIG_prefix "Pool_installed_set", (swig_wrapper_func) _wrap_Pool_installed_set, NULL},
    { SWIG_prefix "Pool_installed_get", (swig_wrapper_func) _wrap_Pool_installed_get, NULL},
    { SWIG_prefix "Pool_errstr_get", (swig_wrapper_func) _wrap_Pool_errstr_get, NULL},
    { SWIG_prefix "Pool_matchprovidingids", (swig_wrapper_func) _wrap_Pool_matchprovidingids, NULL},
    { SWIG_prefix "Pool_Job", (swig_wrapper_func) _wrap_Pool_Job, NULL},
    { SWIG_prefix "Pool_whatprovides", (swig_wrapper_func) _wrap_Pool_whatprovides, NULL},
    { SWIG_prefix "Pool_towhatprovides", (swig_wrapper_func) _wrap_Pool_towhatprovides, NULL},
    { SWIG_prefix "Pool_whatmatchesdep", (swig_wrapper_func) _wrap_Pool_whatmatchesdep, NULL},
    { SWIG_prefix "Pool_isknownarch", (swig_wrapper_func) _wrap_Pool_isknownarch, NULL},
    { SWIG_prefix "Pool_Solver", (swig_wrapper_func) _wrap_Pool_Solver, NULL},
    { SWIG_prefix "Pool_Selection", (swig_wrapper_func) _wrap_Pool_Selection, NULL},
    { SWIG_prefix "Pool_Selection_all", (swig_wrapper_func) _wrap_Pool_Selection_all, NULL},
    { SWIG_prefix "Pool_select", (swig_wrapper_func) _wrap_Pool_select, NULL},
    { SWIG_prefix "Pool_setpooljobs_helper", (swig_wrapper_func) _wrap_Pool_setpooljobs_helper, NULL},
    { SWIG_prefix "Pool_getpooljobs", (swig_wrapper_func) _wrap_Pool_getpooljobs, NULL},
    { SWIG_prefix "Pool", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Pool},
    { SWIG_prefix "Repo_pool_get", (swig_wrapper_func) _wrap_Repo_pool_get, NULL},
    { SWIG_prefix "Repo_name_get", (swig_wrapper_func) _wrap_Repo_name_get, NULL},
    { SWIG_prefix "Repo_priority_set", (swig_wrapper_func) _wrap_Repo_priority_set, NULL},
    { SWIG_prefix "Repo_priority_get", (swig_wrapper_func) _wrap_Repo_priority_get, NULL},
    { SWIG_prefix "Repo_subpriority_set", (swig_wrapper_func) _wrap_Repo_subpriority_set, NULL},
    { SWIG_prefix "Repo_subpriority_get", (swig_wrapper_func) _wrap_Repo_subpriority_get, NULL},
    { SWIG_prefix "Repo_nsolvables_get", (swig_wrapper_func) _wrap_Repo_nsolvables_get, NULL},
    { SWIG_prefix "Repo_appdata_set", (swig_wrapper_func) _wrap_Repo_appdata_set, NULL},
    { SWIG_prefix "Repo_appdata_get", (swig_wrapper_func) _wrap_Repo_appdata_get, NULL},
    { SWIG_prefix "Repo_free", (swig_wrapper_func) _wrap_Repo_free, NULL},
    { SWIG_prefix "Repo_empty", (swig_wrapper_func) _wrap_Repo_empty, NULL},
    { SWIG_prefix "Repo_isempty", (swig_wrapper_func) _wrap_Repo_isempty, NULL},
    { SWIG_prefix "Repo_add_solv", (swig_wrapper_func) _wrap_Repo_add_solv, NULL},
    { SWIG_prefix "Repo_add_solvable", (swig_wrapper_func) _wrap_Repo_add_solvable, NULL},
    { SWIG_prefix "Repo_internalize", (swig_wrapper_func) _wrap_Repo_internalize, NULL},
    { SWIG_prefix "Repo_write", (swig_wrapper_func) _wrap_Repo_write, NULL},
    { SWIG_prefix "Repo_write_first_repodata", (swig_wrapper_func) _wrap_Repo_write_first_repodata, NULL},
    { SWIG_prefix "Repo_Dataiterator", (swig_wrapper_func) _wrap_Repo_Dataiterator, NULL},
    { SWIG_prefix "Repo_Dataiterator_meta", (swig_wrapper_func) _wrap_Repo_Dataiterator_meta, NULL},
    { SWIG_prefix "Repo_id_get", (swig_wrapper_func) _wrap_Repo_id_get, NULL},
    { SWIG_prefix "Repo_solvables_get", (swig_wrapper_func) _wrap_Repo_solvables_get, NULL},
    { SWIG_prefix "Repo_meta_get", (swig_wrapper_func) _wrap_Repo_meta_get, NULL},
    { SWIG_prefix "Repo_solvables_iter", (swig_wrapper_func) _wrap_Repo_solvables_iter, NULL},
    { SWIG_prefix "Repo_add_repodata", (swig_wrapper_func) _wrap_Repo_add_repodata, NULL},
    { SWIG_prefix "Repo_create_stubs", (swig_wrapper_func) _wrap_Repo_create_stubs, NULL},
    { SWIG_prefix "Repo_iscontiguous", (swig_wrapper_func) _wrap_Repo_iscontiguous, NULL},
    { SWIG_prefix "Repo_first_repodata", (swig_wrapper_func) _wrap_Repo_first_repodata, NULL},
    { SWIG_prefix "Repo_Selection", (swig_wrapper_func) _wrap_Repo_Selection, NULL},
    { SWIG_prefix "Repo___eq__", (swig_wrapper_func) _wrap_Repo___eq__, NULL},
    { SWIG_prefix "Repo___ne__", (swig_wrapper_func) _wrap_Repo___ne__, NULL},
    { SWIG_prefix "Repo___str__", (swig_wrapper_func) _wrap_Repo___str__, NULL},
    { SWIG_prefix "Repo___repr__", (swig_wrapper_func) _wrap_Repo___repr__, NULL},
    { SWIG_prefix "Repo", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Repo},
    { SWIG_prefix "Solver_pool_get", (swig_wrapper_func) _wrap_Solver_pool_get, NULL},
    { SWIG_prefix "delete_Solver", (swig_wrapper_func) _wrap_delete_Solver, NULL},
    { SWIG_prefix "Solver_set_flag", (swig_wrapper_func) _wrap_Solver_set_flag, NULL},
    { SWIG_prefix "Solver_get_flag", (swig_wrapper_func) _wrap_Solver_get_flag, NULL},
    { SWIG_prefix "Solver_solve_helper", (swig_wrapper_func) _wrap_Solver_solve_helper, NULL},
    { SWIG_prefix "Solver_transaction", (swig_wrapper_func) _wrap_Solver_transaction, NULL},
    { SWIG_prefix "Solver_describe_decision", (swig_wrapper_func) _wrap_Solver_describe_decision, NULL},
    { SWIG_prefix "Solver_alternatives_count", (swig_wrapper_func) _wrap_Solver_alternatives_count, NULL},
    { SWIG_prefix "Solver_alternative", (swig_wrapper_func) _wrap_Solver_alternative, NULL},
    { SWIG_prefix "Solver_all_alternatives", (swig_wrapper_func) _wrap_Solver_all_alternatives, NULL},
    { SWIG_prefix "Solver", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Solver},
    { SWIG_prefix "new_Chksum", (swig_wrapper_func) _wrap_new_Chksum, NULL},
    { SWIG_prefix "delete_Chksum", (swig_wrapper_func) _wrap_delete_Chksum, NULL},
    { SWIG_prefix "Chksum_type_get", (swig_wrapper_func) _wrap_Chksum_type_get, NULL},
    { SWIG_prefix "Chksum_add", (swig_wrapper_func) _wrap_Chksum_add, NULL},
    { SWIG_prefix "Chksum_add_fp", (swig_wrapper_func) _wrap_Chksum_add_fp, NULL},
    { SWIG_prefix "Chksum_add_fd", (swig_wrapper_func) _wrap_Chksum_add_fd, NULL},
    { SWIG_prefix "Chksum_add_stat", (swig_wrapper_func) _wrap_Chksum_add_stat, NULL},
    { SWIG_prefix "Chksum_add_fstat", (swig_wrapper_func) _wrap_Chksum_add_fstat, NULL},
    { SWIG_prefix "Chksum_raw", (swig_wrapper_func) _wrap_Chksum_raw, NULL},
    { SWIG_prefix "Chksum_hex", (swig_wrapper_func) _wrap_Chksum_hex, NULL},
    { SWIG_prefix "Chksum_typestr", (swig_wrapper_func) _wrap_Chksum_typestr, NULL},
    { SWIG_prefix "Chksum___eq__", (swig_wrapper_func) _wrap_Chksum___eq__, NULL},
    { SWIG_prefix "Chksum___ne__", (swig_wrapper_func) _wrap_Chksum___ne__, NULL},
    { SWIG_prefix "Chksum___str__", (swig_wrapper_func) _wrap_Chksum___str__, NULL},
    { SWIG_prefix "Chksum___repr__", (swig_wrapper_func) _wrap_Chksum___repr__, NULL},
    { SWIG_prefix "Chksum", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Chksum},
    { SWIG_prefix "delete_SolvFp", (swig_wrapper_func) _wrap_delete_SolvFp, NULL},
    { SWIG_prefix "SolvFp_fileno", (swig_wrapper_func) _wrap_SolvFp_fileno, NULL},
    { SWIG_prefix "SolvFp_dup", (swig_wrapper_func) _wrap_SolvFp_dup, NULL},
    { SWIG_prefix "SolvFp_flush", (swig_wrapper_func) _wrap_SolvFp_flush, NULL},
    { SWIG_prefix "SolvFp_close", (swig_wrapper_func) _wrap_SolvFp_close, NULL},
    { SWIG_prefix "SolvFp", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_SolvFp},
    { SWIG_prefix "xfopen", (swig_wrapper_func) _wrap_xfopen, NULL},
    { SWIG_prefix "xfopen_fd", (swig_wrapper_func) _wrap_xfopen_fd, NULL},
    { SWIG_prefix "Problem_solv_get", (swig_wrapper_func) _wrap_Problem_solv_get, NULL},
    { SWIG_prefix "Problem_id_get", (swig_wrapper_func) _wrap_Problem_id_get, NULL},
    { SWIG_prefix "new_Problem", (swig_wrapper_func) _wrap_new_Problem, NULL},
    { SWIG_prefix "Problem_findproblemrule", (swig_wrapper_func) _wrap_Problem_findproblemrule, NULL},
    { SWIG_prefix "Problem_findallproblemrules", (swig_wrapper_func) _wrap_Problem_findallproblemrules, NULL},
    { SWIG_prefix "Problem_solution_count", (swig_wrapper_func) _wrap_Problem_solution_count, NULL},
    { SWIG_prefix "Problem_solutions", (swig_wrapper_func) _wrap_Problem_solutions, NULL},
    { SWIG_prefix "Problem___str__", (swig_wrapper_func) _wrap_Problem___str__, NULL},
    { SWIG_prefix "delete_Problem", (swig_wrapper_func) _wrap_delete_Problem, NULL},
    { SWIG_prefix "Problem", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Problem},
    { SWIG_prefix "Solution_solv_get", (swig_wrapper_func) _wrap_Solution_solv_get, NULL},
    { SWIG_prefix "Solution_problemid_get", (swig_wrapper_func) _wrap_Solution_problemid_get, NULL},
    { SWIG_prefix "Solution_id_get", (swig_wrapper_func) _wrap_Solution_id_get, NULL},
    { SWIG_prefix "new_Solution", (swig_wrapper_func) _wrap_new_Solution, NULL},
    { SWIG_prefix "Solution_element_count", (swig_wrapper_func) _wrap_Solution_element_count, NULL},
    { SWIG_prefix "Solution_elements", (swig_wrapper_func) _wrap_Solution_elements, NULL},
    { SWIG_prefix "delete_Solution", (swig_wrapper_func) _wrap_delete_Solution, NULL},
    { SWIG_prefix "Solution", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Solution},
    { SWIG_prefix "Solutionelement_solv_get", (swig_wrapper_func) _wrap_Solutionelement_solv_get, NULL},
    { SWIG_prefix "Solutionelement_problemid_get", (swig_wrapper_func) _wrap_Solutionelement_problemid_get, NULL},
    { SWIG_prefix "Solutionelement_solutionid_get", (swig_wrapper_func) _wrap_Solutionelement_solutionid_get, NULL},
    { SWIG_prefix "Solutionelement_id_get", (swig_wrapper_func) _wrap_Solutionelement_id_get, NULL},
    { SWIG_prefix "Solutionelement_type_get", (swig_wrapper_func) _wrap_Solutionelement_type_get, NULL},
    { SWIG_prefix "new_Solutionelement", (swig_wrapper_func) _wrap_new_Solutionelement, NULL},
    { SWIG_prefix "Solutionelement_str", (swig_wrapper_func) _wrap_Solutionelement_str, NULL},
    { SWIG_prefix "Solutionelement_replaceelements", (swig_wrapper_func) _wrap_Solutionelement_replaceelements, NULL},
    { SWIG_prefix "Solutionelement_illegalreplace", (swig_wrapper_func) _wrap_Solutionelement_illegalreplace, NULL},
    { SWIG_prefix "Solutionelement_solvable_get", (swig_wrapper_func) _wrap_Solutionelement_solvable_get, NULL},
    { SWIG_prefix "Solutionelement_replacement_get", (swig_wrapper_func) _wrap_Solutionelement_replacement_get, NULL},
    { SWIG_prefix "Solutionelement_jobidx_get", (swig_wrapper_func) _wrap_Solutionelement_jobidx_get, NULL},
    { SWIG_prefix "Solutionelement_Job", (swig_wrapper_func) _wrap_Solutionelement_Job, NULL},
    { SWIG_prefix "delete_Solutionelement", (swig_wrapper_func) _wrap_delete_Solutionelement, NULL},
    { SWIG_prefix "Solutionelement", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Solutionelement},
    { SWIG_prefix "Alternative_solv_get", (swig_wrapper_func) _wrap_Alternative_solv_get, NULL},
    { SWIG_prefix "Alternative_type_get", (swig_wrapper_func) _wrap_Alternative_type_get, NULL},
    { SWIG_prefix "Alternative_rid_get", (swig_wrapper_func) _wrap_Alternative_rid_get, NULL},
    { SWIG_prefix "Alternative_from_id_get", (swig_wrapper_func) _wrap_Alternative_from_id_get, NULL},
    { SWIG_prefix "Alternative_dep_id_get", (swig_wrapper_func) _wrap_Alternative_dep_id_get, NULL},
    { SWIG_prefix "Alternative_chosen_id_get", (swig_wrapper_func) _wrap_Alternative_chosen_id_get, NULL},
    { SWIG_prefix "Alternative_level_set", (swig_wrapper_func) _wrap_Alternative_level_set, NULL},
    { SWIG_prefix "Alternative_level_get", (swig_wrapper_func) _wrap_Alternative_level_get, NULL},
    { SWIG_prefix "delete_Alternative", (swig_wrapper_func) _wrap_delete_Alternative, NULL},
    { SWIG_prefix "Alternative_chosen_get", (swig_wrapper_func) _wrap_Alternative_chosen_get, NULL},
    { SWIG_prefix "Alternative_rule_get", (swig_wrapper_func) _wrap_Alternative_rule_get, NULL},
    { SWIG_prefix "Alternative_depsolvable_get", (swig_wrapper_func) _wrap_Alternative_depsolvable_get, NULL},
    { SWIG_prefix "Alternative_dep_get", (swig_wrapper_func) _wrap_Alternative_dep_get, NULL},
    { SWIG_prefix "Alternative_choices_raw", (swig_wrapper_func) _wrap_Alternative_choices_raw, NULL},
    { SWIG_prefix "Alternative_choices", (swig_wrapper_func) _wrap_Alternative_choices, NULL},
    { SWIG_prefix "Alternative___str__", (swig_wrapper_func) _wrap_Alternative___str__, NULL},
    { SWIG_prefix "Alternative", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Alternative},
    { SWIG_prefix "Transaction_pool_get", (swig_wrapper_func) _wrap_Transaction_pool_get, NULL},
    { SWIG_prefix "delete_Transaction", (swig_wrapper_func) _wrap_delete_Transaction, NULL},
    { SWIG_prefix "Transaction_isempty", (swig_wrapper_func) _wrap_Transaction_isempty, NULL},
    { SWIG_prefix "Transaction_othersolvable", (swig_wrapper_func) _wrap_Transaction_othersolvable, NULL},
    { SWIG_prefix "Transaction_allothersolvables", (swig_wrapper_func) _wrap_Transaction_allothersolvables, NULL},
    { SWIG_prefix "Transaction_classify", (swig_wrapper_func) _wrap_Transaction_classify, NULL},
    { SWIG_prefix "Transaction_newpackages", (swig_wrapper_func) _wrap_Transaction_newpackages, NULL},
    { SWIG_prefix "Transaction_keptpackages", (swig_wrapper_func) _wrap_Transaction_keptpackages, NULL},
    { SWIG_prefix "Transaction_newsolvables", (swig_wrapper_func) _wrap_Transaction_newsolvables, NULL},
    { SWIG_prefix "Transaction_keptsolvables", (swig_wrapper_func) _wrap_Transaction_keptsolvables, NULL},
    { SWIG_prefix "Transaction_steps", (swig_wrapper_func) _wrap_Transaction_steps, NULL},
    { SWIG_prefix "Transaction_steptype", (swig_wrapper_func) _wrap_Transaction_steptype, NULL},
    { SWIG_prefix "Transaction_calc_installsizechange", (swig_wrapper_func) _wrap_Transaction_calc_installsizechange, NULL},
    { SWIG_prefix "Transaction_order", (swig_wrapper_func) _wrap_Transaction_order, NULL},
    { SWIG_prefix "Transaction", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Transaction},
    { SWIG_prefix "TransactionClass_transaction_get", (swig_wrapper_func) _wrap_TransactionClass_transaction_get, NULL},
    { SWIG_prefix "TransactionClass_type_get", (swig_wrapper_func) _wrap_TransactionClass_type_get, NULL},
    { SWIG_prefix "TransactionClass_fromid_get", (swig_wrapper_func) _wrap_TransactionClass_fromid_get, NULL},
    { SWIG_prefix "TransactionClass_toid_get", (swig_wrapper_func) _wrap_TransactionClass_toid_get, NULL},
    { SWIG_prefix "TransactionClass_count_get", (swig_wrapper_func) _wrap_TransactionClass_count_get, NULL},
    { SWIG_prefix "new_TransactionClass", (swig_wrapper_func) _wrap_new_TransactionClass, NULL},
    { SWIG_prefix "TransactionClass_solvables", (swig_wrapper_func) _wrap_TransactionClass_solvables, NULL},
    { SWIG_prefix "TransactionClass_fromstr_get", (swig_wrapper_func) _wrap_TransactionClass_fromstr_get, NULL},
    { SWIG_prefix "TransactionClass_tostr_get", (swig_wrapper_func) _wrap_TransactionClass_tostr_get, NULL},
    { SWIG_prefix "delete_TransactionClass", (swig_wrapper_func) _wrap_delete_TransactionClass, NULL},
    { SWIG_prefix "TransactionClass", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_TransactionClass},
    {0, 0, 0}
};

static swig_var_info swig_variables[] = {
    {0,0,0,0}
};

static swig_const_info swig_constants[] = {
    {0,0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Alternative = {"_p_Alternative", "Alternative *", 0, 0, (void*)&_wrap_class_Alternative, 0};
static swig_type_info _swigt__p_Chksum = {"_p_Chksum", "Chksum *", 0, 0, (void*)&_wrap_class_Chksum, 0};
static swig_type_info _swigt__p_Dataiterator = {"_p_Dataiterator", "Dataiterator *", 0, 0, (void*)&_wrap_class_Dataiterator, 0};
static swig_type_info _swigt__p_Datamatch = {"_p_Datamatch", "Datamatch *", 0, 0, (void*)&_wrap_class_Datamatch, 0};
static swig_type_info _swigt__p_Datapos = {"_p_Datapos", "Datapos *", 0, 0, (void*)&_wrap_class_Datapos, 0};
static swig_type_info _swigt__p_Dep = {"_p_Dep", "Dep *", 0, 0, (void*)&_wrap_class_Dep, 0};
static swig_type_info _swigt__p_Job = {"_p_Job", "Job *", 0, 0, (void*)&_wrap_class_Job, 0};
static swig_type_info _swigt__p_Pool = {"_p_Pool", "Pool *", 0, 0, (void*)&_wrap_class_Pool, 0};
static swig_type_info _swigt__p_Pool_repo_iterator = {"_p_Pool_repo_iterator", "Pool_repo_iterator *", 0, 0, (void*)&_wrap_class_Pool_repo_iterator, 0};
static swig_type_info _swigt__p_Pool_solvable_iterator = {"_p_Pool_solvable_iterator", "Pool_solvable_iterator *", 0, 0, (void*)&_wrap_class_Pool_solvable_iterator, 0};
static swig_type_info _swigt__p_Problem = {"_p_Problem", "Problem *", 0, 0, (void*)&_wrap_class_Problem, 0};
static swig_type_info _swigt__p_Queue = {"_p_Queue", "Queue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Repo = {"_p_Repo", "Repo *", 0, 0, (void*)&_wrap_class_Repo, 0};
static swig_type_info _swigt__p_Repo_solvable_iterator = {"_p_Repo_solvable_iterator", "Repo_solvable_iterator *", 0, 0, (void*)&_wrap_class_Repo_solvable_iterator, 0};
static swig_type_info _swigt__p_Ruleinfo = {"_p_Ruleinfo", "Ruleinfo *", 0, 0, (void*)&_wrap_class_Ruleinfo, 0};
static swig_type_info _swigt__p_Selection = {"_p_Selection", "Selection *", 0, 0, (void*)&_wrap_class_Selection, 0};
static swig_type_info _swigt__p_Solution = {"_p_Solution", "Solution *", 0, 0, (void*)&_wrap_class_Solution, 0};
static swig_type_info _swigt__p_Solutionelement = {"_p_Solutionelement", "Solutionelement *", 0, 0, (void*)&_wrap_class_Solutionelement, 0};
static swig_type_info _swigt__p_SolvFp = {"_p_SolvFp", "SolvFp *", 0, 0, (void*)&_wrap_class_SolvFp, 0};
static swig_type_info _swigt__p_Solver = {"_p_Solver", "Solver *", 0, 0, (void*)&_wrap_class_Solver, 0};
static swig_type_info _swigt__p_TclObj = {"_p_TclObj", "TclObj *|AppObjectPtr", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Tcl_Interp = {"_p_Tcl_Interp", "Tcl_Interp *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Transaction = {"_p_Transaction", "Transaction *", 0, 0, (void*)&_wrap_class_Transaction, 0};
static swig_type_info _swigt__p_TransactionClass = {"_p_TransactionClass", "TransactionClass *", 0, 0, (void*)&_wrap_class_TransactionClass, 0};
static swig_type_info _swigt__p_XRepodata = {"_p_XRepodata", "XRepodata *", 0, 0, (void*)&_wrap_class_XRepodata, 0};
static swig_type_info _swigt__p_XRule = {"_p_XRule", "XRule *", 0, 0, (void*)&_wrap_class_XRule, 0};
static swig_type_info _swigt__p_XSolvable = {"_p_XSolvable", "XSolvable *", 0, 0, (void*)&_wrap_class_XSolvable, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *|Id *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_XRule = {"_p_p_XRule", "XRule **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "unsigned int *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Alternative,
  &_swigt__p_Chksum,
  &_swigt__p_Dataiterator,
  &_swigt__p_Datamatch,
  &_swigt__p_Datapos,
  &_swigt__p_Dep,
  &_swigt__p_Job,
  &_swigt__p_Pool,
  &_swigt__p_Pool_repo_iterator,
  &_swigt__p_Pool_solvable_iterator,
  &_swigt__p_Problem,
  &_swigt__p_Queue,
  &_swigt__p_Repo,
  &_swigt__p_Repo_solvable_iterator,
  &_swigt__p_Ruleinfo,
  &_swigt__p_Selection,
  &_swigt__p_Solution,
  &_swigt__p_Solutionelement,
  &_swigt__p_SolvFp,
  &_swigt__p_Solver,
  &_swigt__p_TclObj,
  &_swigt__p_Tcl_Interp,
  &_swigt__p_Transaction,
  &_swigt__p_TransactionClass,
  &_swigt__p_XRepodata,
  &_swigt__p_XRule,
  &_swigt__p_XSolvable,
  &_swigt__p_char,
  &_swigt__p_int,
  &_swigt__p_p_XRule,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
};

static swig_cast_info _swigc__p_Alternative[] = {  {&_swigt__p_Alternative, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Chksum[] = {  {&_swigt__p_Chksum, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Dataiterator[] = {  {&_swigt__p_Dataiterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Datamatch[] = {  {&_swigt__p_Datamatch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Datapos[] = {  {&_swigt__p_Datapos, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Dep[] = {  {&_swigt__p_Dep, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Job[] = {  {&_swigt__p_Job, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Pool[] = {  {&_swigt__p_Pool, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Pool_repo_iterator[] = {  {&_swigt__p_Pool_repo_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Pool_solvable_iterator[] = {  {&_swigt__p_Pool_solvable_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Problem[] = {  {&_swigt__p_Problem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Queue[] = {  {&_swigt__p_Queue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Repo[] = {  {&_swigt__p_Repo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Repo_solvable_iterator[] = {  {&_swigt__p_Repo_solvable_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Ruleinfo[] = {  {&_swigt__p_Ruleinfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Selection[] = {  {&_swigt__p_Selection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Solution[] = {  {&_swigt__p_Solution, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Solutionelement[] = {  {&_swigt__p_Solutionelement, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SolvFp[] = {  {&_swigt__p_SolvFp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Solver[] = {  {&_swigt__p_Solver, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TclObj[] = {  {&_swigt__p_TclObj, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Tcl_Interp[] = {  {&_swigt__p_Tcl_Interp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Transaction[] = {  {&_swigt__p_Transaction, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TransactionClass[] = {  {&_swigt__p_TransactionClass, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XRepodata[] = {  {&_swigt__p_XRepodata, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XRule[] = {  {&_swigt__p_XRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XSolvable[] = {  {&_swigt__p_XSolvable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_XRule[] = {  {&_swigt__p_p_XRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Alternative,
  _swigc__p_Chksum,
  _swigc__p_Dataiterator,
  _swigc__p_Datamatch,
  _swigc__p_Datapos,
  _swigc__p_Dep,
  _swigc__p_Job,
  _swigc__p_Pool,
  _swigc__p_Pool_repo_iterator,
  _swigc__p_Pool_solvable_iterator,
  _swigc__p_Problem,
  _swigc__p_Queue,
  _swigc__p_Repo,
  _swigc__p_Repo_solvable_iterator,
  _swigc__p_Ruleinfo,
  _swigc__p_Selection,
  _swigc__p_Solution,
  _swigc__p_Solutionelement,
  _swigc__p_SolvFp,
  _swigc__p_Solver,
  _swigc__p_TclObj,
  _swigc__p_Tcl_Interp,
  _swigc__p_Transaction,
  _swigc__p_TransactionClass,
  _swigc__p_XRepodata,
  _swigc__p_XRule,
  _swigc__p_XSolvable,
  _swigc__p_char,
  _swigc__p_int,
  _swigc__p_p_XRule,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  
  SWIGINTERN void
  SWIG_Tcl_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
    size_t i;
    Tcl_Obj *obj;
    
    if (!swigconstTableinit) {
      Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
      swigconstTableinit = 1;
    }
    for (i = 0; constants[i].type; i++) {
      switch(constants[i].type) {
      case SWIG_TCL_POINTER:
        obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_TCL_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        SWIG_Tcl_SetConstantObj(interp, constants[i].name, obj);
      }
    }
  }
  
  /* Create fast method lookup tables */
  
  SWIGINTERN void
  SWIG_Tcl_InstallMethodLookupTables(void) {
    size_t i;
    
    for (i = 0; i < swig_module.size; ++i) {
      swig_type_info *type = swig_module.type_initial[i];
      if (type->clientdata) {
        swig_class* klass = (swig_class*) type->clientdata;
        swig_method* meth;
        Tcl_InitHashTable(&(klass->hashtable), TCL_STRING_KEYS);
        for (meth = klass->methods; meth && meth->name; ++meth) {
          int newEntry;
          Tcl_HashEntry* hashentry = Tcl_CreateHashEntry(&(klass->hashtable), meth->name, &newEntry);
          Tcl_SetHashValue(hashentry, (ClientData)meth->method);
        }
      }
    }
  }
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

SWIGEXPORT int SWIG_init(Tcl_Interp *interp) {
  size_t i;
  if (interp == 0) return TCL_ERROR;
#ifdef USE_TCL_STUBS
  /* (char*) cast is required to avoid compiler warning/error for Tcl < 8.4. */
  if (Tcl_InitStubs(interp, (char*)SWIG_TCL_STUBS_VERSION, 0) == NULL) {
    return TCL_ERROR;
  }
#endif  
#ifdef USE_TK_STUBS
  /* (char*) cast is required to avoid compiler warning/error. */
  if (Tk_InitStubs(interp, (char*)SWIG_TCL_STUBS_VERSION, 0) == NULL) {
    return TCL_ERROR;
  }
#endif
  
  Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
  
#ifdef SWIG_namespace
  Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
#endif
  
  SWIG_InitializeModule((void *) interp);
  SWIG_PropagateClientData();
  
  for (i = 0; swig_commands[i].name; i++) {
    Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper,
      swig_commands[i].clientdata, NULL);
  }
  for (i = 0; swig_variables[i].name; i++) {
    Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
    Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, 
      (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
    Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, 
      (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
  }
  
  SWIG_Tcl_InstallConstants(interp, swig_constants);
  SWIG_Tcl_InstallMethodLookupTables();
  
  
  SWIG_Tcl_SetConstantObj(interp, "solv::ID_NULL", SWIG_From_int((int)(ID_NULL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::ID_EMPTY", SWIG_From_int((int)(ID_EMPTY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_NAME", SWIG_From_int((int)(SOLVABLE_NAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_ARCH", SWIG_From_int((int)(SOLVABLE_ARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_EVR", SWIG_From_int((int)(SOLVABLE_EVR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_VENDOR", SWIG_From_int((int)(SOLVABLE_VENDOR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_PROVIDES", SWIG_From_int((int)(SOLVABLE_PROVIDES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_OBSOLETES", SWIG_From_int((int)(SOLVABLE_OBSOLETES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_CONFLICTS", SWIG_From_int((int)(SOLVABLE_CONFLICTS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_REQUIRES", SWIG_From_int((int)(SOLVABLE_REQUIRES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_RECOMMENDS", SWIG_From_int((int)(SOLVABLE_RECOMMENDS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_SUGGESTS", SWIG_From_int((int)(SOLVABLE_SUGGESTS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_SUPPLEMENTS", SWIG_From_int((int)(SOLVABLE_SUPPLEMENTS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_ENHANCES", SWIG_From_int((int)(SOLVABLE_ENHANCES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::RPM_RPMDBID", SWIG_From_int((int)(RPM_RPMDBID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_PREREQMARKER", SWIG_From_int((int)(SOLVABLE_PREREQMARKER)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_FILEMARKER", SWIG_From_int((int)(SOLVABLE_FILEMARKER)));
  SWIG_Tcl_SetConstantObj(interp, "solv::NAMESPACE_INSTALLED", SWIG_From_int((int)(NAMESPACE_INSTALLED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::NAMESPACE_MODALIAS", SWIG_From_int((int)(NAMESPACE_MODALIAS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::NAMESPACE_SPLITPROVIDES", SWIG_From_int((int)(NAMESPACE_SPLITPROVIDES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::NAMESPACE_LANGUAGE", SWIG_From_int((int)(NAMESPACE_LANGUAGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::NAMESPACE_FILESYSTEM", SWIG_From_int((int)(NAMESPACE_FILESYSTEM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::NAMESPACE_OTHERPROVIDERS", SWIG_From_int((int)(NAMESPACE_OTHERPROVIDERS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SYSTEM_SYSTEM", SWIG_From_int((int)(SYSTEM_SYSTEM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::ARCH_SRC", SWIG_From_int((int)(ARCH_SRC)));
  SWIG_Tcl_SetConstantObj(interp, "solv::ARCH_NOSRC", SWIG_From_int((int)(ARCH_NOSRC)));
  SWIG_Tcl_SetConstantObj(interp, "solv::ARCH_NOARCH", SWIG_From_int((int)(ARCH_NOARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::ARCH_ALL", SWIG_From_int((int)(ARCH_ALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::ARCH_ANY", SWIG_From_int((int)(ARCH_ANY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_SOLVABLES", SWIG_From_int((int)(REPOSITORY_SOLVABLES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_DELTAINFO", SWIG_From_int((int)(REPOSITORY_DELTAINFO)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_EXTERNAL", SWIG_From_int((int)(REPOSITORY_EXTERNAL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_KEYS", SWIG_From_int((int)(REPOSITORY_KEYS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_LOCATION", SWIG_From_int((int)(REPOSITORY_LOCATION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_ADDEDFILEPROVIDES", SWIG_From_int((int)(REPOSITORY_ADDEDFILEPROVIDES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_RPMDBCOOKIE", SWIG_From_int((int)(REPOSITORY_RPMDBCOOKIE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_VOID", SWIG_From_int((int)(REPOKEY_TYPE_VOID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_CONSTANT", SWIG_From_int((int)(REPOKEY_TYPE_CONSTANT)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_CONSTANTID", SWIG_From_int((int)(REPOKEY_TYPE_CONSTANTID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_ID", SWIG_From_int((int)(REPOKEY_TYPE_ID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_NUM", SWIG_From_int((int)(REPOKEY_TYPE_NUM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_U32", SWIG_From_int((int)(REPOKEY_TYPE_U32)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_DIR", SWIG_From_int((int)(REPOKEY_TYPE_DIR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_STR", SWIG_From_int((int)(REPOKEY_TYPE_STR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_BINARY", SWIG_From_int((int)(REPOKEY_TYPE_BINARY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_IDARRAY", SWIG_From_int((int)(REPOKEY_TYPE_IDARRAY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_REL_IDARRAY", SWIG_From_int((int)(REPOKEY_TYPE_REL_IDARRAY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_DIRSTRARRAY", SWIG_From_int((int)(REPOKEY_TYPE_DIRSTRARRAY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_DIRNUMNUMARRAY", SWIG_From_int((int)(REPOKEY_TYPE_DIRNUMNUMARRAY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_MD5", SWIG_From_int((int)(REPOKEY_TYPE_MD5)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_SHA1", SWIG_From_int((int)(REPOKEY_TYPE_SHA1)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_SHA224", SWIG_From_int((int)(REPOKEY_TYPE_SHA224)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_SHA256", SWIG_From_int((int)(REPOKEY_TYPE_SHA256)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_SHA384", SWIG_From_int((int)(REPOKEY_TYPE_SHA384)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_SHA512", SWIG_From_int((int)(REPOKEY_TYPE_SHA512)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_FIXARRAY", SWIG_From_int((int)(REPOKEY_TYPE_FIXARRAY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_FLEXARRAY", SWIG_From_int((int)(REPOKEY_TYPE_FLEXARRAY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOKEY_TYPE_DELETED", SWIG_From_int((int)(REPOKEY_TYPE_DELETED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_SUMMARY", SWIG_From_int((int)(SOLVABLE_SUMMARY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_DESCRIPTION", SWIG_From_int((int)(SOLVABLE_DESCRIPTION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_DISTRIBUTION", SWIG_From_int((int)(SOLVABLE_DISTRIBUTION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_AUTHORS", SWIG_From_int((int)(SOLVABLE_AUTHORS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_PACKAGER", SWIG_From_int((int)(SOLVABLE_PACKAGER)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_GROUP", SWIG_From_int((int)(SOLVABLE_GROUP)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_URL", SWIG_From_int((int)(SOLVABLE_URL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_KEYWORDS", SWIG_From_int((int)(SOLVABLE_KEYWORDS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_LICENSE", SWIG_From_int((int)(SOLVABLE_LICENSE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_BUILDTIME", SWIG_From_int((int)(SOLVABLE_BUILDTIME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_BUILDHOST", SWIG_From_int((int)(SOLVABLE_BUILDHOST)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_EULA", SWIG_From_int((int)(SOLVABLE_EULA)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_CPEID", SWIG_From_int((int)(SOLVABLE_CPEID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_MESSAGEINS", SWIG_From_int((int)(SOLVABLE_MESSAGEINS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_MESSAGEDEL", SWIG_From_int((int)(SOLVABLE_MESSAGEDEL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_INSTALLSIZE", SWIG_From_int((int)(SOLVABLE_INSTALLSIZE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_DISKUSAGE", SWIG_From_int((int)(SOLVABLE_DISKUSAGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_FILELIST", SWIG_From_int((int)(SOLVABLE_FILELIST)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_INSTALLTIME", SWIG_From_int((int)(SOLVABLE_INSTALLTIME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_MEDIADIR", SWIG_From_int((int)(SOLVABLE_MEDIADIR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_MEDIAFILE", SWIG_From_int((int)(SOLVABLE_MEDIAFILE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_MEDIANR", SWIG_From_int((int)(SOLVABLE_MEDIANR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_MEDIABASE", SWIG_From_int((int)(SOLVABLE_MEDIABASE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_DOWNLOADSIZE", SWIG_From_int((int)(SOLVABLE_DOWNLOADSIZE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_SOURCEARCH", SWIG_From_int((int)(SOLVABLE_SOURCEARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_SOURCENAME", SWIG_From_int((int)(SOLVABLE_SOURCENAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_SOURCEEVR", SWIG_From_int((int)(SOLVABLE_SOURCEEVR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_ISVISIBLE", SWIG_From_int((int)(SOLVABLE_ISVISIBLE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_TRIGGERS", SWIG_From_int((int)(SOLVABLE_TRIGGERS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_CHECKSUM", SWIG_From_int((int)(SOLVABLE_CHECKSUM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_PKGID", SWIG_From_int((int)(SOLVABLE_PKGID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_HDRID", SWIG_From_int((int)(SOLVABLE_HDRID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_LEADSIGID", SWIG_From_int((int)(SOLVABLE_LEADSIGID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_PATCHCATEGORY", SWIG_From_int((int)(SOLVABLE_PATCHCATEGORY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_HEADEREND", SWIG_From_int((int)(SOLVABLE_HEADEREND)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_CHANGELOG", SWIG_From_int((int)(SOLVABLE_CHANGELOG)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_CHANGELOG_AUTHOR", SWIG_From_int((int)(SOLVABLE_CHANGELOG_AUTHOR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_CHANGELOG_TIME", SWIG_From_int((int)(SOLVABLE_CHANGELOG_TIME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_CHANGELOG_TEXT", SWIG_From_int((int)(SOLVABLE_CHANGELOG_TEXT)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_CATEGORY", SWIG_From_int((int)(SOLVABLE_CATEGORY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_INCLUDES", SWIG_From_int((int)(SOLVABLE_INCLUDES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_EXTENDS", SWIG_From_int((int)(SOLVABLE_EXTENDS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_ICON", SWIG_From_int((int)(SOLVABLE_ICON)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_ORDER", SWIG_From_int((int)(SOLVABLE_ORDER)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_REBOOT", SWIG_From_int((int)(UPDATE_REBOOT)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_RESTART", SWIG_From_int((int)(UPDATE_RESTART)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_RELOGIN", SWIG_From_int((int)(UPDATE_RELOGIN)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_MESSAGE", SWIG_From_int((int)(UPDATE_MESSAGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_SEVERITY", SWIG_From_int((int)(UPDATE_SEVERITY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_RIGHTS", SWIG_From_int((int)(UPDATE_RIGHTS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_COLLECTION", SWIG_From_int((int)(UPDATE_COLLECTION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_COLLECTION_NAME", SWIG_From_int((int)(UPDATE_COLLECTION_NAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_COLLECTION_EVR", SWIG_From_int((int)(UPDATE_COLLECTION_EVR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_COLLECTION_ARCH", SWIG_From_int((int)(UPDATE_COLLECTION_ARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_COLLECTION_FILENAME", SWIG_From_int((int)(UPDATE_COLLECTION_FILENAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_COLLECTION_FLAGS", SWIG_From_int((int)(UPDATE_COLLECTION_FLAGS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_REFERENCE", SWIG_From_int((int)(UPDATE_REFERENCE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_REFERENCE_TYPE", SWIG_From_int((int)(UPDATE_REFERENCE_TYPE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_REFERENCE_HREF", SWIG_From_int((int)(UPDATE_REFERENCE_HREF)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_REFERENCE_ID", SWIG_From_int((int)(UPDATE_REFERENCE_ID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::UPDATE_REFERENCE_TITLE", SWIG_From_int((int)(UPDATE_REFERENCE_TITLE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_REFERENCEFILE", SWIG_From_int((int)(PRODUCT_REFERENCEFILE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_SHORTLABEL", SWIG_From_int((int)(PRODUCT_SHORTLABEL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_DISTPRODUCT", SWIG_From_int((int)(PRODUCT_DISTPRODUCT)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_DISTVERSION", SWIG_From_int((int)(PRODUCT_DISTVERSION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_TYPE", SWIG_From_int((int)(PRODUCT_TYPE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_URL", SWIG_From_int((int)(PRODUCT_URL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_URL_TYPE", SWIG_From_int((int)(PRODUCT_URL_TYPE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_FLAGS", SWIG_From_int((int)(PRODUCT_FLAGS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_PRODUCTLINE", SWIG_From_int((int)(PRODUCT_PRODUCTLINE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_REGISTER_TARGET", SWIG_From_int((int)(PRODUCT_REGISTER_TARGET)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_REGISTER_RELEASE", SWIG_From_int((int)(PRODUCT_REGISTER_RELEASE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_UPDATES_REPOID", SWIG_From_int((int)(PRODUCT_UPDATES_REPOID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_UPDATES", SWIG_From_int((int)(PRODUCT_UPDATES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_ENDOFLIFE", SWIG_From_int((int)(PRODUCT_ENDOFLIFE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SUSETAGS_DATADIR", SWIG_From_int((int)(SUSETAGS_DATADIR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SUSETAGS_DESCRDIR", SWIG_From_int((int)(SUSETAGS_DESCRDIR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SUSETAGS_DEFAULTVENDOR", SWIG_From_int((int)(SUSETAGS_DEFAULTVENDOR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SUSETAGS_FILE", SWIG_From_int((int)(SUSETAGS_FILE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SUSETAGS_FILE_NAME", SWIG_From_int((int)(SUSETAGS_FILE_NAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SUSETAGS_FILE_TYPE", SWIG_From_int((int)(SUSETAGS_FILE_TYPE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SUSETAGS_FILE_CHECKSUM", SWIG_From_int((int)(SUSETAGS_FILE_CHECKSUM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SUSETAGS_SHARE_NAME", SWIG_From_int((int)(SUSETAGS_SHARE_NAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SUSETAGS_SHARE_EVR", SWIG_From_int((int)(SUSETAGS_SHARE_EVR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SUSETAGS_SHARE_ARCH", SWIG_From_int((int)(SUSETAGS_SHARE_ARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_TIMESTAMP", SWIG_From_int((int)(REPOSITORY_TIMESTAMP)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_EXPIRE", SWIG_From_int((int)(REPOSITORY_EXPIRE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_UPDATES", SWIG_From_int((int)(REPOSITORY_UPDATES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_DISTROS", SWIG_From_int((int)(REPOSITORY_DISTROS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_PRODUCT_LABEL", SWIG_From_int((int)(REPOSITORY_PRODUCT_LABEL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_PRODUCT_CPEID", SWIG_From_int((int)(REPOSITORY_PRODUCT_CPEID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_REPOID", SWIG_From_int((int)(REPOSITORY_REPOID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_KEYWORDS", SWIG_From_int((int)(REPOSITORY_KEYWORDS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_REVISION", SWIG_From_int((int)(REPOSITORY_REVISION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_TOOLVERSION", SWIG_From_int((int)(REPOSITORY_TOOLVERSION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_PACKAGE_NAME", SWIG_From_int((int)(DELTA_PACKAGE_NAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_PACKAGE_EVR", SWIG_From_int((int)(DELTA_PACKAGE_EVR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_PACKAGE_ARCH", SWIG_From_int((int)(DELTA_PACKAGE_ARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_LOCATION_DIR", SWIG_From_int((int)(DELTA_LOCATION_DIR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_LOCATION_NAME", SWIG_From_int((int)(DELTA_LOCATION_NAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_LOCATION_EVR", SWIG_From_int((int)(DELTA_LOCATION_EVR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_LOCATION_SUFFIX", SWIG_From_int((int)(DELTA_LOCATION_SUFFIX)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_DOWNLOADSIZE", SWIG_From_int((int)(DELTA_DOWNLOADSIZE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_CHECKSUM", SWIG_From_int((int)(DELTA_CHECKSUM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_BASE_EVR", SWIG_From_int((int)(DELTA_BASE_EVR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_SEQ_NAME", SWIG_From_int((int)(DELTA_SEQ_NAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_SEQ_EVR", SWIG_From_int((int)(DELTA_SEQ_EVR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_SEQ_NUM", SWIG_From_int((int)(DELTA_SEQ_NUM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::DELTA_LOCATION_BASE", SWIG_From_int((int)(DELTA_LOCATION_BASE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_REPOMD", SWIG_From_int((int)(REPOSITORY_REPOMD)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_REPOMD_TYPE", SWIG_From_int((int)(REPOSITORY_REPOMD_TYPE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_REPOMD_LOCATION", SWIG_From_int((int)(REPOSITORY_REPOMD_LOCATION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_REPOMD_TIMESTAMP", SWIG_From_int((int)(REPOSITORY_REPOMD_TIMESTAMP)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_REPOMD_CHECKSUM", SWIG_From_int((int)(REPOSITORY_REPOMD_CHECKSUM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_REPOMD_OPENCHECKSUM", SWIG_From_int((int)(REPOSITORY_REPOMD_OPENCHECKSUM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REPOSITORY_REPOMD_SIZE", SWIG_From_int((int)(REPOSITORY_REPOMD_SIZE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PUBKEY_KEYID", SWIG_From_int((int)(PUBKEY_KEYID)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PUBKEY_FINGERPRINT", SWIG_From_int((int)(PUBKEY_FINGERPRINT)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PUBKEY_EXPIRES", SWIG_From_int((int)(PUBKEY_EXPIRES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PUBKEY_SIGNATURES", SWIG_From_int((int)(PUBKEY_SIGNATURES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PUBKEY_DATA", SWIG_From_int((int)(PUBKEY_DATA)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PUBKEY_SUBKEYOF", SWIG_From_int((int)(PUBKEY_SUBKEYOF)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SIGNATURE_ISSUER", SWIG_From_int((int)(SIGNATURE_ISSUER)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SIGNATURE_TIME", SWIG_From_int((int)(SIGNATURE_TIME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SIGNATURE_EXPIRES", SWIG_From_int((int)(SIGNATURE_EXPIRES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SIGNATURE_DATA", SWIG_From_int((int)(SIGNATURE_DATA)));
  SWIG_Tcl_SetConstantObj(interp, "solv::PRODUCT_REGISTER_FLAVOR", SWIG_From_int((int)(PRODUCT_REGISTER_FLAVOR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVABLE_INSTALLSTATUS", SWIG_From_int((int)(SOLVABLE_INSTALLSTATUS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::ID_NUM_INTERNAL", SWIG_From_int((int)(ID_NUM_INTERNAL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVID_META", SWIG_From_int((int)(SOLVID_META)));
  SWIG_Tcl_SetConstantObj(interp, "solv::SOLVID_POS", SWIG_From_int((int)(SOLVID_POS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REL_EQ", SWIG_From_int((int)(REL_EQ)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REL_GT", SWIG_From_int((int)(REL_GT)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REL_LT", SWIG_From_int((int)(REL_LT)));
  SWIG_Tcl_SetConstantObj(interp, "solv::REL_ARCH", SWIG_From_int((int)(REL_ARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_NAME", SWIG_From_int((int)(SELECTION_NAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_PROVIDES", SWIG_From_int((int)(SELECTION_PROVIDES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_FILELIST", SWIG_From_int((int)(SELECTION_FILELIST)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_CANON", SWIG_From_int((int)(SELECTION_CANON)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_DOTARCH", SWIG_From_int((int)(SELECTION_DOTARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_REL", SWIG_From_int((int)(SELECTION_REL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_INSTALLED_ONLY", SWIG_From_int((int)(SELECTION_INSTALLED_ONLY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_GLOB", SWIG_From_int((int)(SELECTION_GLOB)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_FLAT", SWIG_From_int((int)(SELECTION_FLAT)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_NOCASE", SWIG_From_int((int)(SELECTION_NOCASE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_SOURCE_ONLY", SWIG_From_int((int)(SELECTION_SOURCE_ONLY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Selection_SELECTION_WITH_SOURCE", SWIG_From_int((int)(SELECTION_WITH_SOURCE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Dataiterator_SEARCH_STRING", SWIG_From_int((int)(SEARCH_STRING)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Dataiterator_SEARCH_STRINGSTART", SWIG_From_int((int)(SEARCH_STRINGSTART)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Dataiterator_SEARCH_STRINGEND", SWIG_From_int((int)(SEARCH_STRINGEND)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Dataiterator_SEARCH_SUBSTRING", SWIG_From_int((int)(SEARCH_SUBSTRING)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Dataiterator_SEARCH_GLOB", SWIG_From_int((int)(SEARCH_GLOB)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Dataiterator_SEARCH_REGEX", SWIG_From_int((int)(SEARCH_REGEX)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Dataiterator_SEARCH_NOCASE", SWIG_From_int((int)(SEARCH_NOCASE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Dataiterator_SEARCH_FILES", SWIG_From_int((int)(SEARCH_FILES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Dataiterator_SEARCH_COMPLETE_FILELIST", SWIG_From_int((int)(SEARCH_COMPLETE_FILELIST)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Dataiterator_SEARCH_CHECKSUMS", SWIG_From_int((int)(SEARCH_CHECKSUMS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SOLVABLE", SWIG_From_int((int)(SOLVER_SOLVABLE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SOLVABLE_NAME", SWIG_From_int((int)(SOLVER_SOLVABLE_NAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SOLVABLE_PROVIDES", SWIG_From_int((int)(SOLVER_SOLVABLE_PROVIDES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SOLVABLE_ONE_OF", SWIG_From_int((int)(SOLVER_SOLVABLE_ONE_OF)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SOLVABLE_REPO", SWIG_From_int((int)(SOLVER_SOLVABLE_REPO)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SOLVABLE_ALL", SWIG_From_int((int)(SOLVER_SOLVABLE_ALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SELECTMASK", SWIG_From_int((int)(SOLVER_SELECTMASK)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_NOOP", SWIG_From_int((int)(SOLVER_NOOP)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_INSTALL", SWIG_From_int((int)(SOLVER_INSTALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_ERASE", SWIG_From_int((int)(SOLVER_ERASE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_UPDATE", SWIG_From_int((int)(SOLVER_UPDATE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_WEAKENDEPS", SWIG_From_int((int)(SOLVER_WEAKENDEPS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_MULTIVERSION", SWIG_From_int((int)(SOLVER_MULTIVERSION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_LOCK", SWIG_From_int((int)(SOLVER_LOCK)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_DISTUPGRADE", SWIG_From_int((int)(SOLVER_DISTUPGRADE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_VERIFY", SWIG_From_int((int)(SOLVER_VERIFY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_DROP_ORPHANED", SWIG_From_int((int)(SOLVER_DROP_ORPHANED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_USERINSTALLED", SWIG_From_int((int)(SOLVER_USERINSTALLED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_JOBMASK", SWIG_From_int((int)(SOLVER_JOBMASK)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_WEAK", SWIG_From_int((int)(SOLVER_WEAK)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_ESSENTIAL", SWIG_From_int((int)(SOLVER_ESSENTIAL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_CLEANDEPS", SWIG_From_int((int)(SOLVER_CLEANDEPS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_FORCEBEST", SWIG_From_int((int)(SOLVER_FORCEBEST)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_TARGETED", SWIG_From_int((int)(SOLVER_TARGETED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_NOTBYUSER", SWIG_From_int((int)(SOLVER_NOTBYUSER)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SETEV", SWIG_From_int((int)(SOLVER_SETEV)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SETEVR", SWIG_From_int((int)(SOLVER_SETEVR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SETARCH", SWIG_From_int((int)(SOLVER_SETARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SETVENDOR", SWIG_From_int((int)(SOLVER_SETVENDOR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SETREPO", SWIG_From_int((int)(SOLVER_SETREPO)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SETNAME", SWIG_From_int((int)(SOLVER_SETNAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_NOAUTOSET", SWIG_From_int((int)(SOLVER_NOAUTOSET)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Job_SOLVER_SETMASK", SWIG_From_int((int)(SOLVER_SETMASK)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Pool_POOL_FLAG_PROMOTEEPOCH", SWIG_From_int((int)(POOL_FLAG_PROMOTEEPOCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Pool_POOL_FLAG_FORBIDSELFCONFLICTS", SWIG_From_int((int)(POOL_FLAG_FORBIDSELFCONFLICTS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Pool_POOL_FLAG_OBSOLETEUSESPROVIDES", SWIG_From_int((int)(POOL_FLAG_OBSOLETEUSESPROVIDES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Pool_POOL_FLAG_IMPLICITOBSOLETEUSESPROVIDES", SWIG_From_int((int)(POOL_FLAG_IMPLICITOBSOLETEUSESPROVIDES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Pool_POOL_FLAG_OBSOLETEUSESCOLORS", SWIG_From_int((int)(POOL_FLAG_OBSOLETEUSESCOLORS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Pool_POOL_FLAG_IMPLICITOBSOLETEUSESCOLORS", SWIG_From_int((int)(POOL_FLAG_IMPLICITOBSOLETEUSESCOLORS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Pool_POOL_FLAG_NOINSTALLEDOBSOLETES", SWIG_From_int((int)(POOL_FLAG_NOINSTALLEDOBSOLETES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Pool_POOL_FLAG_HAVEDISTEPOCH", SWIG_From_int((int)(POOL_FLAG_HAVEDISTEPOCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Pool_POOL_FLAG_NOOBSOLETESMULTIVERSION", SWIG_From_int((int)(POOL_FLAG_NOOBSOLETESMULTIVERSION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Repo_REPO_REUSE_REPODATA", SWIG_From_int((int)(REPO_REUSE_REPODATA)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Repo_REPO_NO_INTERNALIZE", SWIG_From_int((int)(REPO_NO_INTERNALIZE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Repo_REPO_LOCALPOOL", SWIG_From_int((int)(REPO_LOCALPOOL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Repo_REPO_USE_LOADING", SWIG_From_int((int)(REPO_USE_LOADING)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Repo_REPO_EXTEND_SOLVABLES", SWIG_From_int((int)(REPO_EXTEND_SOLVABLES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Repo_REPO_USE_ROOTDIR", SWIG_From_int((int)(REPO_USE_ROOTDIR)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Repo_REPO_NO_LOCATION", SWIG_From_int((int)(REPO_NO_LOCATION)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Repo_SOLV_ADD_NO_STUBS", SWIG_From_int((int)(SOLV_ADD_NO_STUBS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_UNKNOWN", SWIG_From_int((int)(SOLVER_RULE_UNKNOWN)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_PKG", SWIG_From_int((int)(SOLVER_RULE_PKG)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_PKG_NOT_INSTALLABLE", SWIG_From_int((int)(SOLVER_RULE_PKG_NOT_INSTALLABLE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_PKG_NOTHING_PROVIDES_DEP", SWIG_From_int((int)(SOLVER_RULE_PKG_NOTHING_PROVIDES_DEP)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_PKG_REQUIRES", SWIG_From_int((int)(SOLVER_RULE_PKG_REQUIRES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_PKG_SELF_CONFLICT", SWIG_From_int((int)(SOLVER_RULE_PKG_SELF_CONFLICT)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_PKG_CONFLICTS", SWIG_From_int((int)(SOLVER_RULE_PKG_CONFLICTS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_PKG_SAME_NAME", SWIG_From_int((int)(SOLVER_RULE_PKG_SAME_NAME)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_PKG_OBSOLETES", SWIG_From_int((int)(SOLVER_RULE_PKG_OBSOLETES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_PKG_IMPLICIT_OBSOLETES", SWIG_From_int((int)(SOLVER_RULE_PKG_IMPLICIT_OBSOLETES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_PKG_INSTALLED_OBSOLETES", SWIG_From_int((int)(SOLVER_RULE_PKG_INSTALLED_OBSOLETES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_UPDATE", SWIG_From_int((int)(SOLVER_RULE_UPDATE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_FEATURE", SWIG_From_int((int)(SOLVER_RULE_FEATURE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_JOB", SWIG_From_int((int)(SOLVER_RULE_JOB)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_JOB_NOTHING_PROVIDES_DEP", SWIG_From_int((int)(SOLVER_RULE_JOB_NOTHING_PROVIDES_DEP)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_JOB_PROVIDED_BY_SYSTEM", SWIG_From_int((int)(SOLVER_RULE_JOB_PROVIDED_BY_SYSTEM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_JOB_UNKNOWN_PACKAGE", SWIG_From_int((int)(SOLVER_RULE_JOB_UNKNOWN_PACKAGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_JOB_UNSUPPORTED", SWIG_From_int((int)(SOLVER_RULE_JOB_UNSUPPORTED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_DISTUPGRADE", SWIG_From_int((int)(SOLVER_RULE_DISTUPGRADE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_INFARCH", SWIG_From_int((int)(SOLVER_RULE_INFARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_CHOICE", SWIG_From_int((int)(SOLVER_RULE_CHOICE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_LEARNT", SWIG_From_int((int)(SOLVER_RULE_LEARNT)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_JOB", SWIG_From_int((int)(SOLVER_SOLUTION_JOB)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_POOLJOB", SWIG_From_int((int)(SOLVER_SOLUTION_POOLJOB)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_INFARCH", SWIG_From_int((int)(SOLVER_SOLUTION_INFARCH)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_DISTUPGRADE", SWIG_From_int((int)(SOLVER_SOLUTION_DISTUPGRADE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_BEST", SWIG_From_int((int)(SOLVER_SOLUTION_BEST)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_ERASE", SWIG_From_int((int)(SOLVER_SOLUTION_ERASE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_REPLACE", SWIG_From_int((int)(SOLVER_SOLUTION_REPLACE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_REPLACE_DOWNGRADE", SWIG_From_int((int)(SOLVER_SOLUTION_REPLACE_DOWNGRADE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_REPLACE_ARCHCHANGE", SWIG_From_int((int)(SOLVER_SOLUTION_REPLACE_ARCHCHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_REPLACE_VENDORCHANGE", SWIG_From_int((int)(SOLVER_SOLUTION_REPLACE_VENDORCHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_SOLUTION_REPLACE_NAMECHANGE", SWIG_From_int((int)(SOLVER_SOLUTION_REPLACE_NAMECHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_POLICY_ILLEGAL_DOWNGRADE", SWIG_From_int((int)(POLICY_ILLEGAL_DOWNGRADE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_POLICY_ILLEGAL_ARCHCHANGE", SWIG_From_int((int)(POLICY_ILLEGAL_ARCHCHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_POLICY_ILLEGAL_VENDORCHANGE", SWIG_From_int((int)(POLICY_ILLEGAL_VENDORCHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_POLICY_ILLEGAL_NAMECHANGE", SWIG_From_int((int)(POLICY_ILLEGAL_NAMECHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_ALLOW_DOWNGRADE", SWIG_From_int((int)(SOLVER_FLAG_ALLOW_DOWNGRADE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_ALLOW_ARCHCHANGE", SWIG_From_int((int)(SOLVER_FLAG_ALLOW_ARCHCHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_ALLOW_VENDORCHANGE", SWIG_From_int((int)(SOLVER_FLAG_ALLOW_VENDORCHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_ALLOW_NAMECHANGE", SWIG_From_int((int)(SOLVER_FLAG_ALLOW_NAMECHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_ALLOW_UNINSTALL", SWIG_From_int((int)(SOLVER_FLAG_ALLOW_UNINSTALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_NO_UPDATEPROVIDE", SWIG_From_int((int)(SOLVER_FLAG_NO_UPDATEPROVIDE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_SPLITPROVIDES", SWIG_From_int((int)(SOLVER_FLAG_SPLITPROVIDES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_IGNORE_RECOMMENDED", SWIG_From_int((int)(SOLVER_FLAG_IGNORE_RECOMMENDED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_ADD_ALREADY_RECOMMENDED", SWIG_From_int((int)(SOLVER_FLAG_ADD_ALREADY_RECOMMENDED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_NO_INFARCHCHECK", SWIG_From_int((int)(SOLVER_FLAG_NO_INFARCHCHECK)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_BEST_OBEY_POLICY", SWIG_From_int((int)(SOLVER_FLAG_BEST_OBEY_POLICY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_NO_AUTOTARGET", SWIG_From_int((int)(SOLVER_FLAG_NO_AUTOTARGET)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_DUP_ALLOW_DOWNGRADE", SWIG_From_int((int)(SOLVER_FLAG_DUP_ALLOW_DOWNGRADE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_DUP_ALLOW_ARCHCHANGE", SWIG_From_int((int)(SOLVER_FLAG_DUP_ALLOW_ARCHCHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_DUP_ALLOW_VENDORCHANGE", SWIG_From_int((int)(SOLVER_FLAG_DUP_ALLOW_VENDORCHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_DUP_ALLOW_NAMECHANGE", SWIG_From_int((int)(SOLVER_FLAG_DUP_ALLOW_NAMECHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_KEEP_ORPHANS", SWIG_From_int((int)(SOLVER_FLAG_KEEP_ORPHANS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_BREAK_ORPHANS", SWIG_From_int((int)(SOLVER_FLAG_BREAK_ORPHANS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_FOCUS_INSTALLED", SWIG_From_int((int)(SOLVER_FLAG_FOCUS_INSTALLED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_YUM_OBSOLETES", SWIG_From_int((int)(SOLVER_FLAG_YUM_OBSOLETES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_FLAG_NEED_UPDATEPROVIDE", SWIG_From_int((int)(SOLVER_FLAG_NEED_UPDATEPROVIDE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_UNRELATED", SWIG_From_int((int)(SOLVER_REASON_UNRELATED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_UNIT_RULE", SWIG_From_int((int)(SOLVER_REASON_UNIT_RULE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_KEEP_INSTALLED", SWIG_From_int((int)(SOLVER_REASON_KEEP_INSTALLED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_RESOLVE_JOB", SWIG_From_int((int)(SOLVER_REASON_RESOLVE_JOB)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_UPDATE_INSTALLED", SWIG_From_int((int)(SOLVER_REASON_UPDATE_INSTALLED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_CLEANDEPS_ERASE", SWIG_From_int((int)(SOLVER_REASON_CLEANDEPS_ERASE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_RESOLVE", SWIG_From_int((int)(SOLVER_REASON_RESOLVE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_WEAKDEP", SWIG_From_int((int)(SOLVER_REASON_WEAKDEP)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_RESOLVE_ORPHAN", SWIG_From_int((int)(SOLVER_REASON_RESOLVE_ORPHAN)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_RECOMMENDED", SWIG_From_int((int)(SOLVER_REASON_RECOMMENDED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_REASON_SUPPLEMENTED", SWIG_From_int((int)(SOLVER_REASON_SUPPLEMENTED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Solver_SOLVER_RULE_RPM", SWIG_From_int((int)(SOLVER_RULE_RPM)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Alternative_SOLVER_ALTERNATIVE_TYPE_RULE", SWIG_From_int((int)(SOLVER_ALTERNATIVE_TYPE_RULE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Alternative_SOLVER_ALTERNATIVE_TYPE_RECOMMENDS", SWIG_From_int((int)(SOLVER_ALTERNATIVE_TYPE_RECOMMENDS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Alternative_SOLVER_ALTERNATIVE_TYPE_SUGGESTS", SWIG_From_int((int)(SOLVER_ALTERNATIVE_TYPE_SUGGESTS)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_IGNORE", SWIG_From_int((int)(SOLVER_TRANSACTION_IGNORE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_ERASE", SWIG_From_int((int)(SOLVER_TRANSACTION_ERASE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_REINSTALLED", SWIG_From_int((int)(SOLVER_TRANSACTION_REINSTALLED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_DOWNGRADED", SWIG_From_int((int)(SOLVER_TRANSACTION_DOWNGRADED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_CHANGED", SWIG_From_int((int)(SOLVER_TRANSACTION_CHANGED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_UPGRADED", SWIG_From_int((int)(SOLVER_TRANSACTION_UPGRADED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_OBSOLETED", SWIG_From_int((int)(SOLVER_TRANSACTION_OBSOLETED)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_INSTALL", SWIG_From_int((int)(SOLVER_TRANSACTION_INSTALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_REINSTALL", SWIG_From_int((int)(SOLVER_TRANSACTION_REINSTALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_DOWNGRADE", SWIG_From_int((int)(SOLVER_TRANSACTION_DOWNGRADE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_CHANGE", SWIG_From_int((int)(SOLVER_TRANSACTION_CHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_UPGRADE", SWIG_From_int((int)(SOLVER_TRANSACTION_UPGRADE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_OBSOLETES", SWIG_From_int((int)(SOLVER_TRANSACTION_OBSOLETES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_MULTIINSTALL", SWIG_From_int((int)(SOLVER_TRANSACTION_MULTIINSTALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_MULTIREINSTALL", SWIG_From_int((int)(SOLVER_TRANSACTION_MULTIREINSTALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_MAXTYPE", SWIG_From_int((int)(SOLVER_TRANSACTION_MAXTYPE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_SHOW_ACTIVE", SWIG_From_int((int)(SOLVER_TRANSACTION_SHOW_ACTIVE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_SHOW_ALL", SWIG_From_int((int)(SOLVER_TRANSACTION_SHOW_ALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_SHOW_OBSOLETES", SWIG_From_int((int)(SOLVER_TRANSACTION_SHOW_OBSOLETES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_SHOW_MULTIINSTALL", SWIG_From_int((int)(SOLVER_TRANSACTION_SHOW_MULTIINSTALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_CHANGE_IS_REINSTALL", SWIG_From_int((int)(SOLVER_TRANSACTION_CHANGE_IS_REINSTALL)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_OBSOLETE_IS_UPGRADE", SWIG_From_int((int)(SOLVER_TRANSACTION_OBSOLETE_IS_UPGRADE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_MERGE_VENDORCHANGES", SWIG_From_int((int)(SOLVER_TRANSACTION_MERGE_VENDORCHANGES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_MERGE_ARCHCHANGES", SWIG_From_int((int)(SOLVER_TRANSACTION_MERGE_ARCHCHANGES)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_RPM_ONLY", SWIG_From_int((int)(SOLVER_TRANSACTION_RPM_ONLY)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_ARCHCHANGE", SWIG_From_int((int)(SOLVER_TRANSACTION_ARCHCHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_VENDORCHANGE", SWIG_From_int((int)(SOLVER_TRANSACTION_VENDORCHANGE)));
  SWIG_Tcl_SetConstantObj(interp, "solv::Transaction_SOLVER_TRANSACTION_KEEP_ORDERDATA", SWIG_From_int((int)(SOLVER_TRANSACTION_KEEP_ORDERDATA)));
  return TCL_OK;
}
SWIGEXPORT int Solv_SafeInit(Tcl_Interp *interp) {
  return SWIG_init(interp);
}

